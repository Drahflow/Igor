#!/home/drahflow/nbg-os/igor/loaded

{ # ==parentBlock
  < map ==?f map ==?e list ==?d map ==?v _ ==?parent >'
} /childBlock deffd
< map ==?c map ==?assertions > childBlock ==currentBlock

< map ==:cache { _ cache .has not { _ _ cache =[] } rep cache * } > -- /makeUnique deffd

<
  { sys .linux .gettimeofday -- 1000000 mul add } /t deffd
  < { == }' > ==time =*setTime
  < { == }' > ==count =*setCount
  { ==l 0 l setTime 0 l setCount 
    { =*f { t ==start f t start sub time l . add l setTime count l . 1 add l setCount } }
    quoted not { * } rep
  }
  { time keys { _ dump _ time -01 . txt .produce .u " μs" cat dump count -01 . txt .produce .u " calls" cat dump } each }
> -- /perfstats deffd "τ" defq

<
  txt .consume .|hu "%" defq
  { "2120" "-" | |le "021" "-" | |ge |and } /in defq
  { "Unconfigured peek/take/get/set/noErr/snip" die } -000000 =*peek =*take =*get =*set =*noErr =*snip

  # parser generator
  { _ sys .typed .type 1 eq { ==str { 1 ==r str { peek eq r and =r take }' each r _ |noErr rep }' } { }" ? * } /lit deffd
  { lit =*p { get ==s [ p { ] _ len dearray }" { ] -- s set }" ? * 1 } } ",?" deffd
  { lit =*p { get ==s { get =s [ p }" { ] _ len dearray }" loop ] -- s set 1 } } ",*" deffd
  { _ ,* ,; } ",+" deffd
  { lit =*q lit =*p { get ==s [ p { ] _ len dearray 1 }" { ] -- s set q }" ? * } } ",|" deffd
  { 0 } ==:ZERO { lit ==q lit =*p { p q ZERO ? * }' } ",;" deffd
  { [ [ }" { ] |lit each ] ",;" | fold }" -01 ",[" deffd ",]" deffd
  { defvst }' =*:defp
  {
    ==name "}'" | * { ,[ }' -01 ; { ,] }' ; { * _ name "_make" cat defp * }_ name "_make" cat defp
    "{" | * name "_make" cat "|" | "*" | "}'" | * name defp
  } "}==" defq
  "{" | "(" defq { 1 "}'" | * }' ")" defq

  { lit =*p lit =*q { get ==s
    { get =s [ p { ] -- s set [ 0 }' { ] -- s set [ q }' ? * }' { ] _ len dearray }' loop ] -- s set 1
  } } /upto deffd

  # compare Specification of the Metamath Language
  { { peek take %24 neq }" { }" loop 1 }" ==sequenceEndingInDollar
  { peek take ==c c %09 eq c %0A eq or c %0C eq or c %0D eq or c %20 eq or } ==whitechar
  { peek take ==c c %41 %5A in c %61 %7A in or c %30 %39 in or c %2D eq or c %5F eq or c %2E eq or } ==labelchar
  { peek take ==c c %41 %5A in c %3F eq or } ==compressedchar
  { peek take ==c c %24 neq c %20 gt and c %7F lt and } ==mathchar

  { "$(" sequenceEndingInDollar ")" upto ")" white }==comment
  { whitechar comment ,| include ,| ,+ }==white
  { "$[" white ( get ) mathchar ,* ( get snip "including: " dump _ dump parseFile ) white "$]" white }==include

  { ( get ) mathchar ,* ( get snip makeUnique ) white }==mathsymbol
  { ( get ) labelchar ,* ( get snip makeUnique ) white }==label

  { "$c" white ,[ mathsymbol ( _ "$c " -01 cat dump 1 -01 currentBlock .c =[] ) ,] ,+ "$." white }==cstatement
  { "$v" white ,[ mathsymbol ( _ "$v " -01 cat dump 1 -01 currentBlock .v =[] ) ,] ,+ "$." white }==vstatement
  { label "$f" white ( _ "$f " -01 cat dump [ ) mathsymbol mathsymbol ( ] -01 currentBlock .f =[] ) "$." white }==fstatement
  { label "$e" white ( _ "$e " -01 cat dump [ ) mathsymbol mathsymbol ,* ( ] -01 currentBlock .e =[] ) "$." white }==estatement
  { "$d" white ( [ ) mathsymbol mathsymbol ,+ ( ] currentBlock .d .append1 ) "$." white }==dstatement
  { label "$a" white ( _ "$a " -01 cat dump [ ) mathsymbol mathsymbol ,* ( ]
    < currentBlock ==ctx ==thm { "Assumption has no proof" die } =*proof
      { mandatoryHypotheses ==hyps }' { mandatoryDisjunct ==disj }' { allDisjunct ==allDisj }' > -01*02*03*0
    -01 currentBlock .assertions =[] ) "$." white
  }==astatement

  { "?" ( "?" ) white }==questionmark
  { ( [ ) label questionmark ,| ,* ( ] { -- }_ ) }==proof
  { "(" white ( [ ) label ,* ( ] ) ")" white ( [ ) ,[ ,[ ( get ) compressedchar ( get snip ) ,] ,+ white ,] ,* ( ] |cat fold
    < ==data _ ==labels len ==labelCount { _ ==hypotheses len ==hypCount
      [ 0 data { ==c
        [
          { c %41 ge c %54 le and } { 20 mul c %40 sub add _ dump ==n
          [
            { n 1 sub hypCount lt } { n 1 sub hypotheses * }
            { n 1 sub hypCount sub labelCount lt } { n 1 sub hypCount sub labels * } 
            { 1 } { n 1 sub hypCount sub labelCount sub txt .produce .u "@ " -01 cat }
          ] conds
          0 }
          { c %55 ge c %59 le and } { 5 mul c %54 sub add _ dump }
          { c %5A eq } { -- "!" 0 }
          { c %3F eq } { -- "?" 0 }
          { 1 } { "Invalid compressed proof" die }
        ] conds
      } each -- ]
    } > -- ) }==compressedproof
  { label "$p" white ( _ "$p " -01 cat dump [ ) mathsymbol mathsymbol ,* ( ] ) "$="
    white compressedproof proof ,| (
    < currentBlock ==ctx -01 ==thm =*proof
      { mandatoryHypotheses ==hyps }' { mandatoryDisjunct ==disj }' { allDisjunct ==allDisj }' > -01*02*03*0
    # -101 "simpl31" eq { perfstats "done" die } rep
    # -101 "vtoclga" eq { perfstats "done" die } rep
    # _ "a17d" eq { -101 verifyProof "done" die } rep # TODO: this line is just debugging
    # -100 verifyProof dump
    -01 currentBlock .assertions =[] ) "$." white
    }==pstatement

  { "${" ( currentBlock childBlock =currentBlock ) white statements ( currentBlock .parent =currentBlock ) "$}" white }==block
  { [ estatement pstatement dstatement block vstatement fstatement astatement cstatement white ] ",|" | fold ,* }==statements

  { ":" via
    "" ==s 0 ==i 0 ==slen 0 ==last 0 ==eof
    {
      i slen lt not { eof not { s 1024 1024 mul :read cat =s "Just read to: " dump s len _ =slen dump } rep }" rep
      i slen lt { i s * }" { 1 neg 1 =eof }" ? *
    }' =peek
    { i 1 add =i }' =take { i }' =get { =i }' =set { i =last }' =noErr { s str .infix }' =snip

    { block statements * { i s len neq { ??metamath.trailing-garbage } rep } { ??metamath } ? * }
      { -- < last s str .postfix ==remaining > ??!' } ?!metamath
  }
> -- /parse deffd

{ sys .file _ ":" via -01 :open parse :close } /parseFile deffd

{ -01 ==sym 0 ==found { _ .?v found not and } { _ .v sym -01 .has found or =found .parent } loop -- found } /isVar deffd
{ -01 ==lbl 0 ==found { _ .?e found not and } { _ .e lbl -01 .has found or =found .parent } loop -- found } /isEHyp deffd
{ -01 ==lbl 0 ==found { _ .?f found not and } { _ .f lbl -01 .has found or =found .parent } loop -- found } /isFHyp deffd
{ -01 ==lbl { _ .e lbl -01 .has not } { .parent } loop .e lbl -01 * } /getEHyp deffd
{ -01 ==lbl { _ .f lbl -01 .has not } { .parent } loop .f lbl -01 * } /getFHyp deffd
{ .c .has } /isConst deffd

{ _ ==pstm .ctx ==ctx map _ ==vars # will be returned
  { ==sym [
    { sym ctx isVar } { 1 sym vars =[] }
    { sym ctx isConst } { }
    { 1 } { "Undeclared symbol: " sym cat die }
  ] conds } ==collect

  pstm .thm collect each
  ctx { _ .?e } { _ .e { collect each } each .parent } loop --
} /mandatoryVariables deffd

{ _ ==pstm mandatoryVariables ==vars list _ ==hyps # will be returned
  [ pstm .ctx { _ .?e } { _ .parent } loop -- ] reverse ==ctxs
  ctxs { _ ==ctx .f dom { _ ==k ctx .f * 1 -01 * vars .has { k hyps .append } rep } each } each
  ctxs { .e dom { hyps .append } each } each
} /mandatoryHypotheses deffd

{ ==pstm list _ ==disj # will be returned
  [ pstm .ctx { _ .?d } { _ .parent } loop -- ] reverse ==ctxs
  ctxs { .d { ==dstm
    0 dstm len range { ==i
      i 1 add dstm len range { ==j
        [ i dstm * j dstm * ] disj .append1
      } each
    } each
  } each } each
} /allDisjunct deffd

{ _ ==pstm mandatoryVariables ==vars list _ ==disj # will be returned
  # "Vars: " dump
  # vars dom dump
  [ pstm .ctx { _ .?d } { _ .parent } loop -- ] reverse ==ctxs
  ctxs { .d { # _ dump
    ==dstm
    0 dstm len range { _ ==i dstm * vars .has {
      i 1 add dstm len range { _ ==j dstm * vars .has {
        [ i dstm * j dstm * ] disj .append1
      } rep } each
    } rep } each
  } each } each
} /mandatoryDisjunct deffd

{ _ ==pstm _ .hyps ==hyps .disj ==disj
  "Mandatory hyps: " dump
  hyps |dump each
  "Mandatory disjunct: " dump
  disj |dump each
  "^^^^^^^^^^^^^^^^^^^" dump

  hyps pstm .proof
} /computeProof deffd

{ _ ==pstm _ .ctx ==ctx computeProof
    list ==stack # the verification stack
    list ==savedTheorems # Z-saved theorems
  _ dump { ==lbl
    [
      { lbl ctx isEHyp } { lbl ctx getEHyp stack .append1 }
      { lbl ctx isFHyp } { lbl ctx getFHyp stack .append1 }
      { lbl "!" eq } { stack len 1 sub stack * savedTheorems .append1 }
      { lbl len _ { -- 0 lbl * 0 "@" * eq } rep }
        { 2 lbl str .postfix txt .consume .u savedTheorems * stack .append1 }
      { lbl ctx .assertions .has } {
        "Applying: " lbl cat dump
        
        lbl ctx .assertions * _ ==ass .hyps ==hyps
        map ==substitution

        "Mandatory hypotheses:" dump
        hyps dump
        0 hyps len range
          _ { hyps * dump } each
        _ { _ ==i hyps * _ ==h ass .ctx isFHyp {
            h ass .ctx getFHyp ==mask
            stack len hyps len sub i add stack * ==target
            0 mask * 0 target * neq { mask dump target dump "Constant symbol mismatch" die } rep
            [ 1 target len range { target * } each ] 1 mask * substitution =[]
          } rep } each

          substitution dom { ==k k " => " cat k substitution * { " " -01 cat cat } fold cat dump } each

          { _ ==i hyps * _ ==h ass .ctx isEHyp {
              stack len hyps len sub i add stack * ==target
              [ h ass .ctx getEHyp { # ==sym
                _ ass .ctx isVar { substitution * _ len dearray } rep
              } each ] ==mask
              mask target eq all not { mask dump target dump "Hypthesis does not match stack" die } rep
          } rep } each

        ass .disj { =*d
          "Checking disjunct " 0 d cat " <=> " cat 1 d cat dump
          0 d substitution * { ass .ctx isVar } grep { ==v
            1 d substitution * { ass .ctx isVar } grep { ==w
                v " :=: " w cat cat dump
                v w eq { "Disjunct variable requirement broken" die } rep
                [ pstm .allDisj { =*d 0 d v eq 1 d w eq and 0 d w eq 1 d v eq and or } each ] any not
                  { "Disjunct variable requirement not carried" die } rep
            } each
          } each
        } each

        "All checks ok. Inserting new statement." dump

        hyps len { stack .pop } rep
        [ ass .thm { _ ass .ctx isVar { substitution * _ len dearray } rep } each ] stack .append1
      }
      { 1 } { "Invalid proof step: " lbl cat die }
    ] conds
    
    "Proof stack" dump
    stack { { " " -01 cat cat } fold dump } each
    "^^^^^^^^^^^" dump
  } each

  [
    { stack len 1 neq } { "Stack not empty after proof." dump 0 }
    { 0 stack * pstm .thm eq all not } { "Final stack contents: " dump 0 stack * dump "and theorem: " pstm .thm dump "do not match" dump 0 }
    { 1 } { 1 }
  ] conds
} /verifyProof deffd

sys .|argv len 2 neq { "usage: ./igor input.mm" die } rep
1 sys .argv * parseFile
#
# {
#   sys .argv len { 0 sys .argv * } { "/proc/self/fd/0" } ? * include
#   0 sys .exit
# }' "igor.loaded" sys .freeze

# vim: syn=elymas
