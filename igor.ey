#!/home/drahflow/elymas/elymas/loaded

{ { _ sys .asm .rawAddress txt .produce .u defv }' scope }
<
  /generate deffd
  0 ==m # placeholder, zero value is never read
  { =m [ m .v keys { m .v -01 . } each ] }' "#dom" defmd
  { =m m .v ==v =*f v keys { v -01 . f }' each } "#each" defmd
  { 0 } "#istart" deffd
  { =m m .v keys len eq }' "#iend" defmd
  { 1 add }" "#istep" deffd
  { =m m .v keys * }' "#itrans" defmd
  { =m m .v -01 sys .asm .rawAddress txt .produce .u .?' }' /has defmd
  { =m m .v ==v "#iclone" | * ==n v keys { _ v -01 . -01 n =[] } each n }' /clone defmd
  { < generate ==v "put" =* > }' _ "#iclone" deffd
> -- /objset deffd

{ { 0 } ? * } /andif deffd

map ==constants
map ==assertions
objset ==blocks
{ # ==parentBlock
  < map ==f map ==e list ==d map ==v _ ==parent >' _ blocks .put
} /childBlock deffd
< > childBlock _ ==emptyBlock ==currentBlock

< map ==:cache { _ cache .has not { _ _ cache =[] }" rep cache * }' > -- /makeUnique deffd

<
  { sys .linux .gettimeofday -- 1000000 mul add } /t deffd
  < { == }' > ==time =*setTime
  < { == }' > ==count =*setCount
  { ==l 0 l setTime 0 l setCount 
    { =*f { t ==start f t start sub time l . add l setTime count l . 1 add l setCount } }
    quoted not { * } rep
  }
  { time keys { _ dump _ time -01 . txt .produce .u " μs" cat dump count -01 . txt .produce .u " calls" cat dump } each }
> -- /perfstats deffd "τ" defq

<
  { -- } "$$" defq # { ==name _ "$" name cat " " cat -01 cat dump } "$$" deffd

  txt .consume .|hu "%" defq
  { "2120" "-" | |le "021" "-" | |ge |and } /in defq
  { "Unconfigured peek/take/get/set/noErr/snip" die } -000000 =*peek =*take =*get =*set =*noErr =*snip { } =*setupInput
  { | { ==:f /f sys .executeIdentifier _ * -- } * }" "@" deffd
  str .|infix =*:infix

  # parser generator
  { _ sys .typed .type 1 eq { ==str { 1 ==r str { peek eq r and =r take }' each r _ |noErr rep }' } { }" ? * } /lit deffd
  { lit =*p { get , p { --, ,-- }" { ,--- set }" ? * 1 }' } ",?" deffd
  { lit =*p { { get , p }' { --, ,-- }' loop ,--- set 1 }' } ",*" deffd
  { _ ,* ,; } ",+" deffd
  { lit =*q lit =*p { get , p { --, ,-- 1 }" { ,--- set q }" ? * }' } ",|" deffd
  { lit ==q lit =*p { p q { 0 }" ? * }' } ",;" deffd
  { [ [ }" { ] |lit each ] ",;" | fold }" -01 ",[" deffd ",]" deffd
  { defvst }' =*:defp
  {
    ==name "}'" | * { ,[ }' -01 ; { ,] }' ; { * _ name "_make" cat defp * }_ name "_make" cat defp
    "{" | * name "_make" cat "|" | "*" | "}'" | * name defp
  } "}==" defq
  "{" | "(" defq { 1 "}'" | * }' ")" defq

  { lit =*p lit =*q {
    { get , p { ,--- _ set , 0 }" { ,--- _ set , q }" ? * }' { --, ,-- }' loop ,--- set 1
  }' } /upto deffd

  # compare Specification of the Metamath Language
  { { peek take %24 neq }' { }' loop 1 }" ==sequenceEndingInDollar
  { peek take ==c c %09 eq c %0A eq or c %0C eq or c %0D eq or c %20 eq or } ==whitechar
  { peek take ==c c %41 %5A in c %61 %7A in or c %30 %39 in or c %2D eq or c %5F eq or c %2E eq or } ==labelchar
  { peek take ==c c %41 %5A in c %3F eq or } ==compressedchar
  { peek take ==c c %24 neq c %20 gt and c %7F lt and } ==mathchar

  { "$(" sequenceEndingInDollar ")" upto ")" white }==comment
  { whitechar comment ,| include ,| ,+ }==white
  { "$[" white ( |setupInput get ) mathchar ,* (
    get snip "including: " -1101 cat dump parseFile "finished " -01 cat dump *
  ) white "$]" white }==include

  { ( get ) mathchar ,+ ( get snip makeUnique ) white }==mathsymbol
  { ( get ) labelchar ,+ ( get snip makeUnique ) white }==label

  { "$c" white ,[ mathsymbol ( $$c 1 -01 constants =[] ) ,] ,+ "$." white }==cstatement
  { "$v" white ,[ mathsymbol ( $$v 1 -01 currentBlock .v =[] ) ,] ,+ "$." white }==vstatement
  { label "$f" white ( $$f [ ) mathsymbol mathsymbol ( ] -01 currentBlock .f =[] ) "$." white }==fstatement
  { label "$e" white ( $$e [ ) mathsymbol mathsymbol ,* ( ] -01 currentBlock .e =[] ) "$." white }==estatement
  { "$d" white ( [ ) mathsymbol mathsymbol ,+ ( ] currentBlock .d .append1 ) "$." white }==dstatement
  { label "$a" white ( $$a [ ) mathsymbol mathsymbol ,* ( ]
    < "a" ==type currentBlock ==ctx ==thm { "Assumption has no proof" die }" =*proof _ ==name
      { mandatoryHypotheses ==hyps }' { mandatoryDisjunct ==disj }' { allDisjunct ==allDisj }' > -01*02*03*0
    -01 assertions =[] ) "$." white
  }==astatement

  { "?" ( "?" ) white }==questionmark
  { ( [ ) label questionmark ,| ,* ( ] { -- }_ ) }==proof
  { "(" white ( [ ) label ,* ( ] ) ")" white ( [ ) ,[ ( get ) ,[ compressedchar ,] ,+ ( get snip ) white ,] ,* ( ] |cat fold
    < ==data _ ==labels len ==labelCount { _ ==hypotheses len ==hypCount
      [ 0 data { ==c
        [
          { c %41 ge c %54 le and } { 20 mul c %40 sub add _ dump ==n
          [
            { n 1 sub hypCount lt } { n 1 sub hypotheses * }
            { n 1 sub hypCount sub labelCount lt } { n 1 sub hypCount sub labels * } 
            { 1 } { n 1 sub hypCount sub labelCount sub txt .produce .u "@ " -01 cat }
          ] conds
          0 }
          { c %55 ge c %59 le and } { 5 mul c %54 sub add _ dump }
          { c %5A eq } { -- "!" 0 }
          { c %3F eq } { -- "?" 0 }
          { 1 } { "Invalid compressed proof" die }
        ] conds
      } each -- ]
    } > -- ) }==compressedproof
  { label "$p" white ( $$p [ ) mathsymbol mathsymbol ,* ( ] ) "$="
    white compressedproof proof ,| (
    < "p" ==type currentBlock ==ctx -01 ==thm =*proof _ ==name
      { mandatoryHypotheses ==hyps }' { mandatoryDisjunct ==disj }' { allDisjunct ==allDisj }' > -01*02*03*0
    # -101 "simpl31" eq { perfstats "done" die } rep
    # -101 "vtoclga" eq { perfstats "done" die } rep
    # _ "a17d" eq { -101 verifyProof "done" die } rep # TODO: this line is just debugging
    # -100 verifyProof dump
    -01 assertions =[] ) "$." white
  }==pstatement

  { "${" ( currentBlock childBlock =currentBlock ) white statements ( currentBlock .parent =currentBlock ) "$}" white }==block
  { [ estatement pstatement dstatement block vstatement fstatement astatement cstatement white ] ",|" | fold ,* }==statements

  { ":" via
    "" ==s 0 ==i 0 ==slen 0 ==last 0 ==eof
    {
      {
        i slen lt not {
          eof not {
            s 1024 1024 mul :read cat =s
            s len _ =slen
                    txt .produce .u "Just read to: " -01 cat dump }" rep
        }" rep
        i slen lt { i s * }" { 1 neg 1 =eof }" ? *
      }' =peek
      { i 1 add =i }' =take { i }' =get { =i }' =set { i =last }' =noErr { s infix }' =snip
    } _ =setupInput *

    { statements * { i s len neq { ??metamath.trailing-garbage } rep } { ??metamath } ? * }
      { -- < last s str .postfix ==remaining > ??!' } ?!metamath
  }
> -- /parse deffd

{ sys .file _ ":" via -01 :open parse :close } /parseFile deffd

{ ==ctx ==sym 0 ==found { ctx .?'v found not and }' { sym ctx .v ==v v .has found or =found ctx .parent =ctx }' loop found } /isVar deffd
{ ==ctx ==lbl 0 ==found { ctx .?'e found not and }' { lbl ctx .e ==e e .has found or =found ctx .parent =ctx }' loop found } /isEHyp deffd
{ ==ctx ==lbl 0 ==found { ctx .?'f found not and }' { lbl ctx .f ==f f .has found or =found ctx .parent =ctx }' loop found } /isFHyp deffd
{ -01 ==lbl { _ .e lbl -01 .has not }' { .parent }' loop .e lbl -01 * } /getEHyp deffd
{ -01 ==lbl { _ .f lbl -01 .has not }' { .parent }' loop .f lbl -01 * } /getFHyp deffd
{ constants .has }' /isConst deffd

{ _ ==pstm .ctx ==ctx map _ ==vars # will be returned
  { ==sym [
    { sym ctx isVar }' { 1 sym vars =[] }'
    { sym isConst }' { }'
    { 1 }' { "Undeclared symbol: " sym cat die }'
  ] conds } ==collect

  pstm .thm collect each
  ctx { _ .?'e }' { _ .e { collect each }' each .parent }' loop --
} /mandatoryVariables deffd

{ _ ==pstm mandatoryVariables ==vars list _ ==hyps # will be returned
  [ pstm .ctx { _ .?'e }' { _ .parent }' loop -- ] reverse ==ctxs
  ctxs { _ ==ctx .f dom { _ ==k ctx .f * 1 -01 * vars .has { k hyps .append1 }' rep } each } each
  ctxs { .e dom { hyps .append1 }' each }' each
} /mandatoryHypotheses deffd

{ ==pstm list _ ==disj # will be returned
  [ pstm .ctx { _ .?'d }' { _ .parent }' loop -- ] reverse ==ctxs
  ctxs { .d { _ len ==l ==dstm
    0 l range { ==i
      i 1 add l range { ==j
        [ i dstm * j dstm * ] disj .append1
      } each
    } each
  } each }' each
} /allDisjunct deffd

{ _ ==pstm mandatoryVariables ==vars list _ ==disj # will be returned
  # "Vars: " dump
  # vars dom dump
  [ pstm .ctx { _ .?'d }' { _ .parent }' loop -- ] reverse ==ctxs
  ctxs { .d { # _ dump
    ==dstm
    0 dstm len range { _ ==i dstm * vars .has {
      i 1 add dstm len range { _ ==j dstm * vars .has {
        [ i dstm * j dstm * ] disj .append1
      }' rep } each
    }' rep } each
  } each }' each
} /mandatoryDisjunct deffd

{ _ ==pstm _ .hyps ==hyps .disj ==disj
  "Mandatory hyps: " dump
  hyps |dump each
  "Mandatory disjunct: " dump
  disj |dump each
  "^^^^^^^^^^^^^^^^^^^" dump

  hyps pstm .proof
} /computeProof deffd

{ _ ==pstm _ .ctx ==ctx computeProof
    list ==stack # the verification stack
    list ==savedTheorems # Z-saved theorems
  _ dump { ==lbl
    [
      { lbl ctx isEHyp } { lbl ctx getEHyp stack .append1 }
      { lbl ctx isFHyp } { lbl ctx getFHyp stack .append1 }
      { lbl "!" eq } { stack len 1 sub stack * savedTheorems .append1 }
      { lbl len _ { -- 0 lbl * 0 "@" * eq } rep }
        { 2 lbl str .postfix txt .consume .u savedTheorems * stack .append1 }
      { lbl assertions .has } {
        "Applying: " lbl cat dump
        
        lbl assertions * _ ==ass .hyps ==hyps
        map ==substitution

        "Mandatory hypotheses:" dump
        hyps dump
        0 hyps len range
          _ { hyps * dump } each
        _ { _ ==i hyps * _ ==h ass .ctx isFHyp {
            h ass .ctx getFHyp ==mask
            stack len hyps len sub i add stack * ==target
            0 mask * 0 target * neq { mask dump target dump "Constant symbol mismatch" die } rep
            [ 1 target len range { target * } each ] 1 mask * substitution =[]
          } rep } each

          substitution dom { ==k k " => " cat k substitution * { " " -01 cat cat } fold cat dump } each

          { _ ==i hyps * _ ==h ass .ctx isEHyp {
              stack len hyps len sub i add stack * ==target
              [ h ass .ctx getEHyp { # ==sym
                _ ass .ctx isVar { substitution * _ len dearray } rep
              } each ] ==mask
              mask target eq all not { mask dump target dump "Hypthesis does not match stack" die } rep
          } rep } each

        ass .disj { =*d
          "Checking disjunct " 0 d cat " <=> " cat 1 d cat dump
          0 d substitution * { ass .ctx isVar } grep { ==v
            1 d substitution * { ass .ctx isVar } grep { ==w
                v " :=: " w cat cat dump
                v w eq { "Disjunct variable requirement broken" die } rep
                [ pstm .allDisj { =*d 0 d v eq 1 d w eq and 0 d w eq 1 d v eq and or } each ] any not
                  { "Disjunct variable requirement not carried" die } rep
            } each
          } each
        } each

        "All checks ok. Inserting new statement." dump

        hyps len { stack .pop } rep
        [ ass .thm { _ ass .ctx isVar { substitution * _ len dearray } rep } each ] stack .append1
      }
      { 1 } { "Invalid proof step: " lbl cat die }
    ] conds
    
    "Proof stack" dump
    stack { { " " -01 cat cat } fold dump } each
    "^^^^^^^^^^^" dump
  } each

  [
    { stack len 1 neq } { "Stack not empty after proof." dump 0 }
    { 0 stack * pstm .thm eq all not } { "Final stack contents: " dump 0 stack * dump "and theorem: " pstm .thm dump "do not match" dump 0 }
    { 1 } { 1 }
  ] conds
} /verifyProof deffd

{
  sys .|argv len 2 neq { "usage: ./igor input.mm" die } rep
  1 sys .argv * parseFile
} { _ dump _ keys dump .remaining die } ?!metamath

{ =*f 0 ==computed "" ==?result {
  computed not { 1 =computed f =result } rep
  result
} } /memoized deffst

{ ==ctx map _ ==result # returned
  [ ctx { _ .?'e }' { _ .parent }' loop -- ] reverse ==ctxs
  ctxs { _ ==c .f _ =*fs dom { _ fs -01 result =[] } each } each
} /collectFHyps deffst

{ ==ctx map _ ==result # returned
  [ ctx { _ .?'e }' { _ .parent }' loop -- ] reverse ==ctxs
  ctxs { _ ==c .e _ =*es dom { _ es -01 result =[] } each } each
} /collectEHyps deffst

<
  { [ } "[|" deffd { ] |cat fold } "|]" deffd

  emptyBlock ==renderContext
  emptyBlock ==userContext
  emptyBlock ==proofContext

  { ==name
    [
      { name constants .has } {
        [| "\e[37m" name "\e[0m" |]
      }
      { name assertions .has } {
        name assertions * ==a
        [
          { a .type "p" eq } { [| "\e[36m" name "\e[0m" |] }
          { a .type "a" eq } { [| "\e[31m" name "\e[0m" |] }
          { 1 } { name }
        ] conds
      }
      { name renderContext isVar } { [| "\e[32m" name "\e[0m" |] }
      { name "^\\$" regex } { [| "\e[33m" name "\e[0m" |] }
      { 1 } { name }
    ] conds
  } /renderName deffd

  sys .out .|writeall /out deffd

  { -- } /showBlock deffd

  { ==a
    a .ctx _ =renderContext _ =userContext showBlock
    [| "assuming:\n" |] out
    a .hyps { ==hyp
      [
        { hyp userContext isEHyp } {
          [| "$e " hyp renderName "\n" |] out
          [| hyp userContext getEHyp { renderName " " } each "\n" |] out
        }
        { hyp userContext isFHyp } {
          [| "$f " hyp renderName "\n" |] out
          [| hyp userContext getFHyp { renderName " " } each "\n" |] out
        }
        { 1 } {
          [| "\e[31mcould not resolve hypothesis:\e[0m " hyp "\n" |] out
        }
      ] conds
    } each
    [| "gives:\n" |] out
    [| a .thm { renderName " " } each "\n" |] out
    " " ==sep
    [| "mandatory disjunct:" a .disj { =*d sep ", " =sep 0 d renderName " <!> " 1 d renderName } each "\n" |] out
    " " =sep
    [| "all disjunct:" a .allDisj { =*d sep ", " =sep 0 d renderName " <!> " 1 d renderName } each "\n" |] out
  } /showAssertion deffd

  { ==p
    p showAssertion
  } /showProposition deffd

  { ==name
    [
      { name constants .has } {
        [| "$c " name renderName "\n" |] out
      }
      { name assertions .has } {
        name assertions * ==a
        [
          { a .type "p" eq } { [| "$p " name renderName "\n" |] out a showProposition }
          { a .type "a" eq } { [| "$a " name renderName "\n" |] out a showAssertion }
          { 1 } { [| name " is an assertion of unknown type (probably a bug)\n" |] out }
        ] conds
      }
      { name userContext isEHyp } {
        [| "$e " name renderName "\n" |] out
        [| name userContext getEHyp { renderName " " } each "\n" |] out
      }
      { name userContext isFHyp } {
        [| "$f " name renderName "\n" |] out
        [| name userContext getFHyp { renderName " " } each "\n" |] out
      }
      { name userContext isVar } {
        [| "$v " name renderName "\n" |] out
      }
      { 1 } {
        [| name " is not known" "\n" |] out
      }
    ] conds
  } /show deffd

  { ==prompt
    0 ==numberRead
    { numberRead not } {
      prompt "> " cat sys .out .writeall
      63356 sys .in .read ==input
      input "^(\\d+)\n" regex { 1 =numberRead txt .consume .u } rep
    } loop
  } /readNumber deffd

  { ==assertion ==tokens list ==result
    assertion .thm { -- 0 } '*0.0 ==starts
    assertion .thm { -- 0 } '*0.0 ==ends
    assertion .thm len ==tokenCount

    { ==i
      i assertion .thm * ==var
      var constants .has {
        i 0 eq { 0 } { i 1 sub ends * } ? * ==pos
        pos tokens * var eq {
          pos i starts =[]
          pos 1 add i ends =[]
          i 1 add handleToken
        } rep
      } {
        i 0 eq { 0 } { i 1 sub ends * } ? * ==start
        start i starts =[]
        start tokens len 1 add range {
          i ends =[]
          i 1 add handleToken
        } each
      } ? *
    } /moveToken deffst

    { ==i
      i tokenCount eq not {
        i moveToken
      } {
        tokenCount 1 sub ends * tokens len eq {
          map ==substitution
          1 ==valid
          0 tokenCount range { ==j
            j assertion .thm * ==var
            var constants .has not {
              var substitution .has {
                j starts * j ends * range tokens * ==newValue
                var substitution * ==oldValue
                newValue len oldValue len eq {
                  newValue oldValue eq all valid and =valid
                } {
                  0 =valid
                } ? *
              } {
                j starts * j ends * range tokens * var substitution =[]
              } ? *
            } rep
          } each

          valid {
            substitution dom { ==var
              0 var substitution * var variables * logicParsers * * { var substitution * len eq valid and =valid -- } { 0 =valid } ? *
            } each
          } rep

          valid { substitution result .append1 } rep
        } rep
      } ? *
    } /handleToken deffst

    0 handleToken

    result
  } /possibleSubstitutions deffd

  { ==substitution ==tokens
    [ tokens { _ substitution .has { substitution * _ len dearray } rep } each ]
  } /applySubstitution deffst

  { <
    ==thm < > ==resolution 1 ==isopen

    { < > =resolution 1 =isopen } =*open
    { =resolution 0 =isopen } =*close
  > } /goal deffst

  { < ==theorem ==substitution ==hypotheses > } /step deffst

  { # ==goal
    objset ==goals
    {
      _ .isopen { goals .put } { .resolution .hypotheses |collect each } ? *
    } /collect deffst
    collect goals dom
  } /openGoals deffst

  { ==proposition

    map ==disj
    { ==x ==y
      x y gt { x y =x =y } rep
      x disj .has not { map x disj =[] } rep
      1 y x disj * =[]
    } /markDisj deffst

    proposition .ctx _ =proofContext
    proposition .thm goal ==mainGoal
    proposition .allDisj { 2 dearray markDisj } each
    0 ==selectedGoal
    0 ==nextMetaVariable
    map ==metaSubstitution
    1 ==redisplay
    [ ] ==lastSearch

    { metaSubstitution applySubstitution } /expandMeta deffst

    { ==closedGoal ==substitution ==theorem
      [| "applying with:\n" |] out
      substitution dom { ==name
        [| name " = " name substitution * { renderName " " } each "\n" |] out
      } each

      theorem mandatoryVariables dom { ==var
        var constants .has not {
          var substitution .has not {
            [| "$" var "." nextMetaVariable _ 1 add =nextMetaVariable txt .produce .u |] ==newVar
            [ newVar ] var substitution =[]
          } rep
        } rep
      } each

      0 ==disjunctionsViolated
      theorem .disj { 2 dearray ==x ==y
        x substitution * { ==xTok
          xTok constants .has not {
            y substitution * { ==yTok
              yTok constants .has not { xTok yTok eq {
                1 =disjunctionsViolated
                [| "\e[31mproposed application would violate\e[0m " x renderName " <!> " y renderName "\n" |] out
                0 =redisplay
              } rep } rep
            } each
          } rep
        } each
      } each

      disjunctionsViolated not {
        theorem .disj { 2 dearray ==x ==y
          x substitution * { ==xTok
            xTok constants .has not {
              y substitution * { ==yTok
                yTok constants .has not { xTok yTok markDisj } rep
              } each
            } rep
          } each
        } each

        list ==hypotheses
        theorem .hyps { ==name
          [
            { name theorem .ctx isEHyp } {
              name theorem .ctx getEHyp substitution applySubstitution goal hypotheses .append1
            }
            { name theorem .ctx isFHyp } {
              name theorem .ctx getFHyp substitution applySubstitution goal hypotheses .append1
            }
            { 1 } {
              [| "hypothesis " name " cannot be resolved" "\n" |] out
            }
          ] conds
        } each

        # TODO: index open goals and reuse

        hypotheses substitution theorem step closedGoal .close
      } rep
    } /applyTheorem deffst

    { ==goal ==name
      [| "using: " name "\n" |] out
      [
        { name assertions .has } {
          name assertions * ==a
          [
            { a .type "p" eq a .type "a" eq or } {
              goal .thm expandMeta a possibleSubstitutions ==choices

              [
                { choices len 0 eq } {
                  [| "\e[31mno possible substitutions\e[0m\n" |] out
                  0 =redisplay
                  name show
                }
                { choices len 1 eq } {
                  a 0 choices * goal applyTheorem
                }
                { choices len 1 ge } {
                  [| "\e[31mmultiple substitutions possible\e[0m\n" |] out
                  0 =redisplay
                  name show
                  0 choices len range { ==i
                    [| i txt .produce .u ") " a .thm i choices * applySubstitution { renderName " " } each "\n" |] out
                    [| "(with " i choices * dom { ==v v "=" v i choices * * { " " } each " " } each ")\n" |] out
                  } each

                  a "choice" readNumber choices * goal applyTheorem
                }
              ] conds
            }
            { 1 } { [| name " is an assertion of unknown type (probably a bug)\n" |] out }
          ] conds
        }
        { name userContext isEHyp } {
          goal .thm expandMeta name userContext getEHyp eq all {
            list map < "f" ==type userContext ==ctx name userContext getEHyp ==thm { "no proof" die } =*proof name ==name >
              step goal .close
          } {
            [| "\e[31mnot applicable:\e[0m $f " name renderName "\n" |] out
            0 =redisplay
          } ? *
        }
        { name userContext isFHyp } {
          goal .thm expandMeta name userContext getFHyp eq all {
            list map < "f" ==type userContext ==ctx name userContext getFHyp ==thm { "no proof" die } =*proof name ==name >
              step goal .close
          } {
            [| "\e[31mnot applicable:\e[0m $f " name renderName "\n" |] out
            0 =redisplay
          } ? *
        }
        { 1 } {
          [| name " is not usable" "\n" |] out
          name show
        }
      ] conds
    } /use deffst

    { ==tokens ==name
      0 ==usable
      [
        { name assertions .has } {
          name assertions * ==a
          a .type "p" eq a .type "a" eq or {
            tokens a possibleSubstitutions ==choices
            choices len 1 ge =usable
          } rep
        }
        { name userContext isEHyp } {
          tokens name userContext getEHyp eq all =usable
        }
        { name userContext isFHyp } {
          tokens name userContext getFHyp eq all =usable
        }
      ] conds
      usable
    } /canUse deffst

    { ==metaVar ==tokens
      0 ==disjunctionsViolated
      tokens { ==x metaVar ==y
        x y gt { x y =x =y } rep
        x disj .has {
          y x disj * .has {
            1 =disjunctionsViolated
            [| "\e[31mproposed let would violate\e[0m " x renderName " <!> " y renderName "\n" |] out
            0 =redisplay
          } rep
        } rep
      } each
      disjunctionsViolated not {
        tokens metaVar metaSubstitution =[]

        disj dom { ==x
          x disj * dom { ==y
            x metaVar eq { tokens { ==t t constants .has not { t y markDisj } rep } each } rep
            y metaVar eq { tokens { ==t t constants .has not { t x markDisj } rep } each } rep
          } each
        } each
      } rep
    } /let deffst

    { map _ ==directTheoremIndex # returned
      [| "Indexing theorems by text...\n" |] out

      assertions dom { ==name
        name assertions * .ctx collectEHyps dom len not {
          name [| name assertions * .thm { " " } each |] directTheoremIndex =[]
        } rep
      } each
      [ |collectEHyps |collectFHyps ] { =*collect
        proofContext collect ==hyps hyps dom { ==name
          name [| name hyps * { " " } each |] directTheoremIndex =[]
        } each
      } each
    } memoized /directTheoremIndex deffst

    { map _ ==closedGoalIndex # returned
      { ==goal
        goal .isopen not {
          [| goal .thm expandMeta { " " } each |] ==txt
          goal txt closedGoalIndex =[]
          goal .resolution .hypotheses |recurse each
        } rep
      } /recurse deffst
      mainGoal recurse
    } /closedGoalIndex deffst

    { ==goal
      goal .thm expandMeta ==tokens
      [| tokens { " " } each |] ==txt
      [
        { txt directTheoremIndex .has } {
          txt directTheoremIndex * goal use
        }
        { txt closedGoalIndex .has } {
          [| "re-using earlier proof\n" |] out
          txt closedGoalIndex * .resolution goal .close
        }
        { 0 tokens * logicParsers .has } {
          { [| "\e[31mautomatic parser available, but did not parse. probably not satisfiable\e[0m\n" |] out } =*failed
          1 tokens 0 tokens * logicParsers * * { tokens len eq { ==parse
            # parse tree order is by token sequence, but hypothesis order is by set.mm
            # only apply topmost parse rule and handle rest via big recursion
            parse logicNonTerminal goal use
            goal .resolution .hypotheses |auto each
          } |failed ? * } |failed ? *
        }
        { 0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { tokens len eq } andif } { ==parse
          [
            { parse logicNonTerminal /wi eq { 0 parse * logicRange tokens * 1 parse * logicRange tokens * eq all } andif } {
              /id goal use
              goal .resolution .hypotheses |auto each
            }
            { parse logicNonTerminal /wi eq { 1 parse * logicNonTerminal /wceq eq } andif
              { 0 1 parse * * logicRange tokens * 1 1 parse * * logicRange tokens * eq all } andif } {
              /a1i goal use
              goal .resolution .hypotheses |auto each
            }
            { parse logicNonTerminal /wi eq { 1 parse * logicNonTerminal /wal eq } andif
              { 0 parse * logicRange tokens * 1 1 parse * * logicRange tokens * eq all } andif } {
              /ax-17 goal use
              goal .resolution .hypotheses |auto each
            }
            { parse logicNonTerminal /wceq eq { 0 parse * logicRange tokens * 1 parse * logicRange tokens * eq all } andif } {
              /eqid goal use
              goal .resolution .hypotheses |auto each
            }
          ] conds
        }
      ] conds
    } /auto deffst

    { ==goal
      { "\e[31mdistr:eq not applicable, expected |- ( x = y -> ( ... { <-> , = } ... ) )\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { tokens len eq } andif { ==parse
        parse logicNonTerminal /wi eq { 0 parse * logicNonTerminal /wceq eq } andif {
          < > ==thms "" ==leftNt "" ==rightNt
          [
            { 1 parse * logicNonTerminal /wb eq } {
              0 1 parse * * logicNonTerminal =leftNt
              1 1 parse * * logicNonTerminal =rightNt
              leftNt rightNt eq {
                0 0 parse * * logicRange tokens * ==from
                1 0 parse * * logicRange tokens * ==to
                <
                  /imbi12d ==wi
                  /bibi12d ==wb
                  /eleq12d ==wcel
                  /orbi12d ==wo
                  /anbi12d ==wa
                  /eqeq12d ==wceq
                  /albid ==wal
                  /exbid ==wex
                > =thms
              } |notApplicable ? *
            }
            { 1 parse * logicNonTerminal /wceq eq } {
              0 1 parse * * logicNonTerminal =leftNt
              1 1 parse * * logicNonTerminal =rightNt
              leftNt rightNt eq {
                0 0 parse * * logicRange tokens * ==from
                1 0 parse * * logicRange tokens * ==to
                <
                  /fveq12d ==cfv
                  /opeq12d ==cop
                > =thms
              } |notApplicable ? *
            }
          ] conds

          thms leftNt .?' {
            thms leftNt . goal use
            0 tree
            goal .resolution .hypotheses |auto each
            goal .resolution .hypotheses { ==g g .isopen { g tacDistrEq } rep } each
          } { [| "\e[31mno theorem known to process rewrite step, of type " leftNt "\e[0m\n" |] out } ? *
        } |notApplicable ? *
      } |notApplicable ? *
    } /tacDistrEq deffst

    # Models all known truths as an accepting FSM. Theorem variables become
    # self-loops, theorem tokens become transitions.
    { < map ==transitions objset ==theorems > } /tokenNode deffst

    { tokenNode _ ==theoremTokenIndex # returned
      [| "Indexing theorems by tokens...\n" |] out

      { ==name ==tokens
        objset ==i theoremTokenIndex i .put

        tokens { ==tok
          tok constants .has {
            objset ==newI
            i { ==n
              tok n .transitions .has not { tokenNode tok n .transitions =[] } rep
              tok n .transitions * newI .put
            } each
            newI =i
          } rep
        } each

        i { ==n
          name n .theorems .put
        } each
      } /index deffst

      assertions dom { ==name name assertions * .thm name index } each
      [ |collectEHyps |collectFHyps ] { =*collect
        proofContext collect ==hyps hyps dom { ==name
          name hyps * name index
        } each
      } each
    } memoized /theoremTokenIndex deffst

    { ==tokens
      objset ==i
      theoremTokenIndex i .put
      tokens { ==tok
        i { ==n
          tok n .transitions .has {
            tok n .transitions * i .put
          } rep
        } each
      } each

      [| "Possible theorems:\n" |] out
      i { .theorems 0 ==some { ==thm
        # thm tokens canUse { thm " " cat out 1 =some } rep
        thm " " cat out 1 =some
      } each some { "\n" out } rep } each
    } /search deffst

    { .thm expandMeta search } /suggest deffst

    { ==includeTypes
      0 ==i
      { ==indent ==goal
        includeTypes 0 goal .thm expandMeta * "|-" eq or {
          [|
            i txt .produce .u _ out ")" out len
            indent -01 sub { " " } rep
            goal .isopen { "\e[31m???\e[0m " } { goal .resolution .theorem .name " " } ? *
            goal .thm expandMeta { renderName " " } each "\n"
          |] out
        } rep
        i 1 add =i
        goal .isopen not { goal .resolution .hypotheses { indent 2 add recurse } each } rep
      } /recurse deffst
      mainGoal 4 recurse
    } /tree deffst

    {
      { ==goal
        goal .isopen not { goal .resolution .hypotheses |recurse each } rep
        [| goal .isopen { "? " } { goal .resolution .theorem .name " " } ? * |] out
      } /recurse deffst
      mainGoal recurse
      "$.\n" out
    } /export deffst

    { ==toReopen
      0 ==i
      { ==goal
        i _ 1 add =i toReopen eq { goal .open } rep
        goal .isopen not { goal .resolution .hypotheses |recurse each } rep
      } /recurse deffst
      mainGoal recurse
    } /reopen deffst

    1 ==running

    { running } {
      proofContext _ =userContext =renderContext
      mainGoal openGoals ==goals

      redisplay {
        " " ==sep
        [| disj dom sort { ==x
          x disj * dom sort { ==y
            sep ", " =sep x renderName " <!> " y renderName
          } each
        } each "\n" |] out

        goals dom { ==i
          i selectedGoal eq "\e[1m" "" ? ==hl
          [| hl i txt .produce .u ") " i goals * .thm expandMeta { hl -01 renderName " " } each "\e[0m\n" |] out
        } each
      } rep
      1 =redisplay

      "proof> " sys .out .writeall
      63356 sys .in .read ==input

      { "\e[32mWe are done here.\e[0m\n" out } =*solved
      [
        { input "" eq } { 0 =running }
        { input "done\n" eq } { 0 =running }
        { input "^show (.*)\n" regex } { show 0 =redisplay }
        { input "^(\\d+)\n" regex } {
          txt .consume .u _ goals len ge { -- goals len 1 sub } rep =selectedGoal
        }
        { input "^use (.*)\n" regex } { selectedGoal goals * use }
        { input "^let (\\$[^=]+) = (.*)\n" regex } { ==metaVar " " str .split { "" neq } grep ==tokens
          tokens metaVar let
        }
        { input "^unlet (\\$[^=]+)\n" regex } { ==v [ v ] v metaSubstitution =[] }
        { input "lets\n" eq } {
          metaSubstitution dom { ==v
            [| v " = " v metaSubstitution * { renderName " " } each "\n" |] out
          } each
          0 =redisplay
        }
        { input "auto\n" eq
          input "\n" eq or } { goals len { selectedGoal goals * auto } |solved ? * }
        { input "distr:eq\n" eq } { goals len { selectedGoal goals * tacDistrEq } |solved ? * }
        { input "tree\n" eq } { 0 tree }
        { input "fulltree\n" eq } { 1 tree }
        { input "export\n" eq } { export }
        { input "reopen (\\d+)\n" regex } { txt .consume .u reopen }
        { input "sug\n" eq } { selectedGoal goals * suggest }
        { input "search (.*)\n" regex } { " " str .split _ =lastSearch search }
        { input "search\n" regex } { lastSearch search }
        { input "parse\n" regex } {
          0 selectedGoal goals * .thm * ==head

          [
            { head "|-" eq }           { [ 1 selectedGoal goals * .thm /wff logicParsers * * ] dump }
            { head logicParsers .has } { [ 1 selectedGoal goals * .thm head logicParsers * * ] dump }
            { 1 } { [| "\e[31mno parser available\e[0m\n" |] out }
          ] conds
        }
      ] conds
    } loop
  } /proveProposition deffd

  { ==name
    name assertions .has { name assertions * .type "p" eq } { 0 } ? * {
      name assertions * proveProposition
    } {
      [| name " is not a provable proposition\n" |] out
      name show
    } ? *
  } /prove deffd

  { map _ ==variables # returned
    blocks { .f _ =*d dom 
      { _ ==n d _ 0 -01 * ==nonterminal 1 -01 * ==var
        nonterminal var variables =[]
      } each
    } each
  } memoized /variables deffd

  # generate parser functions
  # { ==toks ==start [...] used_theorem end success[0/1] }
  { [| "Generating logic parser...\n" |] out
    map _ ==nonterminals # returned
    map ==variableTypedefs

    blocks { .f _ =*d dom 
      { _ ==n d _ 0 -01 * ==nonterminal 1 -01 * ==var
        var variableTypedefs .has { var variableTypedefs * len n len gt } { 1 } ? *
          { n var variableTypedefs =[] } rep
      } each
    } each

    variables dom { _ ==var variables * ==nonterminal
      { -- -- 0 } =*alt
      nonterminal nonterminals .has { nonterminal nonterminals * =alt } rep

      var variableTypedefs * ==name
      { ==toks ==start
        start toks len lt { start toks * var eq } andif { [ start _ 1 add name ] start 1 add 1 } { start toks alt } ? *
      } nonterminal nonterminals =[]
    } each

    assertions dom { _ ==name assertions * ==a
      a .type "a" eq {
        0 a .thm * _ ==nt nonterminals .has {
          a .ctx collectEHyps dom len 0 eq {
            1 a .thm len range a .thm * ==expectedTokens
            nt nonterminals * =*alt

            { ==toks _ ==start ==i
              start toks alt { 1 } {
                1 ==success , [
                expectedTokens { ==tok success {
                  tok constants .has {
                    i toks len lt { i toks * tok eq } andif { i 1 add =i } { 0 =success } ? *
                  } {
                    i toks tok variables * nonterminals * * { =i } { 0 =success } ? *
                  } ? *
                } rep } each
                success { ,-- start i name ] i 1 } { ,--- 0 } ? *
              } ? *
            } nt nonterminals =[]
          } rep
        } rep
      } rep
    } each
  } memoized /logicParsers deffd

  { ==node node len 3 sub node * } /logicStart deffst
  { ==node node len 2 sub node * } /logicEnd deffst
  { ==node node len _ 3 sub node * -01 2 sub node * range } /logicRange deffst
  { ==node node len 1 sub node * } /logicNonTerminal deffst

  { ==name
    [
      { name assertions .has } {
        name assertions * ==a
        [ 1 a .thm /wff logicParsers * * ] dump
      }
      { 1 } { [| "\e[31m" name " is not a proposition\e[0m" |] dump }
    ] conds
  } /parseTokens deffd

  {
    1 ==running
    { running } {
      "> " sys .out .writeall
      63356 sys .in .read ==input

      [
        { input "" eq } { 0 =running }
        { input "quit\n" eq } { 0 =running }
        { input "^show (.*)\n" regex } { show }
        { input "^parse (.*)\n" regex } { parseTokens }
        { input "^prove (.*)\n" regex } { prove }
      ] conds
    } loop
  }
> -- /interactive deffd

interactive
#
# {
#   sys .argv len { 0 sys .argv * } { "/proc/self/fd/0" } ? * include
#   0 sys .exit
# }' "igor.loaded" sys .freeze

# vim: syn=elymas
