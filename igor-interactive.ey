<
  { [ } "[|" deffd sys .asmroutines .|assemblestr "|]" deffd

  emptyBlock ==renderContext
  emptyBlock ==userContext
  emptyBlock ==proofContext
  0 ==silent

  { <
    0 128 range ==data
    0 ==top

    { # ==elem
      top data len ge { data _ cat =data } rep
      top data =[]
      top 1 add =top
    } /push deffst

    {
      top 1 sub _ 0 lt { "export stack underflow" die } rep
                _ =top
                  data *
    } /pop deffst

    { top } /has deffst
  > } /stack deffst

  <
    map ==:renderNameCache
    "" ==name

    { =name
      name renderNameCache .has not {
        [
          { name constants .has } {
            [| "\e[37m" name "\e[0m" |]
          }
          { name assertions .has } {
            name assertions * ==a
            [
              { a .type "p" eq } { [| "\e[36m" name "\e[0m" |] }
              { a .type "a" eq } { [| "\e[31m" name "\e[0m" |] }
              { 1 } { name }
            ] conds
          }
          { name renderContext isVar } { [| "\e[32m" name "\e[0m" |] }
          { 0 name * 0 "$" * eq } { [| "\e[33m" name "\e[0m" |] }
          { 1 } { name }
        ] conds
      name renderNameCache =[] } rep
      name renderNameCache *
    }'
  > -- τrenderName /renderName deffd

  "" ==inputBuffer
  {
    { ==s
      s "" neq {
        0 ==i { i s len lt i s * 10 neq and } { i 1 add =i } loop
        i s len lt {
          i 1 add s str .postfix
          i 1 add s str .prefix
          1
        } { 0 } ? *
      } { 0 } ? *
    } /extractFirstLine deffst

    0 ==eof
    { eof not { inputBuffer extractFirstLine not } andif } {
      65536 sys .in .read _ ==input "" eq =eof
      inputBuffer input cat =inputBuffer
    } loop eof { "" } { -01 =inputBuffer } ? *
  } /inputLine deffd

  [ ] ==loadedInputWrappers

  {
    "" ==cmd "" ==args
    inputLine ==input
    input "" eq {
      "quit" =cmd
    } {
      1 neg input str .prefix =input
      input len 0 gt {
        0 { _ _ input len lt -01 input * 32 eq and } { 1 add } loop input str .postfix =input
        input len 0 gt {
          0 { _ _ input len lt -01 input * 32 neq and } { 1 add } loop _ input str .prefix =cmd input str .postfix =input
          input len 0 gt {
            0 { _ _ input len lt -01 input * 32 eq and } { 1 add } loop input str .postfix =args
          } rep
        } rep
      } rep
    } ? *
    args cmd loadedInputWrappers "*" | each
  } /inputCmd deffd

  0 ==messages
  sys .out .|writeall /out deffd
  { ==msg [| "\e[31m" msg "\e[0m\n" |] out messages 1 add =messages } /err deffd
  { ==msg [| "\e[1;33m" msg "\e[0m\n" |] out messages 1 add =messages } /warn deffd

  { -- } /showBlock deffd

  { ==a
    a .ctx _ =renderContext _ =userContext showBlock
    [| "assuming:\n" |] out
    a .hyps { ==hyp
      [
        { hyp userContext isEHyp } {
          [| "$e " hyp renderName "\n" |] out
          [| hyp userContext getEHyp { renderName " " } each "\n" |] out
        }
        { hyp userContext isFHyp } {
          [| "$f " hyp renderName "\n" |] out
          [| hyp userContext getFHyp { renderName " " } each "\n" |] out
        }
        { 1 } {
          [| "\e[31mcould not resolve hypothesis:\e[0m " hyp "\n" |] out
        }
      ] conds
    } each
    [| "gives:\n" |] out
    [| a .thm { renderName " " } each "\n" |] out
    " " ==sep
    [| "mandatory disjunct:" a .disj { =*d sep ", " =sep 0 d renderName " <!> " 1 d renderName } each "\n" |] out
    " " =sep
    [| "all disjunct:" a .allDisj { =*d sep ", " =sep 0 d renderName " <!> " 1 d renderName } each "\n" |] out
  } /showAssertion deffd

  { ==p
    p showAssertion
  } /showProposition deffd

  { ==name
    [
      { name constants .has } {
        [| "$c " name renderName "\n" |] out
      }
      { name assertions .has } {
        name assertions * ==a
        [
          { a .type "p" eq } { [| "$p " name renderName "\n" |] out a showProposition }
          { a .type "a" eq } { [| "$a " name renderName "\n" |] out a showAssertion }
          { 1 } { [| name " is an assertion of unknown type (probably a bug)\n" |] out }
        ] conds
      }
      { name userContext isEHyp } {
        [| "$e " name renderName "\n" |] out
        [| name userContext getEHyp { renderName " " } each "\n" |] out
      }
      { name userContext isFHyp } {
        [| "$f " name renderName "\n" |] out
        [| name userContext getFHyp { renderName " " } each "\n" |] out
      }
      { name userContext isVar } {
        [| "$v " name renderName "\n" |] out
      }
      { 1 } {
        [| name " is not known" "\n" |] out
      }
    ] conds
  } /show deffd

  { ==prompt
    0 ==numberRead
    { numberRead not } {
      prompt "> " cat sys .out .writeall
      inputLine ==input
      input "^ *(\\d+)\n" regex { 1 =numberRead txt .consume .u } rep
    } loop
  } /readNumber deffd

  { txt .produce .u ==s
    [
      s len 1 sub { ";" } rep
      s { [ -01 ] str .fromArray } each
    ]
  } /printNumber deffd

  0 ==debuggingPossibleSubstitutions
  { ==assertionTokens ==assertionParse ==tokens ==tokensParse map ==substitution
    1 ==valid
    0 ==i

    { ==assertionParse ==tokensParse
      assertionParse logicNonTerminal ==nt
      [
        { nt "" eq } { # terminal
          tokensParse logicRange tokens * ==new
          assertionParse logicStart assertionTokens * ==var

          var substitution .has {
            var substitution * ==old
            old new arrEq _ valid and =valid not {
              debuggingPossibleSubstitutions {
                [| "Failed to unify (later variable usage):\n" |] out
                [| old { " " } each "\n" |] out
                [| new { " " } each "\n" |] out
              } rep
            } rep
          } {
            new var substitution =[]
          } ? *
        }
        { nt tokensParse logicNonTerminal eq } {
          0 assertionParse logicChildCount range { ==i
            i tokensParse * i assertionParse * recurse
          } each
        }
        { 1 } {
          0 =valid
          debuggingPossibleSubstitutions {
            [| "Failed to unify (parse):\n" |] out
            [| tokensParse logicRange tokens * { " " } each "\n" |] out
            [| assertionParse logicRange assertionTokens * { " " } each "\n" |] out
          } rep
          { -- -- } =recurse
        }
      ] conds
    } /recurse deffst

    tokensParse assertionParse recurse

    [ valid { substitution } rep ]
  } τpossibleSubstitutionsParses /possibleSubstitutionsForParses deffd

  { ==start ==rootNonterminal ==assertionTokens ==tokens ==tokensParse
    start assertionTokens rootNonterminal logicParsers * * not {
      [ ]
      debuggingPossibleSubstitutions {
        [| "Failed to parse as: " rootNonterminal "\n" |] out
        [| start assertionTokens len range assertionTokens * { " " } each "\n" |] out
      } rep
    } { ==assertionParse
      tokensParse tokens assertionParse assertionTokens possibleSubstitutionsForParses
    } ? *
  } τpossibleSubstitutionsParse /possibleSubstitutionsForParse deffd

  { ==start ==rootNonterminal ==assertionTokens ==tokens
    start tokens rootNonterminal logicParsers * * not {
      [ ]
      debuggingPossibleSubstitutions {
        [| "Failed to parse as: " rootNonterminal "\n" |] out
        [| start tokens len range tokens * { " " } each "\n" |] out
      } rep
    } { # ==tokensParse
      tokens assertionTokens rootNonterminal start possibleSubstitutionsForParse
    } ? *
  } τpossibleSubstitutions /possibleSubstitutionsForToks deffd

  {
    1 =debuggingPossibleSubstitutions
    possibleSubstitutionsForToks --
    0 =debuggingPossibleSubstitutions
  } /debugPossibleSubstitutionsForToks deffd

  { .thm ==assertionTokens ==tokens
    0 assertionTokens * 0 tokens * eq {
      0 tokens * "|-" eq /wff 0 tokens * ? ==rootNonterminal
      tokens assertionTokens rootNonterminal 1 possibleSubstitutionsForToks
    } {
      [ ] # no substitutions
    } ? *
  } /possibleSubstitutions deffd

  { ==substitution ==tokens
    [ tokens { _ substitution .has { substitution * _ len dearray } rep } each ]
  } τapplySubstitution /applySubstitution deffst

  { ==proposition
    < "a" ==type emptyBlock ==ctx "?" ==thm { "Fake theorem is fake" die }" =*proof "?" ==name
      list _ _ ==hyps ==disj ==allDisj > ==:fakeTheorem
    < fakeTheorem ==theorem [ ] ==hypotheses > ==:fakeResolution

    { < ==theorem ==hypotheses > } /step deffst

    < < > ==s

      { =s [ -01 ] s .parents cat /parents s .set } /addParent defmst
      { =s < > /resolution s .set 1 /isopen s .set } /open defmst
      { ==s
        s .isopen {
          /resolution s .set
          0 /isopen s .set
          s .resolution .hypotheses { s -01 .addParent } each
          s amendClosedGoalIndex
        } {
          ==resolution # we could just ignore the re-close, but it points to a missing abort condition in some automation
          resolution keys dump
          resolution .theorem dump
          resolution .theorem keys dump
          resolution .theorem .name dump
          [| "\e[31mSome tactics tried to re-close a closed goal\e[0m\n" |] die
        } ? *
      } τclose /close defmst
      { ==s fakeResolution /resolution s .set 0 /isopen s .set
        s amendClosedGoalIndex
      } /fakeclose defmst
      { =s /autohint s .set } /hint defmst

      {
        ==thm [ ] ==parents < > ==resolution 1 ==isopen "" ==autohint
        { = }' =*set scope
      }
    > -- /goal deffst

    map ==disj map ==nonDisj
    { ==x ==y
      x y gt { x y =x =y } rep
      x disj .has not { map x disj =[] } rep
      1 y x disj * =[]
    } /markDisj deffst

    { ==x ==y
      x y gt { x y =x =y } rep
      x disj .has {
        y x disj * .has
      } { 0 } ? *
    } /mustDisj deffst

    { ==x ==y
      x y gt { x y =x =y } rep
      x nonDisj .has not { map x nonDisj =[] } rep
      1 y x nonDisj * =[]
    } /markNonDisj deffst

    { ==x ==y
      x y gt { x y =x =y } rep
      x nonDisj .has {
        y x nonDisj * .has
      } { 0 } ? *
    } /mustNotDisj deffst

    proposition .ctx _ =proofContext
    proposition .thm goal ==mainGoal
    0 ==selectedGoal
    0 ==nextMetaVariable
    map ==lastMetaVariables
    map ==allMetaVariables
    map ==metaSubstitution
    1 ==redisplay
    [ ] ==lastSearch
    [ ] ==loadedCommands
    [ ] ==loadedAutomations
    [ ] ==loadedTrivialities
    [ ] ==loadedDisplays

    { _ metaSubstitution .has {
      metaSubstitution * |expandMetaToken each
    }" rep }' /expandMetaToken deffst
    <
      "" ==s
      { [ -01 { _ =s 0 s * 36 eq { expandMetaToken }" rep }" each ] }'
    > -- τexpandMeta /expandMeta deffst

    { ==theorem ==substitution
      theorem mandatoryVariables dom { ==var
        var constants .has not {
          var substitution .has not {
            [| "$" var "." nextMetaVariable _ 1 add =nextMetaVariable txt .produce .u |] ==newVar
            newVar var lastMetaVariables =[]
            1 newVar allMetaVariables =[]
            [ newVar ] var substitution =[]
          } rep
        } rep
      } each
    } τintroduceMetaVars /introduceMetaVars deffst

    { ==closedGoal ==substitution ==theorem
      silent not {
        [| "applying with:\n" |] out
        substitution dom { ==name
          [| name " = " name substitution * { renderName " " } each "\n" |] out
        } τinfo1 each
      } rep

      substitution theorem introduceMetaVars

      0 ==disjunctionsViolated
      theorem .disj { 2 dearray ==x ==y
        x substitution * { ==xTok
          xTok constants .has not {
            y substitution * { ==yTok
              yTok constants .has not {
                xTok yTok eq {
                  1 =disjunctionsViolated
                  [| "\e[31mproposed application would violate\e[0m " x renderName " <!> " y renderName "\n" |] out
                  0 =redisplay
                } rep
                xTok yTok mustNotDisj {
                  1 =disjunctionsViolated
                  [| "\e[31mproposed application would violate\e[0m " x renderName " <=> " y renderName "\n" |] out
                  0 =redisplay
                } rep
              } rep
            } each
          } rep
        } each
      } each

      disjunctionsViolated not {
        theorem .disj { 2 dearray ==x ==y
          x substitution * { ==xTok
            xTok constants .has not {
              y substitution * { ==yTok
                yTok constants .has not { xTok yTok markDisj } rep
              } each
            } rep
          } each
        } each

        [
          theorem .hyps { ==name
            [
              { name theorem .ctx isEHyp } { name theorem .ctx getEHyp substitution applySubstitution goal }
              { name theorem .ctx isFHyp } { name theorem .ctx getFHyp substitution applySubstitution goal }
              { 1 } {
                [| "hypothesis " name " cannot be resolved" "\n" |] out
              }
            ] conds
          } each
        ] ==hypotheses

        hypotheses theorem step closedGoal .close
      } rep
    } τapplyTheorem /applyTheorem deffst

    { ==assertion ==substitution
      silent not {
        [| "using e-hyp for: " assertion .name "\n" |] out
        substitution dom { ==v
          [| v " = " v substitution * { renderName " " } each "\n" |] out
        } each
      } rep
      assertion .hyps { assertion .ctx isEHyp } grep { ==name
        name assertion .ctx getEHyp ==toks
        0 toks * "|-" eq { 1 toks /wff logicParsers * * } andif { ==parse
          parse logicNonTerminal /wi eq
              { 0 parse * logicNonTerminal /wceq eq } andif
              { 1 parse * logicNonTerminal /wb eq } andif {
            0 0 parse * * logicRange toks * ==leftVar
            1 0 parse * * logicRange toks * ==rightVar
            0 1 parse * * logicRange toks * ==leftTerm
            1 1 parse * * logicRange toks * ==rightTerm
            leftVar len 1 eq
                { rightVar len 1 eq } andif
                { 0 leftVar * substitution .has } andif
                { 0 rightVar * substitution .has } andif {
              leftTerm len 1 eq
                  { 0 leftTerm * substitution .has } andif
                  { 0 rightTerm * substitution .has not } andif {
                0 leftTerm * substitution * 0 leftVar * substitution * 0 rightVar * substitution * rewriteTokens
                  0 rightTerm * substitution =[]
              } rep
              rightTerm len 1 eq
                  { 0 rightTerm * substitution .has } andif
                  { 0 leftTerm * substitution .has not } andif {
                0 rightTerm * substitution * 0 rightVar * substitution * 0 leftVar * substitution * rewriteTokens
                  0 leftTerm * substitution =[]
              } rep
            } rep
          } rep
        } rep
      } each
    } τresolveEhypSubstitutions /resolveEhypSubstitutions deffst

    { ==allowIndirectUsage ==goal ==name
      silent not {
        [| "using: " name "\n" |] out
      } rep
      [
        { name assertions .has } {
          name assertions * ==a
          [
            { a .type "p" eq a .type "a" eq or } {
              goal .thm expandMeta ==goalToks
              goalToks a possibleSubstitutions ==choices

              0 ==indirectUsage
              allowIndirectUsage
              { choices len 0 eq } andif
              { 0 goalToks * "|-" eq } andif
              { 1 goalToks /wff logicParsers * * } andif { ==goalParse
                0 a .thm * "|-" eq
                { 1 a .thm /wff logicParsers * * } andif { ==assertionParse
                  goalParse logicNonTerminal /wi eq {
                    [ "|-" ] 1 goalParse * logicRange goalToks * cat a possibleSubstitutions ==implChoices
                    implChoices len 1 eq {
                      /a1i goal use
                      goal .isopen not {
                        1 =indirectUsage

                        2 goal .resolution .hypotheses * ==g
                        g .isopen { name g use } rep
                      } rep
                    } rep
                  } rep

                  indirectUsage not {
                    0 ==hasAntes
                    goalParse logicNonTerminal /wi eq {
                      1 goalParse * 1 =hasAntes
                    } {
                      goalParse
                    } ? * ==relevantGoalParse

                    assertionParse ==i [ ] ==path
                    { ==path ==goal ==substitution
                      path reverse { ==step
                        hasAntes {
                          /syl goal use
                          goal .isopen not {
                            step logicRange a .thm * substitution applySubstitution /ps lastMetaVariables * let
                            4 goal .resolution .hypotheses * =goal
                          } rep
                        } {
                          /ax-mp goal use
                          goal .isopen not {
                            step logicRange a .thm * substitution applySubstitution /ph lastMetaVariables * let
                            name 3 goal .resolution .hypotheses * =goal
                          } rep
                        } ? *
                      } each
                      goal
                    } /resolvePath deffst

                    { ==goal ==name
                      goal .isopen {
                        name goal -1010 .thm expandMeta canUse { use } { .hint } ? *
                      } rep
                    } /useOrHint deffst

                    {
                      [
                        { goal .isopen not } { 0 } # success already
                        { i logicNonTerminal /wb eq } {
                          relevantGoalParse goalToks 1 i * logicRange a .thm * /wff 0 possibleSubstitutionsForParse ==rightChoices
                          relevantGoalParse goalToks 0 i * logicRange a .thm * /wff 0 possibleSubstitutionsForParse ==leftChoices

                          # prefer substitutions with more variables known (i.e. better match)
                          rightChoices len 1 eq { leftChoices len 1 eq { 0 leftChoices * dom len 0 rightChoices * dom len gt } andif not } andif {
                            0 rightChoices * ==substitution
                            substitution a resolveEhypSubstitutions
                            substitution a introduceMetaVars
                            1 =indirectUsage
                            hasAntes {
                              path len {
                                /mpbid goal use
                                goal .isopen not {
                                  0 i * logicRange a .thm * substitution applySubstitution /ps lastMetaVariables * let
                                  substitution 4 goal .resolution .hypotheses * path resolvePath ==subgoal
                                  name subgoal useOrHint
                                } rep
                              } {
                                /sylib goal use
                                goal .isopen not {
                                  0 i * logicRange a .thm * substitution applySubstitution /ps lastMetaVariables * let
                                  name 4 goal .resolution .hypotheses * useOrHint
                                } rep
                              } ? *
                            } {
                              /mpbi goal use
                              goal .isopen not {
                                0 i * logicRange a .thm * substitution applySubstitution /ph lastMetaVariables * let
                                name 3 goal .resolution .hypotheses * useOrHint
                              } rep
                            } ? *
                          } {
                            leftChoices len 1 eq {
                              0 leftChoices * ==substitution
                              substitution a resolveEhypSubstitutions
                              substitution a introduceMetaVars
                              1 =indirectUsage
                              hasAntes {
                                path len {
                                  /mpbird goal use
                                  goal .isopen not {
                                    1 i * logicRange a .thm * substitution applySubstitution /ch lastMetaVariables * let
                                    substitution 4 goal .resolution .hypotheses * path resolvePath ==subgoal
                                    name subgoal useOrHint
                                  } rep
                                } {
                                  /sylibr goal use
                                  goal .isopen not {
                                    1 i * logicRange a .thm * substitution applySubstitution /ps lastMetaVariables * let
                                    name 4 goal .resolution .hypotheses * useOrHint
                                  } rep
                                } ? *
                              } {
                                /mpbir goal use
                                goal .isopen not {
                                  1 i * logicRange a .thm * substitution applySubstitution /ps lastMetaVariables * let
                                  name 3 goal .resolution .hypotheses * useOrHint
                                } rep
                              } ? *
                            } rep
                          } ? *
                          0
                        }
                        { i logicNonTerminal /wi eq } {
                          relevantGoalParse goalToks 1 i * logicRange a .thm * /wff 0 possibleSubstitutionsForParse ==rightChoices
                          rightChoices len 1 eq {
                            0 rightChoices * ==substitution
                            substitution a resolveEhypSubstitutions
                            substitution a introduceMetaVars
                            1 =indirectUsage
                            hasAntes {
                              path len {
                                /mpd goal use
                                goal .isopen not {
                                  0 i * logicRange a .thm * substitution applySubstitution /ps lastMetaVariables * let
                                  name 4 goal .resolution .hypotheses * useOrHint
                                } rep
                              } {
                                /syl goal use
                                goal .isopen not {
                                  0 i * logicRange a .thm * substitution applySubstitution /ps lastMetaVariables * let
                                  name 4 goal .resolution .hypotheses * useOrHint
                                } rep
                              } ? *
                            } {
                              /ax-mp goal use
                              goal .isopen not {
                                0 i * logicRange a .thm * substitution applySubstitution /ph lastMetaVariables * let
                                name 3 goal .resolution .hypotheses * useOrHint
                              } rep
                            } ? *
                            0
                          } {
                            path [ 0 i * ] cat =path
                            1 i * =i
                            1
                          } ? *
                        }
                        { 1 } { 0 }
                      ] conds
                    } { } loop
                  } rep
                } rep
              } rep

              indirectUsage not {
                [
                  { choices len 1 eq } {
                    a 0 choices * goal applyTheorem
                  }
                  { choices len 0 eq } {
                    [| "\e[31mno possible substitutions\e[0m\n" |] out
                    0 =redisplay
                    name show
                  }
                  { choices len 1 ge } {
                    [| "\e[31mmultiple substitutions possible\e[0m\n" |] out
                    0 =redisplay
                    name show
                    0 choices len range { ==i
                      [| i txt .produce .u ") " a .thm i choices * applySubstitution { renderName " " } each "\n" |] out
                      [| "(with " i choices * dom { ==v v "=" v i choices * * { " " } each " " } each ")\n" |] out
                    } each

                    a "choice" readNumber choices * goal applyTheorem
                  }
                ] conds
              } rep
            }
            { 1 } { [| name " is an assertion of unknown type (probably a bug)\n" |] out }
          ] conds
        }
        { name userContext isEHyp } {
          goal .thm expandMeta name userContext getEHyp arrEq {
            [ ] < "f" ==type userContext ==ctx name userContext getEHyp ==thm { "no proof" die } =*proof name ==name >
              step goal .close
          } {
            [| "\e[31mnot applicable:\e[0m $f " name renderName "\n" |] out
            0 =redisplay
          } ? *
        }
        { name userContext isFHyp } {
          goal .thm expandMeta name userContext getFHyp arrEq {
            [ ] < "f" ==type userContext ==ctx name userContext getFHyp ==thm { "no proof" die } =*proof name ==name >
              step goal .close
          } {
            [| "\e[31mnot applicable:\e[0m $f " name renderName "\n" |] out
            0 =redisplay
          } ? *
        }
        { 1 } {
          [| name " is not usable" "\n" |] out
          name show
        }
      ] conds
    } τuseGeneric /useGeneric deffst

    { 0 useGeneric } /use deffst
    { 1 useGeneric } /tacUse deffst

    { ==tokens ==name
      0 ==usable
      [
        { name assertions .has } {
          name assertions * ==a
          a .type "p" eq a .type "a" eq or {
            tokens a possibleSubstitutions ==choices
            choices len 1 ge =usable
          } rep
        }
        { name userContext isEHyp } {
          tokens name userContext getEHyp arrEq =usable
        }
        { name userContext isFHyp } {
          tokens name userContext getFHyp arrEq =usable
        }
      ] conds
      usable
    } τcanUse /canUse deffst

    { ==metaVar ==tokens
      0 ==disjunctionsViolated
      metaVar "^\\$([^.]+)$" regex { ==stem
        stem lastMetaVariables .has { stem lastMetaVariables * =metaVar } rep
        metaVar metaSubstitution .has {
          allMetaVariables dom { ==v
            v metaSubstitution .has not {
              v "^\\$([^.]+)\\.[0-9]+$" regex { stem eq {
                v =metaVar
              } rep } rep
            } rep
          } each
        } rep
      } rep

      tokens { ==x metaVar ==y
        x y gt { x y =x =y } rep
        x disj .has {
          y x disj * .has {
            1 =disjunctionsViolated
            [| "\e[31mproposed let would violate\e[0m " x renderName " <!> " y renderName "\n" |] out
            0 =redisplay
          } rep
        } rep
        x nonDisj .has {
          y x nonDisj * .has {
            1 =disjunctionsViolated
            [| "\e[31mproposed let would violate\e[0m " x renderName " <=> " y renderName "\n" |] out
            0 =redisplay
          } rep
        } rep
      } each
      disjunctionsViolated not {
        tokens metaVar metaSubstitution =[]

        disj dom { ==x
          x disj * dom { ==y
            x metaVar eq { tokens { ==t t constants .has not { t y markDisj } rep } each } rep
            y metaVar eq { tokens { ==t t constants .has not { t x markDisj } rep } each } rep
          } each
        } each
      } rep
    } τlet /let deffst

    [ ] ==allOpenGoals 0 ==allOpenGoalsValid
    { # ==goal
      objset ==goals
      {
        _ .isopen { goals .put } { .resolution .hypotheses |collect each } ? *
      } /collect deffst
      collect goals dom
    } /openGoalsRecursive deffst

    { ==goal
      goal sys .asm .rawAddress mainGoal sys .asm .rawAddress eq {
        allOpenGoalsValid not {
          mainGoal openGoalsRecursive _ =allOpenGoals 1 =allOpenGoalsValid
        } {
          [ allOpenGoals { openGoalsRecursive _ len dearray } each ] _ =allOpenGoals 1 =allOpenGoalsValid
        } ? *
      } {
        goal openGoalsRecursive
      } ? *
    } τopenGoals /openGoals deffst

    { map _ ==directTheoremIndex # returned
      [| "Indexing theorems by text...\n" |] out

      assertions dom { ==name
        name assertions * .ctx collectEHyps dom len not { name proposition .name neq } andif {
          name [| name assertions * .thm { " " } each |] directTheoremIndex =[]
        } rep
      } each
      [ |collectEHyps |collectFHyps ] { =*collect
        proofContext collect ==hyps hyps dom { ==name
          name [| name hyps * { " " } each |] directTheoremIndex =[]
        } each
      } each
    } memoized /directTheoremIndex deffst

    map ==closedGoalIndex
    { ==newlyClosedGoal
      { ==goal
        [| goal .thm expandMeta { " " } each |] ==txt

        txt closedGoalIndex .has not {
          goal txt closedGoalIndex =[]
          0 goal .thm * "|-" eq {
            goal recordSolution
          } rep
        } rep
      } /addClosedGoal deffst

      { ==goal
        goal .resolution .hypotheses _ =*hyps len 1 sub ==i
        1 { _ i 0 ge and } {
          i hyps ==hyp
          hyp .isopen { -- 0 } {
            [| hyp .thm expandMeta { " " } each |] ==txt
            -- txt closedGoalIndex .has
          } ? *
          i 1 sub =i
        } loop {
          goal addClosedGoal
          goal .parents |recurse each
        } rep
      } /recurse deffst

      newlyClosedGoal recurse
    } τclosedGoalIndex /amendClosedGoalIndex deffst

    { map =closedGoalIndex
      { ==goal
        goal .isopen { 1 } {
          [| goal .thm expandMeta { " " } each |] ==txt
          txt closedGoalIndex .has { 0 } {
            [ goal .resolution .hypotheses |recurse each ] any { 1 } {
              goal txt closedGoalIndex =[]
              0
            } ? *
          } ? *
        } ? *
      } /recurse deffst
      mainGoal recurse --
    } τclosedGoalIndex /rebuildClosedGoalIndex deffst

    { ==toTry ==goal
      goal .isopen not {
        toTry { =*f
          goal .resolution .hypotheses { ==g g .isopen { g f } rep } each
        } each
      } rep
    } τtacAttemptNext /tacAttemptNext deffst

    { ==goal ==toTry
      goal openGoals { ==g
        toTry { =*f
          g .isopen {
            g f
            g .isopen not {
              toTry g tacAttemptRecursive
            } rep
          } rep
        } each
      } each
    } τtacAttemptRecursive /tacAttemptRecursive deffst

    { ==tokens ==parse
      parse logicRange tokens * ==thing
      [
        [ "NN0" "NN" "RR" "CC" ] { ==numbers
          { thing len 1 eq { [| [ "|-" 0 thing * "e." numbers ] { " " } each |] directTheoremIndex .has } andif } { numbers }
        } each
        { parse logicNonTerminal /cdc eq { 0 parse * tokens classify "NN0" eq } andif { 1 parse * tokens classify "NN0" eq } andif } { "NN0" }
        { 1 } { "" }
      ] conds
    } τclassify /classify deffst

    { ==goal
      goal .isopen {
        goal .thm expandMeta ==tokens
        [| tokens { " " }" each |] ==txt
        [
          { txt closedGoalIndex .has } {
            silent not { [| "re-using earlier proof\n" |] out } rep

            txt closedGoalIndex * .resolution goal .close
          } τauto1
          { txt directTheoremIndex .has } {
            txt directTheoremIndex * goal use
            goal [ |auto ] tacAttemptNext
          } τauto2
          { 0 tokens * logicParsers .has { tokens tokenIsMetaVar any not } andif } {
            { [| "\e[31mautomatic parser available, but did not parse. probably not satisfiable\e[0m\n" |] out } =*failed
            1 tokens 0 tokens * logicParsers * * { ==parse
              faketrivialities { goal .fakeclose } {
                # parse tree order is by token sequence, but hypothesis order is by set.mm
                # only apply topmost parse rule and handle rest via big recursion
                parse logicNonTerminal goal use
                goal [ |auto ] tacAttemptNext
              } ? *
            } |failed ? *
          } τauto3
          { goal .autohint "" neq { goal .autohint tokens canUse } andif } {
            goal .autohint goal use
            goal [ |auto ] tacAttemptNext
          } τauto6
          { 0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif } τauto4 { ==parse
            { ==parse =*preparation
              goal .isopen { parse logicNonTerminal /wi eq } andif { 0 parse * logicRange tokens * 1 parse * logicRange tokens * arrEq } andif {
                goal preparation ==goal
                goal .isopen {
                  /id goal use
                  goal [ |auto ] tacAttemptNext
                } rep
              } rep

              goal .isopen { parse logicNonTerminal /wb eq } andif { 0 parse * logicRange tokens * 1 parse * logicRange tokens * arrEq } andif {
                goal preparation ==goal
                goal .isopen {
                  /biid goal use
                  goal [ |auto ] tacAttemptNext
                } rep
              } rep

              goal .isopen { parse logicNonTerminal /wi eq } andif { 1 parse * logicNonTerminal /wal eq } andif
                { 0 parse * logicRange tokens * 1 1 parse * * logicRange tokens * arrEq } andif {
                goal preparation ==goal

                goal .isopen {
                  /ax-17 assertions * ==theorem
                  tokens theorem possibleSubstitutions ==substitutions

                  substitutions len 1 eq { 0 substitutions * ==substitution
                    0 ==disjunctionsViolated
                    theorem .disj { 2 dearray ==x ==y
                      x substitution * { ==xTok
                        xTok constants .has not {
                          y substitution * { ==yTok
                            yTok constants .has not {
                              xTok yTok eq {
                                1 =disjunctionsViolated
                              } rep
                              xTok yTok mustNotDisj {
                                1 =disjunctionsViolated
                              } rep
                            } rep
                          } each
                        } rep
                      } each
                    } each

                    disjunctionsViolated not {
                      /ax-17 goal use
                    } rep
                    # TODO do something with hb* theorems here

                    goal [ |auto ] tacAttemptNext
                  } rep
                } rep
              } rep

              goal .isopen { parse logicNonTerminal /wceq eq } andif { 0 parse * logicRange tokens * 1 parse * logicRange tokens * arrEq } andif {
                goal preparation ==goal
                goal .isopen {
                  /eqid goal use
                  goal [ |auto ] tacAttemptNext
                } rep
              } rep

              goal .isopen { parse logicNonTerminal /wi eq } andif
                { 0 parse * logicNonTerminal /wceq eq } andif
                { 1 parse * logicNonTerminal /wceq eq } andif
                { 0 0 parse * * logicRange tokens * 1 1 parse * * logicRange tokens * arrEq } andif
                { 1 0 parse * * logicRange tokens * 0 1 parse * * logicRange tokens * arrEq } andif {
                goal preparation ==goal
                goal .isopen {
                  /eqcomd goal use
                  goal [ |auto ] tacAttemptNext
                } rep
              } rep

              goal .isopen { parse logicNonTerminal /wbr eq } andif
                           { 0 1 parse * logicRange tokens * * "<_" eq } andif
                           { 0 parse * tokens classify [ "NN" "NN0" "RR" ] eq any } andif {
                0 parse * logicRange tokens * 2 parse * logicRange tokens * arrEq {
                  goal preparation ==goal
                  goal .isopen {
                    /leidi goal use
                    goal [ |auto ] tacAttemptNext
                  } rep
                } rep

                goal .isopen {
                  0 parse * parseNumber { ==left
                    2 parse * parseNumber { ==right
                      left right lt {
                        goal preparation ==goal
                        goal .isopen {
                          /ltleii goal use
                          goal [ |auto ] tacAttemptNext
                        } rep
                      } rep
                    } rep
                  } rep
                } rep
              } rep

              goal .isopen { parse logicNonTerminal /wne eq } andif {
                0 parse * parseNumber { ==left
                  1 parse * parseNumber { ==right
                    left right lt {
                      goal preparation ==goal
                      goal .isopen {
                        /ltneii goal use
                        goal [ |auto ] tacAttemptNext
                      } rep
                    } rep

                    left right gt {
                      goal preparation ==goal
                      goal .isopen {
                        /gtneii goal use
                        goal [ |auto ] tacAttemptNext
                      } rep
                    } rep
                  } rep
                } rep
              } rep

              goal .isopen { parse logicNonTerminal /wbr eq } andif
                           { 0 1 parse * logicRange tokens * * "<" eq } andif {
                0 parse * parseNumber { ==left
                  2 parse * parseNumber { ==right
                    left right lt {
                      faketrivialities {
                        goal .fakeclose
                      } {
                        0 parse * logicNonTerminal /cdc neq {
                          goal preparation ==goal

                          goal .isopen {
                            /mpbir goal use
                            goal .isopen not {
                              [ ";" "0" 0 parse * logicRange tokens * _ len dearray "<"
                                2 parse * logicRange tokens * _ len dearray ] /ps lastMetaVariables * let
                              goal [ |auto ] tacAttemptNext
                              3 goal .resolution .hypotheses * =goal

                              goal .isopen {
                                /breq1i goal use
                                goal [ |auto ] tacAttemptNext
                                4 goal .resolution .hypotheses * =goal
                                goal .isopen {
                                  /dec0h goal use
                                  goal [ |auto ] tacAttemptNext
                                } rep
                              } rep
                            } rep
                          } rep
                        } {
                          goal preparation ==goal

                          goal .isopen {
                            left 10 div right 10 div lt {
                              /decltc goal use
                            } {
                              /declt goal use
                            } ? *
                            goal [ |auto ] tacAttemptNext
                          } rep
                        } ? *
                      } ? *
                    } rep
                  } rep
                } rep
              } rep

              goal .isopen { parse logicNonTerminal /wcel eq } andif {
                1 parse * logicRange tokens * ==set

                set len 1 eq { 0 set * ==setName
                  goal .isopen { 0 parse * logicNonTerminal "cv" eq } andif { setName "_V" eq } andif {
                    goal preparation ==goal
                    goal .isopen {
                      /vex goal use
                      goal [ |auto ] tacAttemptNext
                    } rep
                  } rep

                  goal .isopen { 0 parse * logicNonTerminal "cfv" eq } andif { setName "_V" eq } andif {
                    goal preparation ==goal
                    goal .isopen {
                      /fvex goal use
                      goal [ |auto ] tacAttemptNext
                    } rep
                  } rep

                  goal .isopen { 0 parse * logicNonTerminal "co" eq } andif { setName "_V" eq } andif {
                    goal preparation ==goal
                    goal .isopen {
                      /ovex goal use
                      goal [ |auto ] tacAttemptNext
                    } rep
                  } rep

                  goal .isopen { setName "NN0" eq } andif { 0 parse * logicNonTerminal /cdc eq } andif {
                    goal preparation ==goal
                    goal .isopen {
                      faketrivialities {
                        0 parse * tokens classify /NN0 eq {
                          goal .fakeclose
                        } rep
                      } {
                        /deccl goal use
                        goal [ |auto ] tacAttemptNext
                      } ? *
                    } rep
                  } rep

                  goal .isopen { setName "NN" eq } andif { 0 parse * logicNonTerminal /cdc eq } andif {
                    goal preparation ==goal
                    goal .isopen {
                      1 0 parse * * logicNonTerminal /cc0 eq /decnnclb /decnncl ? goal use
                      goal [ |auto ] tacAttemptNext
                    } rep
                  } rep

                  0 parse * tokens classify ==type

                  type "" neq {
                    goal .isopen { setName "_V" eq } andif {
                      goal preparation ==goal
                      goal .isopen {
                        /elexi goal use
                        goal .isopen not {
                          [ type ] /B lastMetaVariables * let
                          goal [ |auto ] tacAttemptNext
                        } rep
                      } rep
                    } rep

                    goal .isopen { setName "CC" eq } andif { type "NN0" eq } andif {
                      goal preparation ==goal
                      goal .isopen {
                        /nn0cni goal use
                        goal [ |auto ] tacAttemptNext
                      } rep
                    } rep

                    goal .isopen { setName "RR" eq } andif { type "NN0" eq } andif {
                      goal preparation ==goal
                      goal .isopen {
                        /nn0rei goal use
                        goal [ |auto ] tacAttemptNext
                      } rep
                    } rep

                    goal .isopen { setName "RR+" eq } andif { type "NN0" eq } andif {
                      goal preparation ==goal
                      goal .isopen {
                        /elrpii goal use
                        goal [ |auto ] tacAttemptNext
                      } rep
                    } rep
                  } rep
                } rep
              } rep

              goal .isopen { parse logicNonTerminal "wceq" eq } andif
                  { 0 parse * logicNonTerminal /co eq } andif {
                0 0 parse * * ==left
                1 0 parse * * ==operation
                2 0 parse * * ==right
                1 parse * ==result

                left parseNumber { ==leftNum
                  right parseNumber { ==rightNum
                    result parseNumber { ==resultNum
                      operation logicNonTerminal [ /caddc /cmin /cmul /cexp /cmo ] eq any {
                        goal preparation ==goal
                        goal .isopen {
                          goal tacSolveArith
                        } rep
                      } rep
                    } rep

                    result logicNonTerminal /cneg eq
                        { 0 result * parseNumber } andif { ==resultNum
                      goal preparation ==goal
                      goal .isopen {
                        goal tacSolveArith
                      } rep
                    } rep
                  } rep
                } rep
              } rep

              loadedTrivialities "*" | each
            } /trivialities deffst

            goal .isopen { parse logicNonTerminal /wi eq } andif {
              1 parse * logicRange tokens * ==target
              [| "|- " target { " " } each |] ==targetTxt

              targetTxt directTheoremIndex .has {
                /a1i goal use
                goal [ |auto ] tacAttemptNext
              } rep

              goal antecedents ==antes

              goal .isopen {
                antes { ==ante
                  ante target arrEq {
                    goal tacSelect
                  } rep
                } each
              } rep

              goal .isopen {
                proofContext collectEHyps _ ==hyps dom { ==name
                  name hyps * len 1 sub target len eq { 1 name hyps * len range name hyps * * target arrEq } andif {
                    /a1i goal use
                    goal .isopen not {
                      name 2 goal .resolution .hypotheses * use
                    } rep
                  } rep
                } each
              } rep

              goal .isopen { parse logicNonTerminal /wi eq } andif {
                { ==goal
                  /a1i goal use
                  goal [ |auto ] tacAttemptNext
                  2 goal .resolution .hypotheses *
                } 1 parse * trivialities
              } rep

              goal .isopen {
                [| 1 parse * logicRange tokens * { " " } each |] ==conclusion
                conclusion recordedSolutions .has {
                  map ==anteSet
                  goal antecedents { [| -01 { " " } each |] _ anteSet =[] } each

                  999999999 ==shortestSolutionLength < > ==shortestSolution
                  conclusion recordedSolutions * { ==solution
                    [| solution .thm expandMeta { " " } each |] ==solutionTxt
                    solutionTxt closedGoalIndex .has {
                      [
                        solution antecedents {
                          [| -01 { " " } each |] anteSet .has
                        } each
                      ] all {
                        [| solution .thm expandMeta _ len dearray |] len ==curLen
                        curLen shortestSolutionLength lt {
                          solution =shortestSolution curLen =shortestSolutionLength
                        } rep
                      } rep
                    } rep
                  } each

                  shortestSolutionLength 999999999 lt {
                    shortestSolution .thm expandMeta ==solutionToks

                    0 solutionToks * "|-" eq
                      { 1 solutionToks /wff metaLogicParsers * * } andif { ==solutionParse
                      solutionParse logicNonTerminal /wi eq {
                        0 solutionParse * logicRange solutionToks * goal tacWithOnly
                      } {
                        /a1i goal use
                        goal [ |auto ] tacAttemptNext
                      } ? *
                    } rep
                  } rep
                } rep
              }! rep # execute only non-recursively

              goal .isopen { 1 parse * logicNonTerminal /wcel eq } andif
                  { 1 1 parse * * logicNonTerminal [ /cz /cr /cc ] eq any } andif {
                goal antecedents ==antes
                [ 0 1 parse * * logicRange tokens * _ len dearray "e." "NN0" ] ==nn0classification
                [ antes { nn0classification arrEq } each ] any {
                  1 1 parse * * logicNonTerminal ==class
                  [
                    { class /cz eq } { /nn0z goal tacUse }
                    { class /cr eq } { /nn0re goal tacUse }
                    { class /cc eq } { /nn0cn goal tacUse }
                  ] conds
                  goal .isopen not { goal openGoals |auto each } rep
                } rep
              } rep
            } rep

            goal .isopen { parse logicNonTerminal /wi eq } andif
                { 1 parse * logicNonTerminal /wceq eq } andif
                { 0 1 parse * * logicNonTerminal /co eq } andif
                { 1 0 1 parse * * * logicNonTerminal /caddc eq } andif
                { 2 0 1 parse * * * parseNumber } andif { 0 eq } andif
                { 0 0 1 parse * * * logicRange tokens * 1 1 parse * * logicRange tokens * arrEq } andif {
              /addid1 goal tacUse
              goal [ |auto ] tacAttemptNext
            } rep

            { } parse trivialities
          } τauto5
          loadedAutomations "*" | each
        ] conds
      } rep
    } τauto /auto deffst

    { ==token 0 token * 0 "$" * eq } '0.0 /tokenIsMetaVar deffst

    { ==tokens
      tokens len 1 eq { 0 tokens * tokenIsMetaVar } andif
    } /tokensAreMetaVar deffst

    { ==goal
      { "\e[31mdistr:ante not applicable, expected |- ( ... -> ( ... { <-> , = } ... ) )\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
        parse logicNonTerminal /wi eq {

          < > ==thms "" ==leftNt "" ==rightNt
          [
            { 1 parse * logicNonTerminal /wb eq } {
              0 1 parse * * logicNonTerminal =leftNt
              1 1 parse * * logicNonTerminal =rightNt
              leftNt rightNt eq {
                <
                  [ /imbi1d /imbi2d /imbi12d ] ==wi
                  [ /bibi1d /bibi2d /bibi12d ] ==wb
                  [ /eleq1d /eleq2d /eleq12d ] ==wcel
                  [ /orbi1d /orbi2d /orbi12d ] ==wo
                  [ /anbi1d /anbi2d4 /anbi2d /anbi12d ] ==wa
                  [ /3anbi1d /3anbi2d /3anbi3d /3anbi12d /3anbi13d /3anbi23d /3anbi123d ] ==w3a
                  [ /3orbi1d /3orbi2d /3orbi3d /3orbi123d ] ==w3o
                  [ /notbid ] ==wn
                  [ /eqeq1d /eqeq2d /eqeq12d ] ==wceq
                  [ /neeq1d /neeq2d /neeq12d ] ==wne
                  [ /sseq1d /sseq2d /sseq12d ] ==wss
                  [ /albid ] ==wal
                  [ /exbid ] ==wex
                  [ /ralbid /ralbidv2 ] ==wral
                  [ /rexbid /rexbidv2 ] ==wrex
                  [ /breq1d /breq2d /breqd /breq12d /breq123d ] ==wbr
                  [ /releqd ] ==wrel
                  [ /feq1d /feq2d /feq3d /feq12d /feq23d ] ==wf
                  [ /sbceq1a /sbceq1b /sbceq1c /sbceq1d /sbceq1e /sbceq1f /sbceq1g /sbceq1h /sbcbid /sbcbi13d /sbcbi123d ] ==wsbc
                > =thms
              } |notApplicable ? *
            }
            { 0 parse * logicNonTerminal /wceq eq { 1 parse * logicNonTerminal /wceq eq } andif } {
              0 1 parse * * logicNonTerminal =leftNt
              1 1 parse * * logicNonTerminal =rightNt
              leftNt rightNt eq {
                <
                  [ /fveq1d /fveq2d /fveq12d ] ==cfv
                  [ /oveq /oveq1d /oveq2d /oveq12d /oveq123d ] ==co
                  [ /opeq1d /opeq2d /opeq12d ] ==cop
                  [ /xpeq1d /xpeq2d /xpeq12d ] ==cxp
                  [ /inteqd ] ==cint
                  [ /abbidv /abbid ] ==cab
                  [ /rabbidv /rabeqbidv ] ==crab
                  [ /uneq1d /uneq2d /uneq12d ] ==cun
                  [ /iuneq1d /iuneq2d /iuneq12d ] ==ciun
                  [ /seqeq1d /seqeq2d /seqeq3d /seqeq123d ] ==cseq
                  [ /mpteq12dv ] ==cmpt
                  [ /mpt2eq123dv ] ==cmpt2
                  [ /coeq1d /coeq2d /coeq12d ] ==ccom
                  [ /reseq1d /reseq2d /reseq12d ] ==cres
                  [ /dmeqd ] ==cdm
                  [ /rneqd ] ==crn
                  [ /cnveqd ] ==ccnv
                  [ /unieqd ] ==cuni
                  [ /relexpeq12d ] ==crelexp
                  [ /ifeq1d /ifeq2d /ifbid /ifeq12d /ifbieq12d ] ==cif
                > =thms
              } |notApplicable ? *
            }
          ] conds

          thms leftNt .?' {
            thms leftNt . { ==thm
              goal .isopen { thm goal .thm expandMeta canUse } andif {
                thm goal use
                goal [ |auto |tacDistrAntecedent ] tacAttemptNext
              } rep
            } each

            goal .isopen { [| "\e[31mno theorem succeeded in closing goal, tried: " thms leftNt . { " " } each "\e[0m\n" |] out } rep
          } { [| "\e[31mno theorem known to process rewrite step, of type " leftNt "\e[0m\n" |] out } ? *
        } |notApplicable ? *
      } |notApplicable ? *
    } τtacDistrAntecedent /tacDistrAntecedent deffst

    { ==goal
      { "\e[31mdistr:ante (meta-version) not applicable, expected |- ( ... -> ( ... { <-> , = } ... ) )\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff metaLogicParsers * * } andif { ==parse
        parse logicNonTerminal /wi eq {
          [ ] ==leftMeta [ ] ==rightMeta
          [
            { 1 parse * logicNonTerminal [ /wb /wceq ] eq any
              { 0 1 parse * * logicRange tokens * _ =leftMeta tokensAreMetaVar } andif } {
              1 0 parse * * logicRange tokens * ==from
              0 0 parse * * logicRange tokens * ==to
              1 1 parse * * logicRange tokens * from to rewriteTokens 0 leftMeta * let
            }

            { 1 parse * logicNonTerminal [ /wb /wceq ] eq any
              { 1 1 parse * * logicRange tokens * _ =rightMeta tokensAreMetaVar } andif } {
              0 0 parse * * logicRange tokens * ==from
              1 0 parse * * logicRange tokens * ==to
              0 1 parse * * logicRange tokens * from to rewriteTokens 0 rightMeta * let
            }
          ] conds

          goal tacDistrAntecedent
        } |notApplicable ? *
      } |notApplicable ? *
    } /tacDistrAntecedentMeta deffst

    { ==to ==from ==tokens
      [
        0 ==i { i tokens len lt } {
          i from len add tokens len le { i _ from len add range tokens * from arrEq } andif {
            to _ len dearray i from len add =i
          } {
            i tokens * i 1 add =i
          } ? *
        } loop
      ]
    } τrewriteTokens /rewriteTokens deffst

    { ==goal
      { "\e[31mrewrite:ante not applicable, expected |- ( ( ... { = , <-> } ... ) -> ... )\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
        parse logicNonTerminal /wi eq { 0 parse * logicNonTerminal [ /wceq /wb ] eq any } andif {
          0 0 parse * * logicRange tokens * ==from
          1 0 parse * * logicRange tokens * ==to

          /mpbird goal use
          goal .isopen not {
            1 parse * logicRange tokens * from to rewriteTokens /ch lastMetaVariables * let
            goal [ |auto ] tacAttemptNext
            4 goal .resolution .hypotheses * ==g g .isopen {
              g tacDistrAntecedent
            } rep
          } rep
        } |notApplicable ? *
      } |notApplicable ? *
    } /tacRewriteAntecedent deffst

    { ==goal ==antecedent
      { "\e[31mrewrite:full not applicable, expected |- ... as goal and ... { = , <-> } ... as argument\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
        0 antecedent /wff logicParsers * * { ==antecedentParse
          antecedentParse logicNonTerminal [ /wceq /wb ] eq any {
            0 antecedentParse * logicRange antecedent * ==from
            1 antecedentParse * logicRange antecedent * ==to

            /mpbir goal use
            goal .isopen not {
              1 tokens len range tokens * from to rewriteTokens /ps lastMetaVariables * let
              goal [ |auto ] tacAttemptNext
              3 goal .resolution .hypotheses * ==mpbirMaj

              mpbirMaj .isopen {
                /ax-mp mpbirMaj use
                mpbirMaj .isopen not {
                  antecedent /ph lastMetaVariables * let
                  mpbirMaj [ |auto ] tacAttemptNext

                  3 mpbirMaj .resolution .hypotheses * ==g g .isopen {
                    g tacDistrAntecedent
                  } rep
                } rep
              } rep
            } rep
          } |notApplicable ? *
        } |notApplicable ? *
      } |notApplicable ? *
    } /tacRewriteFull deffst

    { ==goal ==antecedent
      { "\e[31mrewrite not applicable, expected |- ... as goal and ... { = , <-> } ... as argument\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
        0 antecedent /wff logicParsers * * { ==antecedentParse
          antecedentParse logicNonTerminal [ /wceq /wb ] eq any {
            parse logicNonTerminal /wi eq {
              /mpcom goal use
              goal .isopen not {
                antecedent /ph lastMetaVariables * let
                3 goal .resolution .hypotheses * _ .isopen { tacAndSelect } { -- } ? *
                4 goal .resolution .hypotheses * _ .isopen { tacContinueWithRewrite } { -- } ? *
                goal [ |auto ] tacAttemptNext
              } rep
            } {
              /ax-mp goal use
              goal .isopen not {
                antecedent /ph lastMetaVariables * let
                3 goal .resolution .hypotheses * _ .isopen { tacContinueWithRewrite } { -- } ? *
                goal [ |auto ] tacAttemptNext
              } rep
            } ? *
          } |notApplicable ? *
        } |notApplicable ? *
      } |notApplicable ? *
    } /tacRewrite deffst

    { ==goal
      { "\e[31mtacReplaceRecursion not applicable, expected |- ( ph -> ( ps -> ch ) ) as goal with identical structure in ps and ch\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
        parse logicNonTerminal /wi eq {
          1 parse * logicNonTerminal /wi eq {
            0 1 parse * * logicNonTerminal ==nt
            1 1 parse * * logicNonTerminal nt eq {
              [
                { nt /wbr eq } {
                  /biimpd goal use
                  goal .isopen not {
                    goal [ |auto ] tacAttemptNext
                    3 goal .resolution .hypotheses * ==g
                    g .isopen {
                      /breq123d g use
                      g [ |auto ] tacAttemptNext
                    } rep
                  } rep
                }
                { 1 } {
                  <
                    [ /anim1d /anim2d /anim12d ] ==wa
                    [ /orim1d /orim2d /orim12d ] ==wo
                    [ /3anim123d ] ==w3a
                    [ /3orim123d ] ==w3o
                    [ /imim1d /imim2d /imim12d ] ==wi
                    [ /ralimdv2 ] ==wral
                    [ /alimd ] ==wal
                    [ /reximdv2 ] ==wrex
                    [ /eximd ] ==wex
                  > ==thms

                  thms nt .?' {
                    thms nt . { ==thm
                      goal .isopen { thm goal .thm expandMeta canUse } andif {
                        thm goal use
                        goal [ |auto |tacReplaceRecursion ] tacAttemptNext
                      } rep
                    } each

                    goal .isopen { [| "\e[31mno theorem succeeded in closing goal, tried: " thms nt . { " " } each "\e[0m\n" |] out } rep
                  } { [| "\e[31mno theorem known to process rewrite step, of type " nt "\e[0m\n" |] out } ? *
                }
              ] conds
            } |notApplicable ? *
          } |notApplicable ? *
        } |notApplicable ? *
      } |notApplicable ? *
    } /tacReplaceRecursion deffst

    { ==goal ==changes
      { "\e[31mreplace not applicable, expected |- ... as goal and ... { = , <-> } ... as argument\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
        0 changes /wff logicParsers * * { ==changesParse
          changesParse logicNonTerminal [ /wceq /wb ] eq any {
            0 changesParse * logicRange changes * ==from
            1 changesParse * logicRange changes * ==to

            parse logicNonTerminal /wi eq {
              /pm2.43i goal use
              goal .isopen not {
                goal [ |auto ] tacAttemptNext
                2 goal .resolution .hypotheses * =goal
              } rep
            } rep

            goal .isopen {
              /mpdr goal use
              goal .isopen not {
                1 tokens len range tokens * from to rewriteTokens /ps lastMetaVariables * let
                3 goal .resolution .hypotheses * ==g g .isopen {
                  g tacReplaceRecursion
                } rep
                4 goal .resolution .hypotheses * ==g g .isopen {
                  /a1i g use
                  g [ |auto ] tacAttemptNext
                } rep
                goal [ |auto ] tacAttemptNext
              } rep
            } rep
          } |notApplicable ? *
        } |notApplicable ? *
      } |notApplicable ? *
    } /tacReplace deffst

    { ==goal ==name
      name assertions .has {
        name assertions * ==a
        1 a .thm len range a .thm * goal tacRewriteFull
        goal .isopen not {
          3 goal .resolution .hypotheses * ==mpbirMaj
          mpbirMaj .isopen not {
            2 mpbirMaj .resolution .hypotheses * ==g
            g .isopen {
              name g use
            } rep
          } rep
        } rep
      } {
        [| "\e[31m" name " is not an assertion" "\e[0m\n" |] out
      } ? *
    } /tacExpand deffst

    { ==goal
      goal .thm expandMeta ==tokens
      [
        0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
          parse logicNonTerminal /wi eq {
            0 parse * ==anteConjuct
            { anteConjuct logicNonTerminal /wa eq } {
              0 anteConjuct * logicRange tokens * # left in result array
              1 anteConjuct * =anteConjuct
            } loop
            anteConjuct logicRange tokens * # left in result array
          } rep
        } rep
      ]
    } τantecedents /antecedents deffst

    { ==goal
      { "\e[31mtacSelect not applicable, expected |- ( ... /\\ ... ) -> ... \e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens

      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
        goal antecedents ==antes
        antes len {
          [ ] ==goalsToAuto

          1 parse * logicRange tokens * ==target
          0 ==i 1 neg ==success
          { i antes len lt } {
            i antes * ==ante
            ante target arrEq {
              i =success antes len =i
            } rep
            i 1 add =i
          } loop

          success antes len 1 sub eq ==lastTerm

          success 0 ge {
            goal .isopen {
              faketrivialities { goal .fakeclose } {
                { success 1 ge } {
                  [
                    { success 16 ge } {
                      /adantl16 goal use
                      goalsToAuto [ goal ] cat =goalsToAuto
                      goal .isopen {
                        1 neg =success
                      } {
                        18 goal .resolution .hypotheses * =goal
                        goal .isopen not { 1 neg =success } rep
                        success 16 sub =success
                      } ? *
                    }
                    { success 8 ge } {
                      /adantl8 goal use
                      goalsToAuto [ goal ] cat =goalsToAuto
                      goal .isopen {
                        1 neg =success
                      } {
                        10 goal .resolution .hypotheses * =goal
                        goal .isopen not { 1 neg =success } rep
                        success 8 sub =success
                      } ? *
                    }
                    { success 4 ge } {
                      /adantl4 goal use
                      goalsToAuto [ goal ] cat =goalsToAuto
                      goal .isopen {
                        1 neg =success
                      } {
                        6 goal .resolution .hypotheses * =goal
                        goal .isopen not { 1 neg =success } rep
                        success 4 sub =success
                      } ? *
                    }
                    { success 3 ge } {
                      /adantl3 goal use
                      goalsToAuto [ goal ] cat =goalsToAuto
                      goal .isopen {
                        1 neg =success
                      } {
                        5 goal .resolution .hypotheses * =goal
                        goal .isopen not { 1 neg =success } rep
                        success 3 sub =success
                      } ? *
                    }
                    { success 2 ge } {
                      /adantl2 goal use
                      goalsToAuto [ goal ] cat =goalsToAuto
                      goal .isopen {
                        1 neg =success
                      } {
                        4 goal .resolution .hypotheses * =goal
                        goal .isopen not { 1 neg =success } rep
                        success 2 sub =success
                      } ? *
                    }
                    { success 1 ge } {
                      /adantl goal use
                      goalsToAuto [ goal ] cat =goalsToAuto
                      goal .isopen {
                        1 neg =success
                      } {
                        3 goal .resolution .hypotheses * =goal
                        goal .isopen not { 1 neg =success } rep
                        success 1 sub =success
                      } ? *
                    }
                  ] conds
                } loop
                goal .isopen {
                  lastTerm /id /simpl ? goal use
                  goalsToAuto [ goal ] cat =goalsToAuto
                } rep
              } ? *
            } rep
          } { "\e[33mtacSelect not applicable, consequent not found in antecedents\e[0m\n" out } ? *

          goalsToAuto { [ |auto ] tacAttemptNext } each
        } |notApplicable ? *
      } |notApplicable ? *
    } /tacSelect deffst

    { ==goal
      { "\e[31mtacAndSelect not applicable, expected |- ( ... /\\ ... ) -> ( ... /\\ ... )\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
        parse logicNonTerminal /wi eq {
          1 parse * logicRange tokens * ==target 0 ==existsAsAnte

          goal antecedents ==antes
          antes { ==ante
            ante target arrEq { 1 =existsAsAnte } rep
          } each

          existsAsAnte {
            goal tacSelect
          } {
            1 parse * logicNonTerminal /wa eq {
                1 1 parse * * logicNonTerminal /wa eq
                { 1 1 1 parse * * * logicNonTerminal /wa eq } andif
                { 1 1 1 1 parse * * * * logicNonTerminal /wa eq } andif {
                /jca4 goal use
              } {
                /jca goal use
              } ? *
              goal [ |auto |tacAndSelect ] tacAttemptNext
            } rep
          } ? *
        } |notApplicable ? *
      } |notApplicable ? *
    } /tacAndSelectAfterDrop deffst

    { ==goal
      { "\e[31mtacAndSelect not applicable, expected |- ( ... /\\ ... ) -> ( ... /\\ ... )\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
        parse logicNonTerminal /wi eq {
          1 parse * logicRange tokens * ==target 0 ==existsAsAnte

          goal antecedents ==antes
          antes { ==ante
            ante target arrEq { 1 =existsAsAnte } rep
          } each

          existsAsAnte {
            goal tacSelect
          } {
            { ==parse
              [
                { parse logicNonTerminal /wa eq } {
                  0 parse * collectTerms
                  1 parse * collectTerms
                }
                { parse logicNonTerminal /w3a eq } {
                  0 parse * collectTerms
                  1 parse * collectTerms
                  2 parse * collectTerms
                }
                { 1 } { parse logicRange tokens * }
              ] conds
            } /collectTerms deffst
            [ 1 parse * collectTerms ] ==conclusions

            [ conclusions { ==conclusion
              [ antes { conclusion arrEq } each ] any
            } each ] all {
              [ antes { ==ante
                [ conclusions { ante arrEq } each ] any not { ante } rep
              } each ] goal tacDropAll

              goal openGoals ==open
              open len 1 eq {
                0 open * ==dropped
                dropped .isopen { dropped tacAndSelectAfterDrop } rep
              } rep
            } {
              goal tacAndSelectAfterDrop
            } ? *
          } ? *
        } |notApplicable ? *
      } |notApplicable ? *
    } /tacAndSelect deffst

    { ==goal ==tokens
      0 tokens /wff logicParsers * * { --
        /mpcom goal use
        goal .isopen not {
          tokens /ph lastMetaVariables * let
          goal [ |auto ] tacAttemptNext
          3 goal .resolution .hypotheses * _ .isopen { tacAndSelect } { -- } ? *
        } rep
      } { "\e[31mdesired antecedent did not parse as valid wff, would never be satisfiable\e[0m\n" out } ? *
    } /tacUnder deffst

    { ==goal ==tokens
      { "\e[31mwith not applicable, expected |- ...\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==goalTokens
      0 goalTokens * "|-" eq { 1 goalTokens /wff logicParsers * * } andif { ==goalParse
        0 tokens /wff logicParsers * * { --
          goalParse logicNonTerminal /wi eq {
            /mpd goal use
            goal .isopen not {
              tokens /ps lastMetaVariables * let
              goal [ |auto ] tacAttemptNext
              3 goal .resolution .hypotheses * _ .isopen { tacAndSelect } { -- } ? *
            } rep
          } {
            /ax-mp goal use
            goal .isopen not {
              tokens /ph lastMetaVariables * let
              goal [ |auto ] tacAttemptNext
            } rep
          } ? *
        } { "\e[31mdesired antecedent did not parse as valid wff, would never be satisfiable\e[0m\n" out } ? *
      } |notApplicable ? *
    } /tacWith deffst

    { ==goal ==tokens
      0 tokens /wff logicParsers * * { --
        /syl goal use
        goal .isopen not {
          tokens /ps lastMetaVariables * let
          goal [ |auto ] tacAttemptNext
          3 goal .resolution .hypotheses * _ .isopen { tacAndSelect } { -- } ? *
        } rep
      } { "\e[31mdesired antecedent did not parse as valid wff, would never be satisfiable\e[0m\n" out } ? *
    } /tacWithOnly deffst

    { ==goal ==tokens
      0 tokens /wff logicParsers * * { ==parse
        goal .thm expandMeta ==goalToks
        0 goalToks * "|-" eq { 1 goalToks /wff logicParsers * * } andif { ==goalParse
          goalParse logicNonTerminal /wi eq
            /mpancom /ax-mp ? goal use
          goal .isopen not {
            tokens /ph lastMetaVariables * let
            goal [ |auto ] tacAttemptNext
          } rep
        } { "\e[31mcurrent goal is not |- ...\e[0m\n" out } ? *
      } { "\e[31mdesired conclusion did not parse as valid wff, would never be satisfiable\e[0m\n" out } ? *
    } /tacConclude deffst

    { ==goal ==tokens
      0 tokens /wff logicParsers * * { ==parse
        goal .thm expandMeta ==goalToks
        0 goalToks * "|-" eq { 1 goalToks /wff logicParsers * * } andif { ==goalParse
          goalParse logicNonTerminal /wi eq {
            0 goalParse * logicNonTerminal /wa eq {
              /sylancom goal use
              goal .isopen not {
                tokens /ch lastMetaVariables * let
              } rep
            } {
              /syl goal use
              goal .isopen not {
                tokens /ps lastMetaVariables * let
              } rep
            } ? *
            goal [ |auto ] tacAttemptNext
          } { "\e[31current goal is not |- ( ... -> ... )\e[0m\n" out } ? *
        } { "\e[31mcurrent goal is not |- ...\e[0m\n" out } ? *
      } { "\e[31mdesired conclusion did not parse as valid wff, would never be satisfiable\e[0m\n" out } ? *
    } /tacAndConclude deffst

    { ==goal ==tokens # an array of arrays of tokens
      goal antecedents ==antes

      map ==toRemove
      tokens { ==toks 1 [| toks { " " } each |] toRemove =[] } each
      [ ] ==toKeep
      [ ] ==kept

      antes { ==ante
        [| ante { " " } each |] toRemove .has {
          kept [ 0 ] cat =kept
        } {
          toKeep [ ante ] cat =toKeep
          kept [ 1 ] cat =kept
        } ? *
      } each

      { ==clauses # array of array of tokens
        [
          { clauses len 0 eq } { [ "T." ] }
          { clauses len 1 eq } { [ 0 clauses * _ len dearray ] }
          { 1 } {
            [ "("
              0 clauses * _ len dearray
            "/\\"
              1 clauses len range clauses * conjuction _ len dearray
            ")" ]
          }
        ] conds
      } /conjuction deffst

      /syl goal use
      goal .isopen not {
        toKeep conjuction /ps lastMetaVariables * let
        goal [ |auto ] tacAttemptNext

        3 goal .resolution .hypotheses * ==conversion
        faketrivialities { conversion .fakeclose } {
          { kept len conversion .isopen and } {
            [
              { kept len 16 gt { 0 16 range kept * any not } andif } {
                /adantl16 conversion use
                conversion .isopen not {
                  conversion [ |auto ] tacAttemptNext
                  18 conversion .resolution .hypotheses * =conversion
                } rep
                16 kept len range kept * =kept
              }
              { kept len 8 gt { 0 8 range kept * any not } andif } {
                /adantl8 conversion use
                conversion .isopen not {
                  conversion [ |auto ] tacAttemptNext
                  10 conversion .resolution .hypotheses * =conversion
                } rep
                8 kept len range kept * =kept
              }
              { kept len 4 gt { 0 4 range kept * any not } andif } {
                /adantl4 conversion use
                conversion .isopen not {
                  conversion [ |auto ] tacAttemptNext
                  6 conversion .resolution .hypotheses * =conversion
                } rep
                4 kept len range kept * =kept
              }
              { kept len 3 gt { 0 3 range kept * any not } andif } {
                /adantl3 conversion use
                conversion .isopen not {
                  conversion [ |auto ] tacAttemptNext
                  5 conversion .resolution .hypotheses * =conversion
                } rep
                3 kept len range kept * =kept
              }
              { kept len 2 gt { 0 2 range kept * any not } andif } {
                /adantl2 conversion use
                conversion .isopen not {
                  conversion [ |auto ] tacAttemptNext
                  4 conversion .resolution .hypotheses * =conversion
                } rep
                2 kept len range kept * =kept
              }
              { 0 kept * not } {
                /adantl conversion use
                conversion .isopen not {
                  conversion [ |auto ] tacAttemptNext
                  3 conversion .resolution .hypotheses * =conversion
                } rep
                1 kept len range kept * =kept
              }
              { 1 } {
                /anim2i conversion use
                conversion .isopen not {
                  conversion [ |auto ] tacAttemptNext
                  3 conversion .resolution .hypotheses * =conversion
                } rep
                1 kept len range kept * =kept
              }
            ] conds
          } loop
        } ? *
      } rep
    } /tacDropAll deffst

    { ==goal ==tokens
      [ tokens ] goal tacDropAll
    } /tacDrop deffst

    { ==goal ==tokens # a sequence of tokens to search for
      goal antecedents ==antes
      antes len {
        [ ] ==toRemove # ante indices to drop

        0 antes len range { _ ==i antes * ==ante
          0 ante len tokens len sub 1 add range { ==start
            start _ tokens len add range ante * tokens arrEq {
              toRemove [ i ] cat =toRemove
            } rep
          } each
        } each

        toRemove antes * goal tacDropAll
      } { "\e[31mtacDropMatching not applicable, expected |- ... -> ... \e[0m\n" out } ? *
    } /tacDropMatching deffst

    { ==goal
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
        parse logicNonTerminal /wi eq {
          goal ==toRewrite
          0 parse * logicNonTerminal /wa eq {
            /imp goal use
            goal .isopen not {
              3 goal .resolution .hypotheses * =toRewrite
            } rep
          } rep
          toRewrite tacRewriteAntecedent
          toRewrite .isopen not {
            3 toRewrite .resolution .hypotheses * ==continuation
            continuation .isopen {
              /a1i continuation use
              continuation [ |auto ] tacAttemptNext
            } rep
          } rep
          goal [ |auto ] tacAttemptNext
        } { "\e[31mcurrent goal is not |- ( ... -> ... )\e[0m\n" out } ? *
      } { "\e[31mcurrent goal is not |- ...\e[0m\n" out } ? *
    } /tacContinueWithRewrite deffst

    { ==goal
      goal antecedents ==antes
      0 ==doRewrite
      antes { ==ante
        0 ante /wff logicParsers * * { ==parse
          parse logicNonTerminal [ /wa /w3a ] eq any { 1 =doRewrite } rep
        } rep
      } each

      doRewrite {
        {
          goal .thm expandMeta ==tokens
          0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
            parse logicNonTerminal /wi eq {
              [
                { 0 parse * logicNonTerminal /wa eq } {
                  [
                    { 0 0 parse * * logicNonTerminal /wa eq } {
                      1 0 0 parse * * * logicNonTerminal /wa eq
                          { 1 1 0 0 parse * * * * logicNonTerminal /wa eq } andif
                          { 1 1 1 0 0 parse * * * * * logicNonTerminal /wa eq } andif {
                        /animpass4 goal use
                        goal [ |auto ] tacAttemptNext
                        goal .isopen { 0 =doRewrite } { 7 goal .resolution .hypotheses * =goal } ? *
                      } {
                        /animpass goal use
                        goal [ |auto ] tacAttemptNext
                        goal .isopen { 0 =doRewrite } { 4 goal .resolution .hypotheses * =goal } ? *
                      } ? *
                    }
                    { 0 0 parse * * logicNonTerminal /w3a eq } {
                      /3imp1 goal use
                      goal [ |auto ] tacAttemptNext
                      goal .isopen { 0 =doRewrite } { 5 goal .resolution .hypotheses * =goal } ? *
                    }
                    { goal .isopen } {
                      { ==parse
                        [
                          { 0 parse * logicNonTerminal /wa eq } { 1 }
                          { 1 parse * logicNonTerminal /wa eq } { 1 parse * hasAnyNestedConjucts }
                          { 1 } { 0 }
                        ] conds
                      } /hasAnyNestedConjucts deffst

                      0 parse * hasAnyNestedConjucts {
                        /impcom goal use
                        goal [ |auto ] tacAttemptNext
                        goal .isopen { 0 =doRewrite } { 3 goal .resolution .hypotheses * =goal } ? *
                      } {
                        0 =doRewrite
                      } ? *
                    }
                    { 1 } { 0 =doRewrite }
                  ] conds
                  1
                }
                { 0 parse * logicNonTerminal /w3a eq } {
                  /3imp goal use
                  goal [ |auto ] tacAttemptNext
                  goal .isopen { 0 =doRewrite } { 4 goal .resolution .hypotheses * =goal } ? *
                  1
                }
                { 1 } { 0 }
              ] conds
            } { 0 } ? *
          } { 0 } ? *
          doRewrite and goal .isopen and
        } { } loop

        goal .isopen {
          goal tacNormalizeLogic
        } rep
      } rep
    } /tacNormalizeAntecedent deffst

    { |tacNormalizeConsequent ==tmp
      { -- } =tacNormalizeConsequent
      tacNormalizeAntecedent
      tmp =tacNormalizeConsequent
    } /tacNormalizeAntecedentOnly deffst

    { ==goal ==from ==to
      { "\e[31mtacRename not applicable, expected |- ...\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      tokens to neq all {
        0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
          goal .thm expandMeta ==tokens
          /vtocl goal use
          goal .isopen not {
            [ from ] /A lastMetaVariables * let
            [ to ] /x lastMetaVariables * let
            [ parse logicRange tokens * { _ ==t from eq to t ? } each ] /ph lastMetaVariables * let

            5 goal .resolution .hypotheses * tacRewriteAntecedent
            goal [ |auto ] tacAttemptNext
          } rep
        } |notApplicable ? *
      } { "\e[31mtarget name already in use, cannot rename\e[0m\n" out } ? *
    } /tacRename deffst

    { ==goal
      { "\e[31mtacNormalizeConsequent not applicable, expected |- ...\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
        [
          { parse logicNonTerminal /wi eq } {
            [
              { 1 parse * logicNonTerminal /wa eq } {
                  1 1 parse * * logicNonTerminal /wa eq
                  { 1 1 1 parse * * * logicNonTerminal /wa eq } andif
                  { 1 1 1 1 parse * * * * logicNonTerminal /wa eq } andif {
                  /jca4 goal use
                } {
                  /jca goal use
                } ? *
                goal [ |auto |tacNormalizeLogic |tacNormalizeConsequent ] tacAttemptNext
              }
              { 1 parse * logicNonTerminal /w3a eq } {
                /3jca goal use
                goal [ |auto |tacNormalizeLogic |tacNormalizeConsequent ] tacAttemptNext
              }
            ] conds
          }
          { parse logicNonTerminal /wa eq } {
            /pm3.2i goal use
            goal [ |auto |tacNormalizeLogic |tacNormalizeConsequent ] tacAttemptNext
          }
          { parse logicNonTerminal /w3a eq } {
            /3pm3.2i goal use
            goal [ |auto |tacNormalizeLogic |tacNormalizeConsequent ] tacAttemptNext
          }
        ] conds
      } |notApplicable ? *
    } /tacNormalizeConsequent deffst

    { ==goal
      { "\e[31mnormalize not applicable, expected |- ...\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
        parse logicNonTerminal /wi eq {
          0 ==implicationCount
          1 parse * ==i
          { i logicNonTerminal /wi eq } {
            implicationCount 1 add =implicationCount
            1 i * =i
          } loop

          [
            { implicationCount 16 ge } {
              /expcom16 goal use
              goal [ |auto |tacNormalizeLogic ] tacAttemptNext
            }
            { implicationCount 8 ge } {
              /expcom8 goal use
              goal [ |auto |tacNormalizeLogic ] tacAttemptNext
            }
            { implicationCount 4 ge } {
              /expcom4 goal use
              goal [ |auto |tacNormalizeLogic ] tacAttemptNext
            }
            { implicationCount 2 ge } {
              /expcom2 goal use
              goal [ |auto |tacNormalizeLogic ] tacAttemptNext
            }
            { implicationCount 1 ge } {
              /expcom goal use
              goal [ |auto |tacNormalizeLogic ] tacAttemptNext
            }
            { 1 } {
              goal tacNormalizeAntecedent
              goal .isopen {
                /id tokens canUse {
                  /id goal use
                } {
                  goal tacNormalizeConsequent
                } ? *
              } rep
            }
          ] conds
        } rep
      } |notApplicable ? *
    } /tacNormalizeLogic deffst

    { ==parse ==tokens
      0 ==M 0 ==N
      [
        { parse logicNonTerminal /co eq
            { 0 parse * parseNumber _ { -01 =N } rep } andif
            { 2 parse * parseNumber _ { -01 =M } rep } andif
            { 1 parse * logicNonTerminal [ /caddc /cmin /cmul /cmo /cexp ] eq any } andif } {
          1 parse * logicNonTerminal ==nt
          { N printNumber _ len dearray } =*Nt { M printNumber _ len dearray } =*Mt

          [
            { nt /caddc eq } { [ "(" Nt "+" Mt ")" "=" N M add printNumber _ len dearray ] }
            { nt /cmin eq } { N M ge {
                [ "(" Nt "-" Mt ")" "=" N M sub printNumber _ len dearray ]
              } {
                [ "(" Nt "-" Mt ")" "=" "-u" N M sub neg printNumber _ len dearray ]
              } ? *
            }
            { nt /cmul eq } { [ "(" Nt "x." Mt ")" "=" N M mul printNumber _ len dearray ] }
            { nt /cmo eq } { [ "(" Nt "mod" Mt ")" "=" N M mod printNumber _ len dearray ] }
            { nt /cexp eq } { [ "(" Nt "^" Mt ")" "=" N M exp printNumber _ len dearray ] }
          ] conds
        }
        # ( ( X {+,-} N ) + M )
        { parse logicNonTerminal /co eq
            { 0 parse * logicNonTerminal /co eq } andif
            { 2 0 parse * * parseNumber _ { -01 =N } rep } andif
            { 2 parse * parseNumber _ { -01 =M } rep } andif
            { 1 parse * logicNonTerminal /caddc eq } andif } {
          1 0 parse * * logicNonTerminal ==nt
          { N printNumber _ len dearray } =*Nt { M printNumber _ len dearray } =*Mt

          [
            { nt /caddc eq } {
              [ parse logicRange tokens * _ len dearray "="
                "(" 0 0 parse * * logicRange tokens * _ len dearray "+"
                "(" Nt "+" Mt ")" ")" ]
            }
            { nt /cmin eq } {
              [ parse logicRange tokens * _ len dearray "="
                "(" 0 0 parse * * logicRange tokens * _ len dearray "+"
                "(" Mt "-" Nt ")" ")" ]
            }
          ] conds
        }
        { parse logicNonTerminal /co eq
            { 1 parse * logicNonTerminal /caddc eq } andif
            { 2 parse * logicNonTerminal /cneg eq } andif } {
          [ parse logicRange tokens * _ len dearray "="
            "(" 0 parse * logicRange tokens * _ len dearray "-" 0 2 parse * * logicRange tokens * _ len dearray ")" ]
        }
        { parse logicNonTerminal /c10 eq } {
            [ "10" "=" ";" "1" "0" ]
        }
        { 1 } {
          0 parse logicChildCount range { tokens -01 parse * extractArithmeticTrivialities } each
        }
      ] conds
    } /extractArithmeticTrivialities deffst

    { ==goal
      { "\e[31mnormalize:arith not applicable, expected |- ...\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff logicParsers * * } andif { ==parse
        [
          # TODO: import and improve the grammar matcher and simplify these comparison tables
          # the following needs early handling, otherwise infinite recursion
          # ( ( x reg ; 1 3 ) + -u 9 ) = ( ( x reg ; 1 3 ) - 9 )
          { parse logicNonTerminal /wi eq
              { 1 parse * logicNonTerminal /wceq eq } andif
              { 0 1 parse * * logicNonTerminal /co eq } andif
              { 1 1 parse * * logicNonTerminal /co eq } andif
              { 1 0 1 parse * * * logicNonTerminal /caddc eq } andif
              { 2 0 1 parse * * * logicNonTerminal /cneg eq } andif
              { 1 1 1 parse * * * logicNonTerminal /cmin eq } andif
              { 0 0 1 parse * * * logicRange tokens *
                0 1 1 parse * * * logicRange tokens * arrEq } andif
              { 0 2 0 1 parse * * * * logicRange tokens *
                2 1 1 parse * * * logicRange tokens * arrEq } andif } {
            /negsub goal tacUse
          }
          { parse logicNonTerminal /wceq eq
              { 0 parse * logicNonTerminal /co eq } andif
              { 1 parse * logicNonTerminal /co eq } andif
              { 1 0 parse * * logicNonTerminal /caddc eq } andif
              { 2 0 parse * * logicNonTerminal /cneg eq } andif
              { 1 1 parse * * logicNonTerminal /cmin eq } andif
              { 0 0 parse * * logicRange tokens *
                0 1 parse * * logicRange tokens * arrEq } andif
              { 0 2 0 parse * * * logicRange tokens *
                2 1 parse * * logicRange tokens * arrEq } andif } {
            /negsubi goal use
            goal [ |auto |tacNormalizeArith ] tacAttemptNext
          }
          # ( ( A + B ) + C ) = ( A + ( C + B ) )
          { parse logicNonTerminal /wi eq
              { 1 parse * logicNonTerminal /wceq eq } andif
              { 0 1 parse * * logicNonTerminal /co eq } andif
              { 1 1 parse * * logicNonTerminal /co eq } andif
              { 1 0 1 parse * * * logicNonTerminal /caddc eq } andif
              { 1 1 1 parse * * * logicNonTerminal /caddc eq } andif
              { 0 0 1 parse * * * logicNonTerminal /co eq } andif
              { 2 1 1 parse * * * logicNonTerminal /co eq } andif
              { 1 0 0 1 parse * * * * logicNonTerminal /caddc eq } andif
              { 1 2 1 1 parse * * * * logicNonTerminal /caddc eq } andif
              { 0 0 0 1 parse * * * * logicRange tokens *
                0 1 1 parse * * * logicRange tokens * arrEq } andif
              { 2 0 0 1 parse * * * * logicRange tokens *
                0 2 1 1 parse * * * * logicRange tokens * arrEq } andif
              { 2 0 1 parse * * * logicRange tokens *
                2 2 1 1 parse * * * * logicRange tokens * arrEq } andif } {
            /addass goal tacUse
          }
          { parse logicNonTerminal /wceq eq
              { 0 parse * logicNonTerminal /co eq } andif
              { 1 parse * logicNonTerminal /co eq } andif
              { 1 0 parse * * logicNonTerminal /caddc eq } andif
              { 1 1 parse * * logicNonTerminal /caddc eq } andif
              { 0 0 parse * * logicNonTerminal /co eq } andif
              { 2 1 parse * * logicNonTerminal /co eq } andif
              { 1 0 0 parse * * * logicNonTerminal /caddc eq } andif
              { 1 2 1 parse * * * logicNonTerminal /caddc eq } andif
              { 0 0 0 parse * * * logicRange tokens *
                0 1 parse * * logicRange tokens * arrEq } andif
              { 2 0 0 parse * * * logicRange tokens *
                0 2 1 parse * * * logicRange tokens * arrEq } andif
              { 2 0 parse * * logicRange tokens *
                2 2 1 parse * * * logicRange tokens * arrEq } andif } {
            /addass goal tacUse
            goal [ |auto |tacNormalizeArith ] tacAttemptNext
          }
          # ( ( A - B ) + C ) = ( A + ( C - B ) )
          { parse logicNonTerminal /wi eq
              { 1 parse * logicNonTerminal /wceq eq } andif
              { 0 1 parse * * logicNonTerminal /co eq } andif
              { 1 1 parse * * logicNonTerminal /co eq } andif
              { 1 0 1 parse * * * logicNonTerminal /caddc eq } andif
              { 1 1 1 parse * * * logicNonTerminal /caddc eq } andif
              { 0 0 1 parse * * * logicNonTerminal /co eq } andif
              { 2 1 1 parse * * * logicNonTerminal /co eq } andif
              { 1 0 0 1 parse * * * * logicNonTerminal /cmin eq } andif
              { 1 2 1 1 parse * * * * logicNonTerminal /cmin eq } andif
              { 0 0 0 1 parse * * * * logicRange tokens *
                0 1 1 parse * * * logicRange tokens * arrEq } andif
              { 2 0 0 1 parse * * * * logicRange tokens *
                2 2 1 1 parse * * * * logicRange tokens * arrEq } andif
              { 2 0 1 parse * * * logicRange tokens *
                0 2 1 1 parse * * * * logicRange tokens * arrEq } andif } {
            /subadd23 goal tacUse
          }
          { parse logicNonTerminal /wceq eq
              { 0 parse * logicNonTerminal /co eq } andif
              { 1 parse * logicNonTerminal /co eq } andif
              { 1 0 parse * * logicNonTerminal /caddc eq } andif
              { 1 1 parse * * logicNonTerminal /caddc eq } andif
              { 0 0 parse * * logicNonTerminal /co eq } andif
              { 2 1 parse * * logicNonTerminal /co eq } andif
              { 1 0 0 parse * * * logicNonTerminal /cmin eq } andif
              { 1 2 1 parse * * * logicNonTerminal /cmin eq } andif
              { 0 0 0 parse * * * logicRange tokens *
                0 1 parse * * logicRange tokens * arrEq } andif
              { 2 0 0 parse * * * logicRange tokens *
                2 2 1 parse * * * logicRange tokens * arrEq } andif
              { 2 0 parse * * logicRange tokens *
                0 2 1 parse * * * logicRange tokens * arrEq } andif } {
            /subadd23 goal use
            goal [ |auto |tacNormalizeArith ] tacAttemptNext
          }
          { 1 } {
            [ tokens parse extractArithmeticTrivialities ] ==equalities
            equalities len 0 gt {
              0 equalities * ==equality
              [ equality |isConst each ] all {
                equality goal tacRewriteFull
                [ |auto |tacNormalizeArith ] goal tacAttemptRecursive
              } {
                equality goal tacRewrite
                [ |auto |tacNormalizeArith ] goal tacAttemptRecursive
              } ? *
            } rep
          }
        ] conds
      } |notApplicable ? *
    } /tacNormalizeArith deffst

    { ==goal
      goal tacNormalizeArith
      goal openGoals { ==g
        0 g .thm * "|-" eq {
          g tacNormalizeLogic
          g .isopen { g auto } rep
        } rep
      } each
    } /tacNormalize deffst

    { ==goals
      {
        [ goals { ==goal
          goal .isopen {
            goal .thm expandMeta ==tokens
            0 tokens * "|-" eq { 1 tokens /wff metaLogicParsers * * } andif { ==parse
              parse logicNonTerminal /wi eq
                  { 0 parse * logicNonTerminal [ /wb /wceq ] eq any } andif
                  { 1 parse * logicNonTerminal [ /wb /wceq ] eq any } andif {
                0 1 parse * * logicRange tokens * ==leftMeta
                1 1 parse * * logicRange tokens * ==rightMeta
                [
                  { leftMeta tokensAreMetaVar rightMeta tokensAreMetaVar not and } {
                    1 0 parse * * logicRange tokens * ==from
                    0 0 parse * * logicRange tokens * ==to
                    1 1 parse * * logicRange tokens * from to rewriteTokens 0 leftMeta * let
                  }

                  { leftMeta tokensAreMetaVar not rightMeta tokensAreMetaVar and } {
                    0 0 parse * * logicRange tokens * ==from
                    1 0 parse * * logicRange tokens * ==to
                    0 1 parse * * logicRange tokens * from to rewriteTokens 0 rightMeta * let
                  }
                ] conds

                goal .thm expandMeta ==tokensSubstituted
                1 tokensSubstituted /wff logicParsers * * { --
                  goal tacDistrAntecedent
                  goal .isopen not { 1 } rep # repeat
                } rep
              } rep
            } rep
          } rep
        } each ] len
      } { } loop
    } /tacSubstitutions deffst

    { ==parse
      parse logicNonTerminal ==nt
      [
        { nt /cc0 eq } { 0 1 }
        { nt /c1 eq } { 1 1 }
        { nt /c2 eq } { 2 1 }
        { nt /c3 eq } { 3 1 }
        { nt /c4 eq } { 4 1 }
        { nt /c5 eq } { 5 1 }
        { nt /c6 eq } { 6 1 }
        { nt /c7 eq } { 7 1 }
        { nt /c8 eq } { 8 1 }
        { nt /c9 eq } { 9 1 }
        { nt /cdc eq } {
          0 parse * parseNumber { ==high
            1 parse * parseNumber { ==low
              high 10 mul low add 1
            } { 0 } ? *
          } { 0 } ? *
        }
        { 1 } { 0 }
      ] conds
    } τparseNumber /parseNumber deffst

    # this function does not guarantee a correct parse but assumes it
    { ==toks
      0
      toks { ==t
        [
          { t ";" eq } { }
          { t len 1 eq { 0 t * 48 ge 0 t * 57 le and } andif } { 10 mul 0 t * 48 sub add }
          { 1 } { "\e[33minvalid number in parseNumberToks\e[0m\n" out -- 1 neg }
        ] conds
      } each
    } τparseNumberToks /parseNumberToks deffst

    { ==goal
      { "\e[31msolve:arith not applicable, expected |- ( <decimal> { + , - , x. , ^ } <decimal> ) = <decimal>\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      [ /dec0h /addid1i /addid2i /mul01i /mul02i /mulid1i /mulid2i /numexp0 /numexp1 ] { ==thm
        goal .isopen { thm tokens canUse } andif {
          thm goal use
          goal [ |auto ] tacAttemptNext
        } rep
      } each

      goal .isopen {
        0 tokens * "|-" eq { 1 tokens /wff metaLogicParsers * * } andif { ==parse
          parse logicNonTerminal "wceq" eq { 0 parse * logicNonTerminal /co eq } andif {
            0 0 parse * * ==left
            1 0 parse * * ==operation
            2 0 parse * * ==right
            1 parse * ==result

            left parseNumber { ==leftNum
              right parseNumber { ==rightNum
                result parseNumber { ==resultNum
                  [
                    { operation logicNonTerminal /caddc eq } {
                      [
                        { leftNum rightNum add resultNum neq } { "\e[31mincorrect addition result\e[0m\n" out }
                        { faketrivialities } { goal .fakeclose }
                        { left logicNonTerminal /cdc eq right logicNonTerminal /cdc eq or } {
                          leftNum 10 mod rightNum 10 mod add 9 gt {
                            /decaddc goal use
                          } {
                            /decadd goal use
                          } ? *

                          goal .isopen not {
                            left logicNonTerminal /cdc eq {
                              0 left * logicRange tokens * /A lastMetaVariables * let
                              1 left * logicRange tokens * /B lastMetaVariables * let
                            } {
                              [ "0" ] /A lastMetaVariables * let
                              left logicRange tokens * /B lastMetaVariables * let
                            } ? *
                            right logicNonTerminal /cdc eq {
                              0 right * logicRange tokens * /C lastMetaVariables * let
                              1 right * logicRange tokens * /D lastMetaVariables * let
                            } {
                              [ "0" ] /C lastMetaVariables * let
                              right logicRange tokens * /D lastMetaVariables * let
                            } ? *
                            goal [ |auto |tacSolveArith ] tacAttemptNext
                          } rep
                        }
                        { leftNum rightNum lt } {
                          /eqtri goal use
                          goal .isopen not {
                            [
                              "("
                              right logicRange tokens * _ len dearray
                              "+"
                              left logicRange tokens * _ len dearray
                              ")"
                            ] /B lastMetaVariables * let
                            /addcomi 3 goal .resolution .hypotheses * use

                            3 goal .resolution .hypotheses * [ |auto |tacSolveArith ] tacAttemptNext
                            goal [ |auto |tacSolveArith ] tacAttemptNext
                          } rep
                        }
                        { 1 parse * logicNonTerminal /cdc eq
                            { 0 1 parse * * logicNonTerminal /c1 eq } andif
                            { 1 1 parse * * logicNonTerminal /cc0 eq } andif } {
                          /eqtri goal use
                          goal .isopen not {
                            [ "10" ] /B lastMetaVariables * let
                            /dec10 4 goal .resolution .hypotheses * use

                            4 goal .resolution .hypotheses * [ |auto ] tacAttemptNext
                            goal [ |auto |tacSolveArith ] tacAttemptNext
                          } rep
                        }
                        { 1 parse * logicNonTerminal /cdc eq
                            { 0 1 parse * * logicNonTerminal /cc0 eq } andif } {
                          /eqtri goal use
                          goal .isopen not {
                            1 1 parse * * logicRange tokens * /B lastMetaVariables * let
                            goal [ |auto |tacSolveArith ] tacAttemptNext
                          } rep
                        }
                        { 1 } { "\e[31msolve:arith does not deal with ( [0-9] + [0-9] )\e[0m\n" out }
                      ] conds
                    }
                    { operation logicNonTerminal /cmin eq } {
                      /subaddi goal tacUse # TODO: replace with mpbir sequence or similar
                      goal [ |auto |tacSolveArith ] tacAttemptNext
                    }
                    { operation logicNonTerminal /cmul eq } {
                      [
                        { leftNum rightNum mul resultNum neq } { "\e[31mincorrect multiplication result\e[0m\n" out }
                        { faketrivialities } { goal .fakeclose }
                        # { leftNum txt .produce .u len 3 ge { rightNum txt .produce .u len 3 ge } andif } {
                        #   { -0110 == printNumber -01 lastMetaVariables * let }' "=>" deffst

                        #   /karatsuba goal use
                        #   leftNum txt .produce .u len 2 div =>M
                        #   10 M exp ==d
                        #   leftNum _ d div =>A d mod =>B
                        #   rightNum _ d div =>C d mod =>D
                        #   A C mul =>R
                        #   B D mul =>T
                        #   A B add C D add mul T sub R sub =>S
                        #   R d mul S add =>W

                        #   goal [ |auto |tacNormalizeArith ] tacAttemptNext
                        # }
                        { left logicNonTerminal /cdc eq { right logicNonTerminal /cdc eq } andif } {
                          /decmul12c goal use
                          goal .isopen not {
                            leftNum _ 10 div ==A 10 mod ==B
                            rightNum _ 10 div ==C 10 mod ==D
                            { -0110 == printNumber -01 lastMetaVariables * let }' "=>" deffst

                            B D mul 10 div =>H
                            A D mul _ 10 div =>I 10 mod =>J
                            C B mul _ 10 div =>K 10 mod =>L
                            I K add =>N
                            H J add =>O
                            O L add 10 div =>M
                            A C mul =>P
                            N M add =>Q

                            goal [ |auto |tacSolveArith ] tacAttemptNext
                          } rep
                        }
                        { left logicNonTerminal /cdc eq } {
                          /decmul1c goal use
                          goal .isopen not {
                            leftNum 10 div printNumber /A lastMetaVariables * let
                            leftNum 10 mod printNumber /B lastMetaVariables * let
                            leftNum 10 mod rightNum mul 10 div printNumber /E lastMetaVariables * let
                          } rep
                          goal [ |auto |tacSolveArith ] tacAttemptNext
                        }
                        { right logicNonTerminal /cdc eq } {
                          /decmul2c goal use
                          goal .isopen not {
                            rightNum 10 div printNumber /A lastMetaVariables * let
                            rightNum 10 mod printNumber /B lastMetaVariables * let
                            rightNum 10 mod leftNum mul 10 div printNumber /E lastMetaVariables * let
                          } rep
                          goal [ |auto |tacSolveArith ] tacAttemptNext
                        }
                        { leftNum rightNum lt } {
                          /eqtri goal use
                          goal .isopen not {
                            [
                              "("
                              right logicRange tokens * _ len dearray
                              "x."
                              left logicRange tokens * _ len dearray
                              ")"
                            ] /B lastMetaVariables * let
                            /mulcomi 3 goal .resolution .hypotheses * use

                            3 goal .resolution .hypotheses * [ |auto |tacSolveArith ] tacAttemptNext
                            goal [ |auto |tacSolveArith ] tacAttemptNext
                          } rep
                        }
                        { 1 parse * logicNonTerminal /cdc eq
                            { 0 1 parse * * logicNonTerminal /c1 eq } andif
                            { 1 1 parse * * logicNonTerminal /cc0 eq } andif } {
                          /eqtri goal use
                          goal .isopen not {
                            [ "10" ] /B lastMetaVariables * let
                            /dec10 4 goal .resolution .hypotheses * use

                            4 goal .resolution .hypotheses * [ |auto ] tacAttemptNext
                            goal [ |auto |tacSolveArith ] tacAttemptNext
                          } rep
                        }
                        { 1 parse * logicNonTerminal /cdc eq
                            { 0 1 parse * * logicNonTerminal /cc0 eq } andif } {
                          /eqtri goal use
                          goal .isopen not {
                            1 1 parse * * logicRange tokens * /B lastMetaVariables * let
                            /dec0h 4 goal .resolution .hypotheses * use

                            4 goal .resolution .hypotheses * [ |auto ] tacAttemptNext
                            goal [ |auto |tacSolveArith ] tacAttemptNext
                          } rep
                        }
                        { 1 } { "\e[31msolve:arith does not deal with ( [0-9] x. [0-9] )\e[0m\n" out }
                      ] conds
                    }
                    { operation logicNonTerminal /cexp eq } {
                      [
                        { leftNum rightNum exp resultNum neq } { "\e[31mincorrect exponentiation result\e[0m\n" out }
                        { faketrivialities } { goal .fakeclose }
                        { 1 } {
                          rightNum 2 mod 0 eq {
                            rightNum 2 div _ ==leftPart ==rightPart
                          }' {
                            rightNum 1 sub ==leftPart 1 ==rightPart
                          }' ? *
                          /eqtr3i goal use
                          goal .isopen not {
                            [ "("
                              left logicRange tokens * _ len dearray "^"
                                "(" leftPart printNumber _ len dearray
                                    "+"
                                    rightPart printNumber _ len dearray ")"
                            ")" ] /A lastMetaVariables * let
                            /oveq2i 3 goal .resolution .hypotheses * use
                            3 goal .resolution .hypotheses * [ |auto |tacSolveArith ] tacAttemptNext

                            4 goal .resolution .hypotheses * ==step
                            /eqtri step use
                            step .isopen not {
                              [ "("
                                "(" left logicRange tokens * _ len dearray "^" leftPart printNumber _ len dearray ")"
                              "x."
                                "(" left logicRange tokens * _ len dearray "^" rightPart printNumber _ len dearray ")"
                              ")" ] /B lastMetaVariables * let

                              3 step .resolution .hypotheses * ==step2
                              /ax-mp step2 use
                              step2 .isopen not {
                                [ "("
                                  left logicRange tokens * _ len dearray "e." "CC"
                                "/\\"
                                  leftPart printNumber _ len dearray "e." "NN0"
                                "/\\"
                                  rightPart printNumber _ len dearray "e." "NN0"
                                ")" ] /ph lastMetaVariables * let

                                /3pm3.2i 2 step2 .resolution .hypotheses * use
                                2 step2 .resolution .hypotheses * [ |auto ] tacAttemptNext

                                3 step2 .resolution .hypotheses * ==step3
                                /expadd step3 use
                                step3 [ |auto ] tacAttemptNext

                                step2 [ |auto ] tacAttemptNext
                              } rep

                              4 step .resolution .hypotheses * ==step4
                              /eqtri step4 use
                              step4 .isopen not {
                                [ "("
                                  leftNum leftPart exp printNumber _ len dearray
                                "x."
                                  leftNum rightPart exp printNumber _ len dearray
                                ")" ] /B lastMetaVariables * let

                                /oveq12i 3 step4 .resolution .hypotheses * use
                                3 step4 .resolution .hypotheses * [ |auto |tacSolveArith ] tacAttemptNext

                                step4 [ |auto |tacSolveArith ] tacAttemptNext
                              } rep

                              step [ |auto ] tacAttemptNext
                            } rep
                            goal [ |auto ] tacAttemptNext
                          } rep
                        }
                      ] conds
                    }
                    { operation logicNonTerminal /cmo eq } {
                      [
                        { leftNum rightNum mod resultNum neq } { "\e[31mincorrect modulo result\e[0m\n" out }
                        { faketrivialities } { goal .fakeclose }
                        { 1 } {
                          /nnmulmodvali goal use
                          goal .isopen not {
                            leftNum rightNum div printNumber /D lastMetaVariables * let
                            goal [ |auto |tacSolveArith ] tacAttemptNext
                          } rep
                        }
                      ] conds
                    }
                    { 1 } |notApplicable
                  ] conds
                } {
                  [
                    { result logicNonTerminal /cneg eq
                        { 0 result * parseNumber } andif } { ==resultNum
                      /negsubcomi goal use
                      goal [ |auto |tacSolveArith ] tacAttemptNext
                    }
                    { 1 } { notApplicable }
                  ] conds
                } ? *
              } |notApplicable ? *
            } {
              [
                { left logicNonTerminal /co eq
                    { operation logicNonTerminal /caddc eq } andif
                    { 1 left * logicNonTerminal /caddc eq } andif } {
                  0 left * parseNumber { ==leftNum
                    2 left * parseNumber { ==rightNum
                      /eqtri goal use
                      goal .isopen not {
                        [
                          "("
                          leftNum rightNum add printNumber _ len dearray
                          "+"
                          right logicRange tokens * _ len dearray
                          ")"
                        ] /B lastMetaVariables * let
                        /oveq1i 3 goal .resolution .hypotheses * use

                        3 goal .resolution .hypotheses * [ |auto |tacSolveArith ] tacAttemptNext
                        goal [ |auto |tacSolveArith ] tacAttemptNext
                      } rep
                    } |notApplicable ? *
                  } |notApplicable ? *
                }
                { left logicNonTerminal /co eq
                    { operation logicNonTerminal /caddc eq } andif
                    { 1 left * logicNonTerminal /cmul eq } andif } {
                  0 left * parseNumber { ==leftNum
                    2 left * parseNumber { ==rightNum
                      /eqtri goal use
                      goal .isopen not {
                        [
                          "("
                          leftNum rightNum mul printNumber _ len dearray
                          "+"
                          right logicRange tokens * _ len dearray
                          ")"
                        ] /B lastMetaVariables * let
                        /oveq1i 3 goal .resolution .hypotheses * use

                        3 goal .resolution .hypotheses * [ |auto |tacSolveArith ] tacAttemptNext
                        goal [ |auto |tacSolveArith ] tacAttemptNext
                      } rep
                    } |notApplicable ? *
                  } |notApplicable ? *
                }
              ] conds
            } ? *
          } |notApplicable ? *
        } |notApplicable ? *
      } rep
    } /tacSolveArith deffst

    # TODO: replace this by a more general implementation
    { ==goal
      { "\e[31msolve:range not applicable, expected |- ... -> <decimal> { < , <_ } ... (or the other way around)\e[0m\n" out } =*notApplicable

      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff metaLogicParsers * * } andif { ==parse
        parse logicNonTerminal /wi eq {
          [
            { 1 parse * logicNonTerminal /wbr eq } {
              /none ==comparison
              [
                { 1 1 parse * * logicNonTerminal /cle eq } { /cle =comparison }
                # { 1 1 parse * * logicNonTerminal /clt eq } { /clt =comparison }
              ] conds

              /none comparison neq {
                [
                  { 0 1 parse * * parseNumber } { ==target
                    goal antecedents { ==ante
                      0 ante /wff metaLogicParsers * * { ==anteParse
                        anteParse logicNonTerminal /wbr eq
                            { 1 anteParse * logicNonTerminal comparison eq } andif
                            { 2 anteParse * logicRange ante * ==at
                              2 1 parse * * logicRange tokens * ==pt
                              pt at arrEq } andif
                            { 0 anteParse * parseNumber } andif { ==anteNumber
                          anteNumber target gt {
                            /letrd goal use
                            goal .isopen not {
                              0 anteParse * logicRange ante * /B lastMetaVariables * let
                              goal [ |auto ] tacAttemptNext
                            } rep
                          } rep
                        } rep
                      } rep
                    } each
                  }
                  { 2 1 parse * * parseNumber } { ==target
                    goal antecedents { ==ante
                      0 ante /wff metaLogicParsers * * { ==anteParse
                        anteParse logicNonTerminal /wbr eq
                            { 1 anteParse * logicNonTerminal comparison eq } andif
                            { 0 anteParse * logicRange ante * ==at
                              0 1 parse * * logicRange tokens * ==pt
                              pt at arrEq } andif
                            { 2 anteParse * parseNumber } andif { ==anteNumber
                          anteNumber target lt {
                            /letrd goal use
                            goal .isopen not {
                              2 anteParse * logicRange ante * /B lastMetaVariables * let
                              goal [ |auto ] tacAttemptNext
                            } rep
                          } rep
                        } rep
                      } rep
                    } each
                  }
                  { 1 } |notApplicable
                ] conds
              } |notApplicable ? *
            }
            { 1 parse * logicNonTerminal /wa eq } {
              /jca goal use
              goal [ |auto |tacSolveRange ] tacAttemptNext
            }
            { 1 } |notApplicable
          ] conds
        } |notApplicable ? *
      } |notApplicable ? *
    } /tacSolveRange deffst

    { ==goal
      { "\e[31msolve:function not applicable, expected |- [ ph -> ] ( F ` A ) = B or |- [ ph -> ] ( A F B ) = C\e[0m\n" out } =*notApplicable
      goal .thm expandMeta ==tokens
      # [ /dec0h /addid1i /addid2i /mul01i /mul02i /mulid1i /mulid2i /numexp0 /numexp1 ] { ==thm
      #   goal .isopen { thm tokens canUse } andif {
      #     thm goal use
      #     goal [ |auto ] tacAttemptNext
      #   } rep
      # } each

      goal .isopen {
        0 tokens * "|-" eq { 1 tokens /wff metaLogicParsers * * } andif { ==parse
          0 ==hasAntes parse ==relevant
          parse logicNonTerminal /wi eq { 1 =hasAntes 1 parse * =relevant } rep

          relevant logicNonTerminal /wceq eq {
            [
              { 0 relevant * logicNonTerminal /cfv eq } {
                0 0 relevant * * ==function
                1 0 relevant * * ==argument
                hasAntes {
                  /fvmptd goal use
                  goal .isopen not {
                    0 function * logicRange tokens * /x lastMetaVariables * let
                    1 function * logicRange tokens * /D lastMetaVariables * let
                    2 function * logicRange tokens * /B lastMetaVariables * let
                    [ "_V" ] /V lastMetaVariables * let

                    9 goal .resolution .hypotheses * ==equality
                    /adantl equality use
                    equality .isopen not {
                      3 equality .resolution .hypotheses * tacDistrAntecedent
                      equality [ |auto ] tacAttemptNext
                    } rep

                    goal [ |auto ] tacAttemptNext
                  } rep
                } {
                  /ax-mp goal use
                  goal .isopen not {
                    [ "T." ] /ph lastMetaVariables * let
                    3 goal .resolution .hypotheses * tacSolveFunction
                    goal [ |auto ] tacAttemptNext
                  } rep
                } ? *
              }
              { 1 } |notApplicable
            ] conds
          } |notApplicable ? *
        } |notApplicable ? *
      } rep
    } /tacSolveFunction deffst

    { ==goal
      goal .thm expandMeta ==goalToks
      0 goalToks * "|-" eq { 1 goalToks /wff logicParsers * * } andif { ==goalParse
        goalParse logicNonTerminal /wi eq {
          0 goalParse * logicNonTerminal /wcel eq {
            1 0 goalParse * * logicNonTerminal /cun eq {
              /syl goal use
              goal .isopen not {
                0 0 goalParse * * logicRange goalToks * { _ len dearray }_ =*elemToks
                [ "("
                  elemToks "e." 0 1 0 goalParse * * * logicRange goalToks * _ len dearray
                  "\\/"
                  elemToks "e." 1 1 0 goalParse * * * logicRange goalToks * _ len dearray
                ")" ] /ps lastMetaVariables * let
                3 goal .resolution .hypotheses * ==elementwise
                /biimpi elementwise use

                elementwise .isopen not {
                  2 elementwise .resolution .hypotheses * ==equivalence
                  /elun equivalence use
                  equivalence [ |auto ] tacAttemptNext
                } rep
                elementwise [ |auto ] tacAttemptNext

                4 goal .resolution .hypotheses * ==cases
                /jaoi cases use
                cases [ |tacCasesUnion |auto ] tacAttemptNext
              } rep

              goal [ |auto ] tacAttemptNext
            } { "\e[31mcurrent goal is not |- ( ... e. ( ... u. ... ) -> ... ) \e[0m\n" out } ? *
          } { "\e[31mcurrent goal is not |- ( ... e. ... -> ... )\e[0m\n" out } ? *
        } { "\e[31mcurrent goal is not |- ( ... -> ... )\e[0m\n" out } ? *
      } { "\e[31mcurrent goal is not |- ...\e[0m\n" out } ? *
    } /tacCasesUnion deffst

    { ==goal
      goal .thm expandMeta ==goalToks
      0 goalToks * "|-" eq { 1 goalToks /wff logicParsers * * } andif { ==goalParse
        goalParse logicNonTerminal /wi eq {
          0 goalParse * logicNonTerminal /wcel eq {
            1 0 goalParse * * logicNonTerminal /csn eq {
              /syl goal use
              goal .isopen not {
                0 0 goalParse * * logicRange goalToks * { _ len dearray }_ =*elemToks
                [
                  elemToks "=" 0 1 0 goalParse * * * logicRange goalToks * _ len dearray
                ] /ps lastMetaVariables * let

                3 goal .resolution .hypotheses * ==equivalence
                /elsni equivalence use
                equivalence [ |auto ] tacAttemptNext
              } rep

              goal [ |auto ] tacAttemptNext
            } { "\e[31mcurrent goal is not |- ( ... e. { ... } -> ... ) \e[0m\n" out } ? *
          } { "\e[31mcurrent goal is not |- ( ... e. ... -> ... )\e[0m\n" out } ? *
        } { "\e[31mcurrent goal is not |- ( ... -> ... )\e[0m\n" out } ? *
      } { "\e[31mcurrent goal is not |- ...\e[0m\n" out } ? *
    } /tacCasesExplicit deffst

    { ==goal
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff metaLogicParsers * * } andif { ==parse
          parse tokens
          "|- ( ph -> A. x ph )" " " str .split
        /wff 1 possibleSubstitutionsForParse ==substs
        substs len 0 gt {
          0 parse * logicNonTerminal ==nt
          [
            { nt /wi eq } { /hbim goal use }
            { nt /wb eq } { /hbbi goal use }
            { nt /wa eq } { /hban goal use }
            { nt /w3a eq } { /hb3an goal use }
            { nt /wo eq } { /hbor goal use }
            { nt /w3o eq } { /hb3or goal use }
            { nt /wbr eq } { /hbbr goal use }
            { nt /wal eq } {
              1 /ph 0 substs * * * 0 /x 0 substs * * * eq {
                /hba1 goal use
              } {
                /hbal goal use
              } ? *
            }
            { nt /wral eq } {
              1 /ph 0 substs * * * 0 /x 0 substs * * * eq {
                /hbra1 goal use
              } {
                /hbral goal use
              } ? *
            }
            { nt /wex eq } {
              1 /ph 0 substs * * * 0 /x 0 substs * * * eq {
                /hbe1 goal use
              } {
                /hbex goal use
              } ? *
            }
            { nt /wrex eq } {
              1 /ph 0 substs * * * 0 /x 0 substs * * * eq {
                /hbre1 goal use
              } {
                /hbrex goal use
              } ? *
            }
            { nt /wsbc eq } {
              0 1 0 parse * * logicRange * tokens * 0 /x 0 substs * * * eq {
                /hbsbc1f goal use
                [ "a\"" ] /y lastMetaVariables * let
              } {
                /hbsbc goal use
                goal .isopen not {
                  [ "a\"" ] /z lastMetaVariables * let
                } rep
              } ? *
            }
            { 1 } { [| "\e[31mNo rewrite rule known for connective: " nt "\e[0m\n" |] out }
          ] conds

          goal [ |auto |tacNonfree ] tacAttemptNext
        } { "\e[31mNot in fact a trivial non-free variable proof.\e[0m\n" out } ? *
      } { "\e[31mCurrent goal did not parse as wff.\e[0m\n" out } ? *
    } /tacNonfree deffst

    # TODO: Make it respect nondisj directives and create substitutions over variables where neccessary
    { ==goal ==elementToks
      0 elementToks /class metaLogicParsers * * { --
        goal .thm expandMeta ==tokens
        0 tokens * "|-" eq { 1 tokens /wff metaLogicParsers * * } andif { ==parse
          parse logicNonTerminal /wi eq {
            [
              { 1 parse * logicNonTerminal /wrex eq } {
                /syl goal use
                goal .isopen not {
                  [ "("
                    elementToks _ len dearray "e." 1 1 parse * * logicRange tokens * _ len dearray
                    "/\\"
                    0 1 parse * * logicRange tokens * ==from
                    2 1 parse * * logicRange tokens * from elementToks rewriteTokens _ len dearray
                    ")"
                  ] /ps lastMetaVariables * let
                  goal [ |auto ] tacAttemptNext
                  4 goal .resolution .hypotheses * ==existence
                  existence .isopen {
                    /rcla4e existence use
                    existence [ |auto ] tacAttemptNext
                  } rep
                } rep
              }
              { 1 parse * logicNonTerminal /wex eq } {
                /sylc goal use
                goal .isopen not {
                  [ elementToks _ len dearray "e." "_V" ] /ps lastMetaVariables * let
                    0 1 parse * * logicRange tokens * ==from
                    1 1 parse * * logicRange tokens * from elementToks rewriteTokens
                  /ch lastMetaVariables * let
                  goal [ |auto ] tacAttemptNext
                  6 goal .resolution .hypotheses * ==existence
                  existence .isopen {
                    /cla4egf existence use
                    existence [ |auto ] tacAttemptNext
                  } rep
                } rep
              }
              { 1 } { "\e[31mNot an existential goal\e[0m" |] out }
            ] conds
          } {
            [| "\e[31mTODO: tacNamely does not support |- ( ph -> ps ) goals yet\e[0m" |] out
          } ? *
        } { [| "\e[31mGoal is not |- ph\e[0m" |] out } ? *
      } { [| "\e[31mGiven element does not parse as class\e[0m" |] out } ? *
    } /tacNamely deffst

    { ==goal
      [| goal .thm expandMeta { " " } each |] ==txt

      0 ==removed

      mainGoal openGoals { ==otherGoal
        otherGoal sys .asm .rawAddress goal sys .asm .rawAddress neq {
          [| otherGoal .thm expandMeta { " " } each |] txt eq {
            goal .parents { ==parent
              parent .resolution .hypotheses _ ==hyps dom { ==i
                i hyps * sys .asm .rawAddress goal sys .asm .rawAddress eq {
                  otherGoal i hyps =[]
                } rep
              } each
            } each

            1 =removed
          } rep
        } rep
      } each

      removed {
        allOpenGoals { sys .asm .rawAddress goal sys .asm .rawAddress neq } grep =allOpenGoals
      } rep
    } /tacDeduplicate deffst

    # from conclusion to array of earlier solutions to it
    map ==recordedSolutions

    { ==goal
      goal .thm expandMeta ==tokens
      0 tokens * "|-" eq { 1 tokens /wff metaLogicParsers * * } andif { ==parse
        parse logicNonTerminal /wi eq { 1 parse * } { parse } ? * ==conclusionParse
        [| conclusionParse logicRange tokens * { " " } each |] ==conclusion
        conclusion recordedSolutions .has not { [ ] conclusion recordedSolutions =[] } rep

        map ==anteSet
        goal antecedents { [| -01 { " " } each |] _ anteSet =[] } each

        0 ==betterSolutionKnown
        conclusion recordedSolutions * _ ==solutions dom { ==i
          [ i solutions * antecedents {
            [| -01 { " " } each |] anteSet .has
          } each ] all {
            1 =betterSolutionKnown
          } rep
        } each

        betterSolutionKnown not {
            conclusion recordedSolutions * [ goal ] cat
          conclusion recordedSolutions =[]
        } rep
      } { [| "\e[31mGoal is not |- ph\e[0m\n" |] out } ? *
    } /recordSolution deffst

    # Models all known truths as an accepting FSM. Theorem variables become
    # self-loops, theorem tokens become transitions.
    { < map ==transitions objset ==theorems > } /tokenNode deffst

    { tokenNode _ ==theoremTokenIndex # returned
      [| "Indexing theorems by tokens...\n" |] out

      { ==name ==tokens
        objset ==i theoremTokenIndex i .put

        tokens { ==tok
          tok constants .has {
            objset ==newI
            i { ==n
              tok n .transitions .has not { tokenNode tok n .transitions =[] } rep
              tok n .transitions * newI .put
            } each
            newI =i
          } rep
        } each

        i { ==n
          name n .theorems .put
        } each
      } /index deffst

      assertions dom { ==name name assertions * .thm name index } each
      [ |collectEHyps |collectFHyps ] { =*collect
        proofContext collect ==hyps hyps dom { ==name
          name hyps * name index
        } each
      } each
    } memoized /theoremTokenIndex deffst

    { ==tokens
      objset ==i
      theoremTokenIndex i .put
      tokens { ==tok
        i { ==n
          tok n .transitions .has {
            tok n .transitions * i .put
          } rep
        } each
      } each

      [| "Possible theorems:\n" |] out
      i { .theorems 0 ==some { ==thm
        # thm tokens canUse { thm " " cat out 1 =some } rep
        thm " " cat out 1 =some
      } each some { "\n" out } rep } each
    } /search deffst

    { .thm expandMeta search } /suggest deffst

    { ==includeTypes
      0 ==i
      { ==indent ==goal
        includeTypes 0 goal .thm expandMeta * "|-" eq or {
          [|
            i txt .produce .u _ out ")" out len
            indent -01 sub { " " } rep
            goal .isopen { "\e[31m???\e[0m " } { goal .resolution .theorem .name " " } ? *
            goal .thm expandMeta { renderName " " } each "\n"
          |] out
        } rep
        i 1 add =i
        goal .isopen not { goal .resolution .hypotheses { indent 2 add recurse } each } rep
      } /recurse deffst
      mainGoal 4 recurse
    } /tree deffst

    {
      { ==goal
        goal .isopen not { goal .resolution .hypotheses |recurse each } rep
        [| goal .isopen { "? " } { goal .resolution .theorem .name " " } ? * |] out
      } /recurse deffst
      mainGoal recurse
      "$.\n" out
    } /export deffst

    {
      map ==nameCount
      map ==nameMap
      map ==explicitNameMap
      map ==theoremCount
      map ==theoremMap
      1 ==i

      proposition .hyps { ==name
        i name nameMap =[]
        i 1 add =i
      } each

      stack ==nameStack
      mainGoal nameStack .push

      { nameStack .has } {
        nameStack .pop ==goal

        goal .isopen not {
          goal .resolution .theorem .name ==name
          name nameCount .has { name nameCount * 1 add } { 1 } ? * name nameCount =[]

          goal .resolution .hypotheses { nameStack .push } each
        } rep
      } loop

      nameCount dom { ==a ==b
        a nameCount * b nameCount * lt
      } order nameCount dom * { ==name
        name nameMap .has not {
          i name explicitNameMap =[]
          i name nameMap =[] i 1 add =i
        } rep
      } each

      map ==encodedOnce
      stack ==encodeCountStack
      mainGoal encodeCountStack .push
      { encodeCountStack .has } {
        encodeCountStack .pop ==goal

        goal .isopen not {
          [| goal .thm expandMeta { " " } each |] ==txt

          txt encodedOnce .has not {
            goal .resolution .hypotheses { encodeCountStack .push } each
          } rep

          goal .resolution .hypotheses len 0 gt {
            1 txt encodedOnce =[]
            txt theoremCount .has { txt theoremCount * 1 add } { 1 } ? * txt theoremCount =[]
          } rep
        } rep
      } loop

      9999 ==column
      { ==tok
        column tok len add 78 gt {
          "\n      " out 6 =column
          tok "^ *$" regex { "" =tok } rep
        } rep
        tok out
        column tok len add =column
      } /wrapOut deffst

      [ "( " explicitNameMap dom { " " } each ") " ] |wrapOut each

      { 1 sub ==i
        [ [
          i 20 mod "ABCDEFGHIJKLMNOPQRST" * i 20 div =i
          { i } {
            i 1 sub =i
            i 5 mod "UVWXY" * i 5 div =i
          } loop
        ] reverse { [ -01 ] str .fromArray } each ]
      } /encodeNumber deffst

      {
        "Z" wrapOut
      } /encodeTag deffst

      {
        "?" wrapOut
      } /encodeOpen deffst

      stack ==exportStack

      mainGoal exportStack .push

      { exportStack .has } {
        exportStack .pop ==goal
        goal .?'delayed {
          goal .delayed
        } {
          goal .isopen { encodeOpen } {
            [| goal .thm expandMeta { " " } each |] ==txt

            txt theoremMap .has {
              txt theoremMap * encodeNumber |wrapOut each
            } {
              < {
                goal .resolution .theorem .name nameMap * encodeNumber |wrapOut each

                txt theoremCount .has { txt theoremCount * 1 gt } andif {
                  encodeTag
                  1 txt theoremCount =[]
                  i txt theoremMap =[]
                  i 1 add =i
                } rep
              } =*delayed > exportStack .push

              goal .resolution .hypotheses reverse { exportStack .push } each
            } ? *
          } ? *
        } ? *
      } loop

      " $." wrapOut
      "\n" out
    } /exportCompressed deffst

    {
      map ==allVars
      disj dom { tokenIsMetaVar not } grep { ==x
        1 x allVars =[]
        x disj * dom { tokenIsMetaVar not } grep { ==y
          1 y allVars =[]
        } each
      } each

      9999 ==column
      { ==tok
        column tok len add 78 gt {
          "\n    " out 4 =column
          tok "^ *$" regex { "" =tok } rep
        } rep
        tok out
        column tok len add =column
      } /wrapOut deffst

      { ==X ==P ==R
        P len 0 eq { X len 0 eq } andif {
          R len 1 gt {
            [| "$d " R { " " } each "$." |] wrapOut "  " wrapOut
          } rep
        } {
          0 P X cat * ==u # any can be chosen

          P { u mustDisj not } grep { ==v
            R [ v ] cat P { v mustDisj } grep X { v mustDisj } grep findMaximalCliques
            P { v eq not } grep =P
            X [ v ] cat =X
          } each
        } ? *
      } /findMaximalCliques deffst

      [ ] allVars dom [ ] findMaximalCliques

      "\n" out
    } /exportDisjuncts deffst

    {
      [| "=== snip here for " proposition .name " ===\n" |] out
      [| "${" |] out
      exportDisjuncts
      proofContext collectEHyps _ ==hyps dom { ==name
        [| "  " name " $e " name hyps * { " " } each -- " $.\n" |] out
      } each
      [| "\n" |] out
      [| "  " proposition .name " $p " proposition .thm { " " } each -- " $=" |] out
      exportCompressed
      [| "$}\n" |] out
      [| "=== /snip here for " proposition .name " ===\n" |] out
    } /exportTheorem deffst

    { ==toReopen
      0 ==i
      { ==goal
        i _ 1 add =i toReopen eq { goal .open } rep
        goal .isopen not { goal .resolution .hypotheses |recurse each } rep
      } /recurse deffst
      mainGoal recurse

      [ ] =allOpenGoals 0 =allOpenGoalsValid
      rebuildClosedGoalIndex
    } /reopen deffst

    { objset _ ==children .put
      { ==goal
        goal .isopen not {
          goal .resolution .hypotheses { ==hyp
            hyp children .has { goal .open } { hyp recurse } ? *
          } each
        } rep
      } /recurse deffst
      mainGoal recurse

      [ ] =allOpenGoals 0 =allOpenGoalsValid
      rebuildClosedGoalIndex
    } /reopenParentOf deffst

    1 ==running
    0 ==autoall
    0 ==antedisp
    0 ==faketrivialities

    { include }' /load deffst

    { running } { [
      proofContext _ =userContext =renderContext
      mainGoal openGoals ==goals

      autoall { lastMetaVariables map =lastMetaVariables goals |auto each =lastMetaVariables mainGoal openGoals =goals } rep

      { selectedGoal goals len ge selectedGoal 0 gt and } { selectedGoal 1 sub =selectedGoal } loop

      {
        silent not {
          " " ==sep
          [| nonDisj dom sort { ==x
            x nonDisj * dom sort { ==y
              sep ", " =sep x renderName " <=> " y renderName
            } each
          } each "\n" |] out
          [| disj dom sort { ==x
            x disj * dom sort { ==y
              sep ", " =sep x renderName " <!> " y renderName
            } each
          } each "\n" |] out
        } rep

        silent 1 le {
          goals dom { ==i
            i selectedGoal eq "\e[1m" "" ? ==hl
            [| hl i txt .produce .u ") " i goals * .thm expandMeta { hl -01 renderName " " } each "\e[0m\n" |] out
          } each

          loadedDisplays "*" | each

          {
            goals dom len 1 gt {
              [| "\n" |] out
              selectedGoal ==i
              i selectedGoal eq "\e[1m" "" ? ==hl
              [| hl i txt .produce .u ") " i goals * .thm expandMeta { hl -01 renderName " " } each "\e[0m\n" |] out
            } rep
          } /displayCurrentGoal deffst

          antedisp { goals len } andif {
            selectedGoal goals * ==goal
            goal .thm expandMeta ==tokens
            0 tokens * "|-" eq { 1 tokens /wff metaLogicParsers * * } andif { ==parse
              [| "\n" |] out
              proofContext collectEHyps _ ==hyps dom { ==name
                [| "+ " name hyps * _ len 1 -01 range -01* { renderName " " } each "\n" |] out
              } each
              goal antecedents ==antes
              [| "\n" |] out
              antes { ==toks
                [| "* " toks { renderName " " } each "\n" |] out
              } each
              [|
                "\e[1m-------------------------------------------------"
                goal .autohint "" neq { " \e[32m(hint: " goal .autohint ")" } rep
                "\e[0m\n"
              |] out
              [| "  "
                 parse logicNonTerminal /wi eq { 1 parse * } { parse } ? * logicRange tokens *
                   { renderName " " } each
             "\n" |] out
            } |displayCurrentGoal ? *
          } |displayCurrentGoal ? *
        } {
          "." out
        } ? *
      } τdisplay /display deffst
      redisplay |display rep
      1 =redisplay

      perfstats
      silent 1 le {
        "proof> " sys .out .writeall
      } rep
      inputCmd ==cmd ==args

      { "\e[32mWe are done here.\e[0m\n" out } =*solved
      [
        { cmd "quit" eq } { 0 =running }
        { cmd "what" eq } { display 0 =redisplay }
        { cmd "show" eq } { args show 0 =redisplay }
        { cmd "todo" eq } {
          selectedGoal goals len 1 sub lt { selectedGoal 1 add =selectedGoal } rep
        }
        { cmd "next" eq } {
          selectedGoal goals len 1 sub lt { selectedGoal 1 add =selectedGoal } rep
        }
        { cmd "prev" eq } {
          selectedGoal 0 gt { selectedGoal 1 sub =selectedGoal } rep
        }
        { cmd "use" eq } { args selectedGoal goals * tacUse }
        { cmd "let" eq { args "^(\\$[^=]+) = (.*)" regex } andif } { ==metaVar " " str .split { "" neq } grep ==tokens
          tokens metaVar let
        }
        { cmd "unlet" eq { args "^(\\$[^=]+)$" regex } andif } { ==v [ v ] v metaSubstitution =[] }
        { cmd "lets" eq } {
          metaSubstitution dom { ==v
            [| v " = " v metaSubstitution * { renderName " " } each "\n" |] out
          } each
          0 =redisplay
        }
        { cmd "nondisj" eq { args "^(.*) <=> (.*)" regex } andif } { markNonDisj }
        { cmd "/" eq } { args ==search 0 ==success
          goals dom { ==i
            1 neg [ [| i goals * .thm expandMeta { " " } each |] search regex ] * { success not } andif {
              i =selectedGoal 1 =success
            } rep
          } each
          success not { "\e[31mno such goal found\e[0m\n" out } rep
        }
        { cmd "" eq cmd "auto" eq or } { goals len { selectedGoal goals * auto } |solved ? * }
        { cmd "distr:ante" eq } { goals len { selectedGoal goals * tacDistrAntecedentMeta } |solved ? * }
        { cmd "rewrite:ante" eq } { goals len { selectedGoal goals * tacRewriteAntecedent } |solved ? * }
        { cmd "and" eq { args "rewrite" eq } andif } { goals len { selectedGoal goals * tacContinueWithRewrite } |solved ? * }
        { cmd "rewrite:full" eq } { args " " str .split { "" neq } grep ==tokens
          goals len { tokens selectedGoal goals * tacRewriteFull } |solved ? * }
        { cmd "rewrite" eq } { args " " str .split { "" neq } grep ==tokens
          goals len { tokens selectedGoal goals * tacRewrite } |solved ? * }
        { cmd "replace" eq } { args " " str .split { "" neq } grep ==tokens
          goals len { tokens selectedGoal goals * tacReplace } |solved ? * }
        { cmd "substitutions" eq } { goals tacSubstitutions }
        { cmd "under" eq } { args " " str .split { "" neq } grep ==tokens
          goals len { tokens selectedGoal goals * tacUnder } |solved ? * }
        { cmd "with" eq { args "^only (.*)" regex } andif } {  " " str .split { "" neq } grep ==tokens
          goals len { tokens selectedGoal goals * tacWithOnly } |solved ? * }
        { cmd "with" eq } { args " " str .split { "" neq } grep ==tokens
          goals len { tokens selectedGoal goals * tacWith } |solved ? * }
        { cmd "conclude" eq } { args " " str .split { "" neq } grep ==tokens
          goals len { tokens selectedGoal goals * tacConclude } |solved ? * }
        { cmd "and" eq { args "^conclude (.*)" regex } andif } { " " str .split { "" neq } grep ==tokens
          goals len { tokens selectedGoal goals * tacAndConclude } |solved ? * }
        { cmd "drop" eq { args "^everything matching (.*)" regex } andif } { " " str .split { "" neq } grep ==tokens
          goals len { tokens selectedGoal goals * tacDropMatching } |solved ? * }
        { cmd "drop" eq } { args " " str .split { "" neq } grep ==tokens
          goals len { tokens selectedGoal goals * tacDrop } |solved ? * }
        { cmd "normalize" eq } {
          goals len { selectedGoal goals * tacNormalize } |solved ? * }
        { cmd "normalize:logic" eq } {
          goals len { selectedGoal goals * tacNormalizeLogic } |solved ? * }
        { cmd "normalize:arith" eq } {
          goals len { selectedGoal goals * tacNormalizeArith } |solved ? * }
        { cmd "normalize:ante" eq } {
          goals len { selectedGoal goals * tacNormalizeAntecedentOnly } |solved ? * }
        { cmd "rename" eq { args "^([^ ]+) to ([^ ]+)$" regex } andif } {
          goals len { selectedGoal goals * tacRename } |solved ? * }
        { cmd "expand" eq } { args ==name
          goals len { name selectedGoal goals * tacExpand } |solved ? * }
        { cmd "solve:arith" eq } {
          goals len { selectedGoal goals * tacSolveArith } |solved ? * }
        { cmd "solve:range" eq } {
          goals len { selectedGoal goals * tacSolveRange } |solved ? * }
        { cmd "solve:function" eq } {
          goals len { selectedGoal goals * tacSolveFunction } |solved ? * }
        { cmd "cases:union" eq } {
          goals len { selectedGoal goals * tacCasesUnion } |solved ? * }
        { cmd "cases:explicit" eq } {
          goals len { selectedGoal goals * tacCasesExplicit } |solved ? * }
        { cmd "namely" eq } { args " " str .split { "" neq } grep ==tokens
          goals len { tokens selectedGoal goals * tacNamely } |solved ? * }
        { cmd "nonfree" eq } {
          goals len { selectedGoal goals * tacNonfree } |solved ? * }
        { cmd "deduplicate" eq } {
          goals len { selectedGoal goals * tacDeduplicate } |solved ? * }
        { cmd "take" eq { args "note" eq } andif } {
          goals len { selectedGoal goals * recordSolution } |solved ? * }
        { cmd "tree" eq } { 0 tree }
        { cmd "tree:full" eq } { 1 tree }
        { cmd "export" eq } { export }
        { cmd "export:compressed" eq } { exportCompressed }
        { cmd "export:disj" eq } { exportDisjuncts }
        { cmd "export:theorem" eq } { exportTheorem }
        { cmd "reopen" eq { args "^(\\d+)$" regex } andif } { txt .consume .u reopen }
        { cmd "reopen" eq } {
          goals len { selectedGoal goals * reopenParentOf } |solved ? * }
        { cmd "sug" eq } {
          goals len { selectedGoal goals * suggest } |solved ? * }
        { cmd "search" eq args "" neq and } { args " " str .split _ =lastSearch search }
        { cmd "search" eq } { lastSearch search }
        { cmd "parse" eq } {
          goals len {
            0 selectedGoal goals * .thm * ==head

            [
              { head "|-" eq }           { [ 1 selectedGoal goals * .thm expandMeta /wff logicParsers * * ] dump }
              { head logicParsers .has } { [ 1 selectedGoal goals * .thm expandMeta head logicParsers * * ] dump }
              { 1 } { [| "\e[31mno parser available\e[0m\n" |] out }
            ] conds
          } |solved ? *
        }
        { cmd "autoall" eq } { 1 =autoall }
        { cmd "noautoall" eq } { 0 =autoall }
        { cmd "faketrivialities" eq } { 1 =faketrivialities }
        { cmd "nofaketrivialities" eq } { 0 =faketrivialities }
        { cmd "antedisp" eq } { 1 =antedisp }
        { cmd "noantedisp" eq } { 0 =antedisp }
        { cmd "silent" eq } { 2 =silent }
        { cmd "quiet" eq } { 1 =silent }
        { cmd "nosilent" eq } { 0 =silent }
        { cmd "load" eq } { args load }
        { cmd "freeze" eq } { { _ { * }_ args sys .freeze * } !! * }
        { [ cmd { _ 48 ge -01 57 le and } each ] all } {
          txt .consume .u _ goals len ge { -- goals len 1 sub } rep =selectedGoal
        }
        loadedCommands "*" | each
      ] conds
    ] _ ==residue len 0 gt {
      [| "\e[31mSomething left on the stack:\e[0m\n" |] out
      residue dump
    } } loop
  } /proveProposition deffd

  { ==name
    name assertions .has { name assertions * .type "p" eq } { 0 } ? * {
      name assertions * proveProposition
    } {
      [| name " is not a provable proposition\n" |] out
      name show
    } ? *
  } /prove deffd

  { ==proposition
    # DEBUGGING ONLY
    <
      0 ==debugIndent

      {
        _ /usedAntecedent eq { ==name =*f
          { ==goal
            [
              goal f ==result
            ] len 0 neq {
              [| "Stack polluted by " goal .resolution |] err
            } rep
            map ==antes goal .antes { 1 -01 antes =[] } each
            result splitConjunction { antes .has not } grep _ ==error len 0 neq {
              [| "--- goal requested invalid ante ---" |] err
              goal .resolution dump
              [| "proving:\n" |] out
              [| 0 goal .thm renderNicely "\n" |] out
              [| "from:\n" |] out
              goal .antes { ==ante
                [| 0 ante renderNicely "\n" |] out
              } each
              [| "... but actual request was also for ...\n" |] out
              error { ==ante
                [| 0 ante renderNicely "\n" |] out
              } each
              /aborting die
            } rep

            result
          } name
        } rep

        _ /construct eq { ==name =*f
          { ==goal =*pushStep
            [| debugIndent { " " } rep goal .resolution "\n" |] out
            { 2 add } |=debugIndent
            [ /sentinel
              |pushStep goal f
            ] len 1 neq {
              [| "Stack polluted by " goal .resolution |] err
            } rep
            { 2 sub } |=debugIndent
            [| debugIndent { " " } rep "/" goal .resolution "\n" |] out
          } name
        } rep
      }
    > -- |deffst ; =*?deffst
    # END OF DEBUGGING

    # OPTIMIZATION ONLY
    {
      _ /usedAntecedent eq { ==name =*f
        { ==goal
          goal .?usedAntecedent_ {
            goal .usedAntecedent_
          } {
            goal f _ /usedAntecedent_ goal .setExtra
          } ? *
        } name
      } rep
    } |deffst ; =*?deffst
    # END OF OPTIMIZATION

    <
      { ==goal
        ""
      } /usedAntecedent deffst
      { ==goal =*pushStep
        [ "?" map ] pushStep
      } /construct deffst
    > ==unresolved

    <
      { .resolution "" eq } /isopen defmst

      { ==goal ==ante
        goal .antes [ ante ] cat /antes goal .set
      } /addAnte defmst

      { ==goal /thm goal .set } /setThm defmst

      {
        ==thm   # [ "$ch.5" ] theorem to show, no |-
        ==antes # [ "$ph -> $ch.5" ... ] things we know, no |-
        "" ==resolution   # gonna be a $p or $a name (or any other indicator on it was solved)
        [ ] ==children
        unresolved ==strategy  # the proof construction strategy
        { = }' =*set
        { ==? }' =*setExtra
        scope
      }
    > -- /newGoal deffst

    [ ] ==allOpenGoals 0 ==allOpenGoalsValid
    { # ==goal
      objset ==goals
      {
        _ .resolution len not { goals .put } { .children |collect each } ? *
      } /collect deffst
      collect goals dom
    } /openGoalsRecursive deffst

    { ==goal
      goal sys .asm .rawAddress mainGoal sys .asm .rawAddress eq {
        allOpenGoalsValid not {
          mainGoal openGoalsRecursive _ =allOpenGoals 1 =allOpenGoalsValid
        } {
          [ allOpenGoals { openGoalsRecursive _ len dearray } each ] _ =allOpenGoals 1 =allOpenGoalsValid
        } ? *
      } {
        goal openGoalsRecursive
      } ? *
    } τopenGoals /openGoals deffst

    0 ==nextMetaVariable
    map ==metaSubstitution
    map ==allMetaVariables
    map ==lastMetaVariables

    { _ metaSubstitution .has {
      metaSubstitution * |expandMetaToken each
    }" rep }' /expandMetaToken deffst
    <
      "" ==s
      { [ -01 { _ =s 0 s * 36 eq { expandMetaToken }" rep }" each ] }'
    > -- τexpandMeta /expandMeta deffst

    {
      [ -01 { ==tok
        0 tok * 36 eq { 1 tok str .postfix lastMetaVariables .has } andif {
          1 tok str .postfix lastMetaVariables *
        } { tok } ? *
      } each ]
    } /useLastMetas deffst

    map ==lastGrammarMatch
    map ==grammarMatchCache
    { ==pattern
      pattern grammarMatchCache .has not {
        pattern " " str .split ==patternTokens
          [
            { 0 patternTokens   /wff metaLogicParsers * * } { [ -01 patternTokens /wff ] }
            { 0 patternTokens /class metaLogicParsers * * } { [ -01 patternTokens /class ] }
            { 1 } { [| "Could not parse '" pattern "' as wff or class" |] die }
          ] conds
        pattern grammarMatchCache =[]
      } rep

      pattern grammarMatchCache *
    } /cachedPatternParse deffst

    { cachedPatternParse ==pattern ==subject
      subject " " str .split ==tokens
      0 tokens 2 pattern * metaLogicParsers * * { ==tokensParse
        tokensParse tokens pattern 2 dearray possibleSubstitutionsForParses ==substs
        substs len 1 eq {
          0 substs * =lastGrammarMatch 1
        } { 0 } ? *
      } { 0 } ? *
    } "//" deffst

    { cachedPatternParse ==pattern ==subject
      subject " " str .split ==tokens
      [ ] ==result

      { ==parse
        parse tokens pattern 2 dearray possibleSubstitutionsForParses ==substs
        substs len {
          result [ 0 substs * ] cat =result
        } {
          0 parse logicChildCount range { ==i
            i parse * search
          } each
        } ? *
      } /search deffst

      0 tokens /wff metaLogicParsers * * |search rep

      result
    } /allMatchingSubparses deffst

    { # ==map ==key ==value
      -102 " " str .split -021 =[]
    } "$=[]" deffd

    # <$ "x e. A" ==ph "y e. B" ==ps $> as inline-map constructor for pushStep
    { < map ==m { m $=[] } "==" =* }" "<$" deffst
    { m > -- }" "$>" deffst

    { lastGrammarMatch * [| -01 { " " } each -- |] } "$" deffst
    { lastGrammarMatch $=[] } "$=" deffst
    { lastGrammarMatch } "$$" deffst

    { lastGrammarMatch .clone < ==lastGrammarMatch
      { lastGrammarMatch * [| -01 { " " } each -- |] } "$"
      { lastGrammarMatch $=[] } "$="
      { lastGrammarMatch } "$$"
    > -- } { 3 |deffst rep }" ; "$_" deffst

    { " " str .split =*toks 0 ==i 1 ==digits 0 ==result
      { i toks ";" eq } { digits 1 add =digits i 1 add =i } loop
      1 ==success

      digits {
        i |toks len lt {
          i toks [ /0 /1 /2 /3 /4 /5 /6 /7 /8 /9 ] eq any {
            result 10 mul i toks txt .consume .u add =result
          } {
            0 =success
          } ? *
        } {
          0 =success
        } ? *
        i 1 add =i
      } rep

      i |toks len neq { 0 =success } rep

      success { result 1 } { 0 } ? *
    } /parseNumber deffst

    {
      { ==ante
        [
          { ante "" eq } { }
          { ante "( ph /\\ ps )" // } {
            $_
            $ph split
            $ps split
          }
          { ante "( ph /\\ ps /\\ ch )" // } {
            $_
            $ph split
            $ps split
            $ch split
          }
          { 1 } { ante }
        ] conds
      } /split deffst
      [ -01 split ]
    } /splitConjunction deffst

    { ==antes
      [
        { antes len 0 eq } {
          ""
        }
        { antes len 1 eq } {
          0 antes *
        }
        { 1 } {
          antes len 2 div ==split
          [| "( "
            0 split range antes * makeConjunction
            " /\\ "
            split antes len range antes * makeConjunction
          " )" |]

          # Linear construction:
          # antes _ len _ ==l dearray
          # l 1 sub { [| "( " " /\\ " " )" -325140 |] } rep
        }
      ] conds
    } /makeConjunction deffst

    { ==to ==from =*pushStep
      {
        [| "Could not transform conjuction." |] err
        /from: dump [| 0 from renderNicely "\n" |] out
        /to: dump [| 0 to renderNicely "\n" |] out
        [ "?" map ] pushStep
      } ==failed

      from len { [| from " " str .split expandMeta { " " } each -- |] } { "" } ? * ==from
      to len { [| to " " str .split expandMeta { " " } each -- |] } { "" } ? * ==to

      [
        { to "" eq from "" eq or } failed
        { to from eq } {
          $_ to $=ph
          [ /id$HERE1 $$ ] pushStep
        }
        { from "( ph /\\ ps )" // } { $_
          map ==onLeft map ==onRight
          $ph _ ==left splitConjunction { 1 -01 onLeft =[] } each
          $ps _ ==right splitConjunction { 1 -01 onRight =[] } each

          0 ==missingLeft 0 ==missingRight
          to splitConjunction {
            _ onLeft .has not { 1 =missingLeft } rep
              onRight .has not { 1 =missingRight } rep
          } each

          [
            { missingLeft not } {
              $_ left $=ph right $=ch to $=ps
              [ /adantr $$ ] pushStep
              |pushStep left to transformConjunct
            }
            { missingRight not } {
              $_ right $=ph left $=ch to $=ps
              [ /adantl$HERE1 $$ ] pushStep
              |pushStep right to transformConjunct
            }
            { 1 } {
              to "( ps /\\ ch )" // {
                $_ from $=ph
                [ /jca$HERE1 $$ ] pushStep

                $ps ==toLeft
                $ch ==toRight

                |pushStep from toLeft transformConjunct
                |pushStep from toRight transformConjunct
              } failed ? *
            }
          ] conds
        }
        { 1 } failed
      ] conds
    } /transformConjunct deffst

    { ==to ==from
      map ==available
      to splitConjunction { 1 -01 available =[] } each
      from splitConjunction { available .has not } grep
    } /missingConjuncts deffst

    # Which disjunctions must be in place to ensure term is (semantically) independent of var.
    { ==term ==var
      [
        { term "( ph /\\ ps )" // } { $_
          var $ph requiredDisjuncts
          var $ps requiredDisjuncts cat
        }
        { term "( ph -> ps )" // } { $_
          var $ph requiredDisjuncts
          var $ps requiredDisjuncts cat
        }
        { term "A. x ph" // } { $_
          $x var eq {
            [ ]
          } {
            var $ph requiredDisjuncts
          } ? *
        }
        { term "A. x e. A ph" // } { $_
          $x var eq {
            var $A requiredDisjuncts
          } {
            var $ph requiredDisjuncts
            var $A requiredDisjuncts cat
          } ? *
        }
        { 1 } {
          term " " str .split { variables .has } grep
        }
      ] conds
    } /requiredDisjuncts deffst

      [ /a" /b" /c" /d" /e" /f" /g" /h" /i" /j" /k" /l" /m" /n" /p" /q" /r" /t" /u" /w" /x" /y" /z" ]
    ==:uncommonSetVariables
    { ==count ==term
      [
        map ==used
        term " " str .split { 1 -01 used =[] } each
        uncommonSetVariables { used .has not } grep _ len count lt {
            [| "Not enough unused variable names available." |] err
            -- [ count { /x } rep ]
          } rep
        count dearray
      ] _ { ==v
            term " " str .split { variables .has } grep { ==w
              v w markDisj
            } each
          } each
          count dearray
    } /freshVariables deffst

    { ==thm =*pushStep
      [
        { thm "( ph -> A. x ph )" // {
          $ph $x mayDisjunct
        } andif } {
          $ph $x checkMarkedDisjunct
          [ /ax-17 $$ ] pushStep
        }
        { thm "( ( ph /\\ ps ) -> A. x ( ph /\\ ps ) )" // } { $_
          [ /hban $$ ] pushStep
          |pushStep [| "( " $ph " -> A. " $x " " $ph " )" |] constructUnused
          |pushStep [| "( " $ps " -> A. " $x " " $ps " )" |] constructUnused
        }
        { thm "( ( ph -> ps ) -> A. x ( ph -> ps ) )" // } { $_
          [ /hbim $$ ] pushStep
          |pushStep [| "( " $ph " -> A. " $x " " $ph " )" |] constructUnused
          |pushStep [| "( " $ps " -> A. " $x " " $ps " )" |] constructUnused
        }
        { thm "( [ y / x ] ph -> A. x [ y / x ] ph )" // } {
          [ /hbsb3 $$ ] pushStep
          |pushStep [| "( " $ph " -> A. " $y " " $ph " )" |] constructUnused
        }
        { thm "( A = B -> A. x A = B )" // } {
          [| $x " " $A " " $B |] 2 freshVariables $=y $=z
          [ /hbeq $$ ] pushStep

          |pushStep [| "( " $y " e. " $A " -> A. " $x " " $y " e. " $A " )" |] constructUnused
          |pushStep [| "( " $z " e. " $B " -> A. " $x " " $z " e. " $B " )" |] constructUnused
        }
        { thm "( A. x ph -> A. x A. x ph )" // } {
          [ /hba1 $$ ] pushStep
        }
        { thm "( A. x e. A ph -> A. x A. x e. A ph )" // } {
          [ /hbra1 $$ ] pushStep
        }
        { thm "( A. y e. A ph -> A. x A. y e. A ph )" // } {
          [ /hbral $$ ] pushStep

          |pushStep [| "( " $y " e. " $A " -> A. " $x " " $y " e. " $A " )" |] constructUnused
          |pushStep [| "( " $ph " -> A. " $x " " $ph " )" |] constructUnused
        }
        { 1 } {
          [| "No construction step known to show non-usage for:" |] err
          [| 0 thm renderNicely "\n" |] out
          thm "( ph -> A. x ph )" // --
          $ph $x mayDisjunct dump
          /TODO:strategyUnusedVariable die
        }
      ] conds
    } /constructUnused deffst
    <
      { ==goal
        ""
      } /usedAntecedent deffst

      { .thm constructUnused } /construct deffst
    > ==strategyUnusedVariable
    { _ ==goal .thm ==thm
      thm "( ph -> A. x ph )" // { $_
        $x $ph requiredDisjuncts ==required
        required $x eq any not {
          "... (unusedVariable)" /resolution goal .set
          strategyUnusedVariable /strategy goal .set

          required { $x markDisj } each
        } rep
      } rep
    } /unusedVariable deffst

    <
      { ==goal
        map ==known
        goal .antes { 1 -01 known =[] } each
        goal .children len {
          0 goal .children * _ .strategy .usedAntecedent ==childAnte
          goal .thm splitConjunction { known .has } grep makeConjunction ==knownAntes
          childAnte "" neq {
            [| "( " childAnte " /\\ " knownAntes " )" |]
          } {
            knownAntes
          } ? *
        } {
          # All clauses of goal are already known, request well-sorted antecedent
          goal .thm
        } ? *
      } /usedAntecedent deffst

      { ==goal =*pushStep
        goal .children len {
          map ==known
          goal .antes { 1 -01 known =[] } each
          goal .thm splitConjunction { known .has } grep makeConjunction ==knownAntes
          0 goal .children * _ ==child _ .strategy .usedAntecedent ==childAnte
          goal _ .strategy .usedAntecedent ==usedAnte

          childAnte "" eq {
            # knownAntes -> goal .thm

            map ==lastGrammarMatch $_
            knownAntes $=ph
            child .thm $=ps
            knownAntes $=ch
            goal .thm $=th
            [ /syl2anc$HERE2 $$ ] pushStep

            map ==lastGrammarMatch $_
            knownAntes $=ps
            child .thm $=ph
            [ /a1i$HERE1 $$ ] pushStep

            |pushStep child _ .strategy .construct

            map ==lastGrammarMatch $_
            knownAntes $=ph
            [ /id$HERE2 $$ ] pushStep
          } {
            # ( childAnte /\ knownAntes ) -> goal .thm
            map ==lastGrammarMatch $_
            childAnte $=ph
            child .thm $=ps
            knownAntes _ $=ta $=ch
            goal .thm $=th
            [ /syl2an$HERE1 $$ ] pushStep

            |pushStep child _ .strategy .construct

            map ==lastGrammarMatch $_
            knownAntes $=ph
            [ /id$HERE3 $$ ] pushStep
          } ? *

          |pushStep [| "( " child .thm " /\\ " knownAntes " )" |] goal .thm transformConjunct
        } {
          $_ goal .thm $=ph
          [ /id$HERE4 $$ ] pushStep
        } ? *
      } /construct deffst
    > ==strategyKnownAntes
    { _ ==goal .thm ==thm
      map ==known
      goal .antes { 1 -01 known =[] } each
      thm splitConjunction { known .has } grep ==used
      used len 0 neq {
        "... (known antes)" /resolution goal .set
        strategyKnownAntes /strategy goal .set

        thm splitConjunction { known .has not } grep ==remaining
        remaining len 0 neq {
            [ goal .antes remaining makeConjunction newGoal ]
          /children goal .set
        } rep
      } rep
    } /knownAntes deffst

    { ==thm =*pushStep
      [
        { thm "A e. CC" // { $A parseNumber } andif } { --
          [ /nn0cni $$ ] pushStep
          |pushStep [| $A " e. NN0" |] constructDecimal
        }
        { thm "A e. RR" // { $A parseNumber } andif } { --
          [ /nn0rei $$ ] pushStep
          |pushStep [| $A " e. NN0" |] constructDecimal
        }
        { thm "A e. RR+" // { $A parseNumber } andif { 0 gt } andif } { $_
          [ /ax-mp$1 <$ [| $A " e. NN" |] ==ph thm ==ps $> ] pushStep
          |pushStep [| $A " e. NN" |] constructDecimal
          [ /nnrp $$ ] pushStep
        }
        { thm "A e. _V" // { $A parseNumber } andif } { --
          "NN0" $=B
          [ /elexi $$ ] pushStep
          |pushStep [| $A " e. NN0" |] constructDecimal
        }
        { thm "; A B e. NN" // } { $_
          $B parseNumber { 0 eq } andif {
            [ /decnnclb $$ ] pushStep
            |pushStep [| $A " e. NN" |] constructDecimal
            |pushStep [| $B " e. NN0" |] constructDecimal
          } {
            [ /decnncl $$ ] pushStep
            |pushStep [| $A " e. NN0" |] constructDecimal
            |pushStep [| $B " e. NN" |] constructDecimal
          } ? *
        }
        { thm "; A B e. NN0" // } { $_
          [ /deccl $$ ] pushStep
          |pushStep [| $A " e. NN0" |] constructDecimal
          |pushStep [| $B " e. NN0" |] constructDecimal
        }
        { thm "0 e. NN0" // } { [ /0nn0 map ] pushStep }
        { thm "1 e. NN0" // } { [ /1nn0 map ] pushStep }
        { thm "2 e. NN0" // } { [ /2nn0 map ] pushStep }
        { thm "3 e. NN0" // } { [ /3nn0 map ] pushStep }
        { thm "4 e. NN0" // } { [ /4nn0 map ] pushStep }
        { thm "5 e. NN0" // } { [ /5nn0 map ] pushStep }
        { thm "6 e. NN0" // } { [ /6nn0 map ] pushStep }
        { thm "7 e. NN0" // } { [ /7nn0 map ] pushStep }
        { thm "8 e. NN0" // } { [ /8nn0 map ] pushStep }
        { thm "9 e. NN0" // } { [ /9nn0 map ] pushStep }
        { thm "10 e. NN0" // } { [ /10nn0 map ] pushStep }
        { thm "1 e. NN" // } { [ /1nn map ] pushStep }
        { thm "2 e. NN" // } { [ /2nn map ] pushStep }
        { thm "3 e. NN" // } { [ /3nn map ] pushStep }
        { thm "4 e. NN" // } { [ /4nn map ] pushStep }
        { thm "5 e. NN" // } { [ /5nn map ] pushStep }
        { thm "6 e. NN" // } { [ /6nn map ] pushStep }
        { thm "7 e. NN" // } { [ /7nn map ] pushStep }
        { thm "8 e. NN" // } { [ /8nn map ] pushStep }
        { thm "9 e. NN" // } { [ /9nn map ] pushStep }
        { thm "10 e. NN" // } { [ /10nn map ] pushStep }
        { thm "( B - A ) e. NN" // } { $_
          [ /mpbi <$ thm ==ps [| $A " < " $B |] ==ph $> ] pushStep

          |pushStep [| $A " < " $B |] constructArithmetics

          [ /nnsubi $$ ] pushStep
          |pushStep [| $A " e. NN" |] constructDecimal
          |pushStep [| $B " e. NN" |] constructDecimal
        }
        { thm "( A - B ) e. RR" // } { $_
          [ /resubcli $$ ] pushStep
          |pushStep [| $A " e. RR" |] constructDecimal
          |pushStep [| $B " e. RR" |] constructDecimal
        }
        { thm "( A mod B ) e. RR" // } { $_
          [ /ax-mp$2 <$
            thm ==ps
            [| "( " $A " e. RR /\\ " $B " e. RR+ )" |] ==ph
          $> ] pushStep

          [ /pm3.2i <$
            [| $A " e. RR" |] ==ph
            [| $B " e. RR+" |] ==ps
          $> ] pushStep

          |pushStep [| $A " e. RR" |] constructDecimal
          |pushStep [| $B " e. RR+" |] constructDecimal

          [ /modcl $$ ] pushStep
        }
        { 1 } {
          [| "Could not deduce decimal class membership for:" |] err
          [| 0 thm renderNicely "\n" |] out
          /TODO:constructDecimal die
        }
      ] conds
    } /constructDecimal deffst

    <
      { ==goal
        ""
      } /usedAntecedent deffs

      { .thm constructDecimal } /construct deffst
    > ==strategyDecimal
    { _ ==goal .thm ==thm
      thm "A e. NN" // {
        $A evaluateArithmetics { ==A
          A 0 gt {
            "... (e. NN)" /resolution goal .set
            strategyDecimal /strategy goal .set
          } rep
        } rep
      } rep
      thm "A e. NN0" // {
        $A evaluateArithmetics { ==A
          A 0 ge {
            "... (e. NN0)" /resolution goal .set
            strategyDecimal /strategy goal .set
          } rep
        } rep
      } rep
      thm "A e. RR+" // {
        $A evaluateArithmetics { ==A
          A 0 gt {
            "... (e. RR+)" /resolution goal .set
            strategyDecimal /strategy goal .set
          } rep
        } rep
      } rep
      thm "A e. RR" // {
        $A evaluateArithmetics { ==A
          A 0 ge {
            "... (e. RR)" /resolution goal .set
            strategyDecimal /strategy goal .set
          } rep
        } rep
      } rep
      thm "A e. CC" // {
        $A evaluateArithmetics { ==A
          A 0 ge {
            "... (e. CC)" /resolution goal .set
            strategyDecimal /strategy goal .set
          } rep
        } rep
      } rep
      thm "A e. _V" // {
        $A parseNumber { --
          "... (e. _V)" /resolution goal .set
          strategyDecimal /strategy goal .set
        } rep
      } rep
    } /decimal deffst

    { ==expr
      [
        { expr parseNumber } { # ==n
          1
        }
        { expr "; A B" // } { $_
          $A evaluateArithmetics {
            10 mul $B evaluateArithmetics {
              add 1
            } {
              -- 0
            } ? *
          } {
            0
          } ? *
        }
        { expr "( A + B )" // } { $_
          $A evaluateArithmetics {
            $B evaluateArithmetics {
              add 1
            } {
              -- 0
            } ? *
          } {
            0
          } ? *
        }
        { expr "( A - B )" // } { $_
          $A evaluateArithmetics {
            $B evaluateArithmetics {
              sub 1
            } {
              -- 0
            } ? *
          } {
            0
          } ? *
        }
        { expr "( A x. B )" // } { $_
          $A evaluateArithmetics {
            $B evaluateArithmetics {
              mul 1
            } {
              -- 0
            } ? *
          } {
            0
          } ? *
        }
        { expr "( A mod B )" // } { $_
          $A evaluateArithmetics {
            $B evaluateArithmetics {
              mod 1
            } {
              -- 0
            } ? *
          } {
            0
          } ? *
        }
        { 1 } { 0 }
      ] conds
    } /evaluateArithmetics deffst

    { ==thm =*pushStep
      {
        [| "Failed to construct arithmetic proof." |] err
        [| 0 thm renderNicely "\n" |] out
      } /failed defvst
      {
        [| 0 thm renderNicely "\n" |] out
        /TODO:strategyArithmetics die
      } /todo defvst

      [
        { thm "( ( A F B ) G C ) = D" // } { $_
          [| "( " $A " " $F " " $B " )" |] evaluateArithmetics {
            [| -01 printNumber { " " } each -- |] ==innerResult

            [ /eqtri <$
              [| "( ( " $A " " $F " " $B " ) " $G " " $C " )" |] ==A
              [| "( " innerResult " " $G " " $C " )" |] ==B
              $D ==C
            $> ] pushStep

            # |- ( ( A F B ) G C ) = ( <eval> G C )
            [ /oveq1i <$
              [| "( " $A " " $F " " $B " )" |] ==A
              innerResult ==B $G ==F $C ==C
            $> ] pushStep

            |pushStep [| "( " $A " " $F " " $B " ) = " innerResult |] constructArithmetics

            # |- ( <eval> G C ) = D
            |pushStep [| "( " innerResult " " $G " " $C " ) = " $D |] constructArithmetics
          } failed ? *
        }
        { thm "( A F ( B G C ) ) = D" // } { $_
          [| "( " $B " " $G " " $C " )" |] evaluateArithmetics {
            [| -01 printNumber { " " } each -- |] ==innerResult

            [ /eqtri <$
              [| "( " $A " " $F " ( " $B " " $G " " $C " ) )" |] ==A
              [| "( " $A " " $F " " innerResult " )" |] ==B
              $D ==C
            $> ] pushStep

            # |- ( A F ( B G C ) = ( A F <eval> )
            [ /oveq2i <$
              [| "( " $B " " $G " " $C " )" |] ==A
              innerResult ==B $F ==F $A ==C
            $> ] pushStep

            |pushStep [| "( " $B " " $G " " $C " ) = " innerResult |] constructArithmetics

            # |- ( A F eval> ) = D
            |pushStep [| "( " $A " " $F " " innerResult " ) = " $D |] constructArithmetics
          } failed ? *
        }
        { thm "A = A" // } {
          [ /eqid $$ ] pushStep
        }
        { thm "( A mod B ) = C" // } { $_
          $A evaluateArithmetics { ==A
            $B evaluateArithmetics { ==B
              [| A B div printNumber { " " } each -- |] $=D
              [ /nnmulmodvali $$ ] pushStep

              |pushStep [| $A " e. NN0" |] constructDecimal
              |pushStep [| $B " e. NN" |] constructDecimal
              |pushStep [| $C " e. NN0" |] constructDecimal
              |pushStep [| $D " e. NN0" |] constructDecimal
              |pushStep [| $C " < " $B |] constructArithmetics
              |pushStep [| "( ( " $D " x. " $B " ) + " $C " ) = " $A |] constructArithmetics
            } failed ? *
          } failed ? *
        }
        { thm "0 < A" // { $A parseNumber } andif } { ==A
          [ /nngt0i $$ ] pushStep
          |pushStep [| $A " e. NN" |] constructDecimal
        }
        { thm "( A + 0 ) = A" // } {
          [ /addid1i $$ ] pushStep
          |pushStep [| $A " e. CC" |] constructDecimal
        }
        { thm "( 0 + A ) = A" // } {
          [ /addid2i $$ ] pushStep
          |pushStep [| $A " e. CC" |] constructDecimal
        }
        { thm "( A x. 1 ) = A" // } {
          [ /mulid1i $$ ] pushStep
          |pushStep [| $A " e. CC" |] constructDecimal
        }
        { thm "( 1 x. A ) = A" // } {
          [ /mulid2i $$ ] pushStep
          |pushStep [| $A " e. CC" |] constructDecimal
        }
        { thm "A = ; 0 A" // { $A parseNumber } andif } { ==A
          [ /dec0h $$ ] pushStep
          |pushStep [| $A " e. NN0" |] constructDecimal
        }
        { thm "( A + B ) = C" //
            { $A parseNumber } andif { 10 lt } andif
            { $B parseNumber } andif { 10 lt } andif } { $_
          $A parseNumber -- $B parseNumber -- lt {
            [ /eqtri <$
              [| "( " $A " + " $B " )" |] ==A
              [| "( " $B " + " $A " )" |] ==B
              $C ==C
            $> ] pushStep

            [ /addcomi $$ ] pushStep
            |pushStep [| $A " e. CC" |] constructDecimal
            |pushStep [| $B " e. CC" |] constructDecimal

            |pushStep [| "( " $B " + " $A " ) = " $C |] constructArithmetics
          } {
            $C parseNumber { ==C
              $C "; 1 0" eq {
                [ /eqtri <$
                  [| "( " $A " + " $B " )" |] ==A "10" ==B $C ==C
                $> ] pushStep
              } rep
              [| $A "p" $B "e" C txt .produce .u |] ==name
              name assertions .has {
                [ name map ] pushStep
              } failed ? *
              $C "; 1 0" eq {
                [ /dec10 map ] pushStep
              } rep
            } failed ? *
          } ? *
        }
        { thm "( M + N ) = ; E F" // } { $_
          $M parseNumber { ==M
            $N parseNumber { ==N
              { ==name [| -01 printNumber { " " } each -- |] name $= } "$=#" deffst

              M _ 10 div $=#A 10 mod _ ==B $=#B
              N _ 10 div $=#C 10 mod _ ==D $=#D
              B D add 10 ge /decaddc /decadd ? ==name

              [ name $$ ] pushStep
              name assertions * ==a
              a .hyps { a .ctx isEHyp } grep { ==hyp
                [| hyp a .ctx getEHyp $$ applySubstitution { " " } each -- |] 3 -01 str .postfix ==thm
                |pushStep thm _ "A e. NN0" // |constructDecimal |constructArithmetics ? *
              } each
            } failed ? *
          } failed ? *
        }
        { thm "( A - B ) = C" // } { $_
          $A parseNumber { ==A
            $B parseNumber { ==B
              $C parseNumber { ==C
                [ /subaddrii $$ ] pushStep

                |pushStep [| $A " e. CC" |] constructDecimal
                |pushStep [| $B " e. CC" |] constructDecimal
                |pushStep [| $C " e. CC" |] constructDecimal
                |pushStep [| "( " $B " + " $C " ) = " $A |] constructArithmetics
              } failed ? *
            } failed ? *
          } failed ? *
        }
        { thm "( ; A B x. ; C D ) = ; ; E F G" // } { $_
          [ [ /A /B /C /D /E /F /G ] { ==v
            v $ parseNumber { v ==? }' { 0 v ==? 0 }' ? *
          }' each ] all {
            { ==name ==value value name defvst
                             [| value printNumber { " " } each -- |] name $= }' "$=#" deffst

            B D mul 10 div $=#H
            A D mul _ 10 div $=#I 10 mod $=#J
            C B mul _ 10 div $=#K 10 mod $=#L
            I K add $=#N
            H J add $=#O
            O L add 10 div $=#M
            A C mul $=#P
            N M add $=#Q

            [ /decmul12c $$ ] pushStep
            /decmul12c assertions * ==a
            a .hyps { a .ctx isEHyp } grep { ==hyp
              [| hyp a .ctx getEHyp $$ applySubstitution { " " } each -- |] 3 -01 str .postfix ==thm
              |pushStep thm _ "A e. NN0" // |constructDecimal |constructArithmetics ? *
            } each
          } failed ? *
        }
        { thm "( ; A B x. P ) = ; C D" // } { $_
          [ [ /A /B /P /C /D ] { ==v
            v $ parseNumber { v ==? }' { 0 v ==? 0 }' ? *
          }' each ] all {
            { ==name [| -01 printNumber { " " } each -- |] name $= } "$=#" deffst

            A 10 mul B add $=#N
            B P mul 10 div $=#E

            [ /decmul1c $$ ] pushStep
            /decmul1c assertions * ==a
            a .hyps { a .ctx isEHyp } grep { ==hyp
              [| hyp a .ctx getEHyp $$ applySubstitution { " " } each -- |] 3 -01 str .postfix ==thm
              |pushStep thm _ "A e. NN0" // |constructDecimal |constructArithmetics ? *
            } each
          } failed ? *
        }
        { thm "( D x. E ) = ; 0 B" // } { $_
          [| "( " $D " x. " $E " )" |] $=A
          [| "; 0 " $B |] $=C
          [ /eqtri $$ ] pushStep

          |pushStep [| $A " = " $B |] constructArithmetics
          |pushStep [| $B " = " $C |] constructArithmetics
        }
        { thm "( A x. B ) = C" // } { $_
          $A parseNumber { ==A
            $B parseNumber { ==B
              A B lt {
                [ /eqtri <$
                  [| "( " $A " x. " $B " )" |] ==A
                  [| "( " $B " x. " $A " )" |] ==B
                  $C ==C
                $> ] pushStep

                [ /mulcomi $$ ] pushStep
                |pushStep [| $A " e. CC" |] constructDecimal
                |pushStep [| $B " e. CC" |] constructDecimal

                |pushStep [| "( " $B " x. " $A " ) = " $C |] constructArithmetics
              } {
                $C parseNumber { ==C
                  [| $A "t" $B "e" C txt .produce .u |] ==name
                  name assertions .has {
                    [ name map ] pushStep
                  } failed ? *
                } failed ? *
              } ? *
            } failed ? *
          } failed ? *
        }
        { thm "C = ( A - B )" // } { $_
          $A parseNumber { ==A
            $B parseNumber { ==B
              $C parseNumber { ==C
                [ /eqcomi <$ $C ==B [| "( " $A " - " $B " )" |] ==A $> ] pushStep
                |pushStep [| "( " $A " - " $B " ) = " $C |] constructArithmetics
              } failed ? *
            } failed ? *
          } failed ? *
        }
        { thm "A =/= B" // } { $_
          $A parseNumber { ==A
            $B parseNumber { ==B
              A B lt {
                [ /ltneii $$ ] pushStep

                |pushStep [| $A " e. RR" |] constructDecimal
                |pushStep [| $A " < " $B |] constructArithmetics
              } {
                $A $B $=A $=B
                [ /gtneii $$ ] pushStep

                |pushStep [| $A " e. RR" |] constructDecimal
                |pushStep [| $A " < " $B |] constructArithmetics
              } ? *
            } failed ? *
          } failed ? *
        }
        { thm "0 < ( A - B )" // } { $_
          $A evaluateArithmetics { ==A
            $B evaluateArithmetics { ==B
              [| A B sub printNumber { " " } each -- |] ==result

              [ /mpbir <$ thm ==ph [| "0 < " result |] ==ps $> ] pushStep

              |pushStep [| "0 < " result |] constructArithmetics

              [ /breq2i <$
                "<" ==R "0" ==C
                [| "( " $A " - " $B " )" |] ==A
                [| A B sub printNumber { " " } each -- |] ==B
              $> ] pushStep

              |pushStep [| "( " $A " - " $B " ) = " result |] constructArithmetics
            } failed ? *
          } failed ? *
        }
        { thm "A <_ A" // } {
          [ /leidi $$ ] pushStep
          |pushStep [| $A " e. RR" |] constructDecimal
        }
        { thm "A <_ B" // } { $_
          $A evaluateArithmetics { ==A
            $B evaluateArithmetics { ==B
              [
                { A B lt } {
                  [ /ltleii $$ ] pushStep
                  |pushStep [| $A " e. RR" |] constructDecimal
                  |pushStep [| $B " e. RR" |] constructDecimal

                  |pushStep [| $A " < " $B |] constructArithmetics
                }
                { A B eq } {
                  [ /ax-mp$3 <$ [| "( " $A " e. RR /\\ " $A " = " $B " )" |] ==ph thm ==ps $> ] pushStep
                  [ /pm3.2i <$ [| $A " e. RR" |] ==ph [| $A " = " $B |] ==ps $> ] pushStep
                  |pushStep [| $A " e. RR" |] constructDecimal
                  |pushStep [| $A " = " $B |] constructArithmetics

                  [ /eqle $$ ] pushStep
                }
                { 1 } failed
              ] conds
            } failed ? *
          } failed ? *
        }
        { thm "A < B" // } { $_
          $A evaluateArithmetics { ==A
            $B evaluateArithmetics { ==B
              [ /mpbir <$
                thm ==ph [| "0 < ( " $B " - " $A " )" |] ==ps
              $> ] pushStep

              |pushStep [| "0 < ( " $B " - " $A " )" |] constructArithmetics

              [ /posdifi $$ ] pushStep
              |pushStep [| $A " e. RR" |] constructDecimal
              |pushStep [| $B " e. RR" |] constructDecimal
            } failed ? *
          } failed ? *
        }
        { 1 } todo
      ] conds
    } /constructArithmetics deffst
    <
      { ==goal
        ""
      } /usedAntecedent deffs

      { .thm constructArithmetics } /construct deffst
    > ==strategyArithmetics
    { _ ==goal .thm ==thm
      [
        [ "=" |eq ]
        [ "=/=" |neq ]
        [ "<" |lt ]
        [ "<_" |le ]
        [ ">" |gt ]
        [ ">_" |ge ]
      ] { 2 dearray =*check ==rel
        thm [| "A " rel " B" |] // { $_
          $A evaluateArithmetics { ==A
            $B evaluateArithmetics { ==B
              A B check {
                "... (arithmetics)" /resolution goal .set
                strategyArithmetics /strategy goal .set
              } {
                [| "Impossible subgoal:" |] warn
                [| 0 thm renderNicely "\n" |] out
              } ? *
            } rep
          } rep
        } rep
      } each
    } /arithmetics deffst

    { ==thm =*pushStep
      [
        { thm "x e. _V" // } { [ /vex $$ ] pushStep }
        { thm "A = A" // } { [ /eqid $$ ] pushStep }
      ] conds
    } /constructTrivialities deffst
    <
      { ==goal
        ""
      } /usedAntecedent deffs

      { # ==goal =*pushStep
        .thm constructTrivialities
      } /construct deffst
    > ==strategyTrivialities
    { ==goal
      # If we could do it, consider it done.
      { --
        "(trivial)" /resolution goal .set
        strategyTrivialities /strategy goal .set
      } goal .thm constructTrivialities
    } /trivialities deffst

    <
      { ==goal
        0 goal .children * _ .strategy .usedAntecedent ==childAnte

        map ==newAntesSet
        goal .newAntes { 1 -01 newAntesSet =[] } each

        childAnte splitConjunction { newAntesSet .has not } grep makeConjunction
      } /usedAntecedent deffst

      { ==goal =*pushStep
        goal .thm ==thm
        goal _ .strategy .usedAntecedent ==ante
        ante "" neq {
          [| "( " ante " -> " thm " )" |] =thm
        } rep

        0 goal .children * _ .strategy .usedAntecedent ==childAnte

        # |- thm

        { thm "( ph -> ( ps -> ch ) )" // } {
          [ /ex $$ ] pushStep
          [| "( ( " $ph " /\\ " $ps " ) -> " $ch " )" |] =thm
        } loop

        childAnte len {
          thm "( ph -> ch )" // { $_
            childAnte $=ps
            [ /syl$HERE1 $$ ] pushStep
            |pushStep $ph $ps transformConjunct
            |pushStep 0 goal .children * _ .strategy .construct
          } {
            [| "TODO: Theorem became " thm " without antecedents." |] die
          } ? *
        } {
          thm "( ps -> ph )" // { $_
            [ /a1i$HERE2 $$ ] pushStep
            |pushStep 0 goal .children * _ .strategy .construct
          } {
            [| "TODO: Theorem became " thm " without antecedents." |] die
          } ? *
        } ? *
      } /construct deffst
    > ==strategyExtractAntes
    { _ ==goal .thm ==thm
      [ { thm "( ph -> ps )" // } { $ps =thm $ph splitConjunction _ len dearray } loop ] ==newAntes

      newAntes len 0 neq {
        "... (extractAntes)" /resolution goal .set
        strategyExtractAntes /strategy goal .set
        newAntes /newAntes goal .setExtra

        [ goal .antes newAntes cat thm newGoal ] /children goal .set
      } rep
    } /extractAntes deffst

    <
      { ==goal
        /TODO:strategyFromAntes die
      } /usedAntecedent deffst
      { ==goal =*pushStep
        /TODO:strategyFromAntes die
      } /construct deffst
    > ==strategyFromAntes
    { ==goal
      goal .thm goal .antes eq any {
        "... (fromAntes)" /resolution goal .set
        strategyFromAntes /strategy goal .set
      } rep
    } /fromAntes deffst

    <
      { ==goal
        0 goal .children * _ .strategy .usedAntecedent ==childAnte

        map ==needed
        childAnte splitConjunction { 1 -01 needed =[] } each
        goal .deduced needed .has {
          1 [| "( " goal .source " -> " goal .deduced " )" |] needed =[]
          1 goal .source needed =[]
          0 goal .deduced needed =[]

          needed dom { needed * } grep makeConjunction
        } {
          childAnte
        } ? *
      } /usedAntecedent deffst

      { ==goal =*pushStep
        0 goal .children * _ .strategy .usedAntecedent ==childAnte

        map ==needed
        childAnte splitConjunction { 1 -01 needed =[] } each

        goal .deduced needed .has {
          goal _ .strategy .usedAntecedent ==usedAntecedent
          usedAntecedent len not {
            /TODO:strategyWithinAntes die
          } rep

          # |- usedAntecedent -> goal .thm
          map ==lastGrammarMatch $_
          usedAntecedent $=ph
          goal .thm $=ch
          goal .deduced $=ps

          [ /mpdan $$ ] pushStep

          # |- $ph -> $ps
          [ /syl$HERE7 <$
            $ph ==ph $ps ==ch
            [| "( " goal .source " /\\ ( " goal .source " -> " goal .deduced " ) )" |] ==ps
          $> ] pushStep

          |pushStep $ph [| "( " goal .source " /\\ ( " goal .source " -> " goal .deduced " ) )" |] transformConjunct

          [ /pm3.35 <$ goal .source ==ph goal .deduced ==ps $> ] pushStep

          # |- ( $ph /\ $ps ) -> $ch
          0 goal .children * _ .strategy .usedAntecedent ==childAnte
          [ /syl$HERE8 <$
            [| "( " $ph " /\\ " $ps " )" |] ==ph
            childAnte ==ps
            $ch ==ch
          $> ] pushStep

          |pushStep [| "( " $ph " /\\ " $ps " )" |] childAnte transformConjunct
          |pushStep 0 goal .children * _ .strategy .construct
        } {
          |pushStep 0 goal .children * _ .strategy .construct
        } ? *
      } /construct deffst
    > ==strategyWithinAntes
    { ==goal
      map ==allAntes
      goal .antes { 1 -01 allAntes =[] } each

      goal .antes { "( ph -> ps )" // $_
          { $ph splitConjunction { allAntes .has } '*0.0 all } andif
          { $ps allAntes .has not } andif {
        "... (within antes)" /resolution goal .set
        strategyWithinAntes /strategy goal .set
          [ goal .antes [ $ps ] cat goal .thm newGoal ]
        /children goal .set
        $ps /deduced goal .setExtra
        $ph /source goal .setExtra
      } rep } each
    } /withinAntes deffst

    # Things which could be a strategy maybe, but for now just call high-level commands
    { _ ==goal .thm ==thm
      map ==equalities
      { ==A A equalities .has { A equalities * } { A } ? * } /eqmin deffst

      goal .antes { ==ante
        ante "A = B" // {
          1 ante equalities =[]
          $A eqmin $B eqmin min _ $A equalities =[]
                                  $B equalities =[]
        } rep
      } each

      "" ==x "" ==y
      goal .antes { ==ante
        ante "[ x / y ] ph" // {
          $ph thm eq {
            $x eqmin $y eqmin eq { $_
              /stdpc7 goal useTheorem
              [ $x ] "$x" let
              [ $y ] "$y" let
            } rep
          } rep
        } rep
      } each

      thm "( A F C ) = ( B F C )" // {
        $A eqmin $B eqmin eq { $_
          [| $A " = " $B |] equalities .has not {
            [| $A " = " $B |] goal conclude
          } {
            /oveq1d goal useTheorem
            [| $A " = " $B |] " " str .split "$ph" let
          } ? *
        } rep
      } rep
    } /automations deffst

    { _ ==goal _ .thm ==thm .antes ==antes
      # meta variable expansion in-place
      [| thm " " str .split expandMeta { " " } each -- |] ==expandedThm
      thm expandedThm neq { expandedThm _ =thm /thm goal .set } rep

      antes dom { _ ==i antes * ==ante
        [| ante " " str .split expandMeta { " " } each -- |] ==expandedAnte
        ante expandedAnte neq { expandedAnte i -1010 goal .antes =[] antes =[] } rep
      } each

      goal .?delayedResolution {
        goal .isopen goal .delayedResolution rep
      } {
        [
          thm "$" str .split len 1 eq
          antes { "$" str .split len 1 eq } each
        ] all {
          [
            |unusedVariable
            |knownAntes
            |decimal
            |arithmetics
            |trivialities
            |extractAntes
            |fromAntes
            |withinAntes
            |automations
            loadedAutomations "*" | each
          ] { =*resolution
            goal .isopen { goal resolution } rep
          } each
        } rep
      } ? *
    } /normalizeGoal deffst

    # takes variable name, either wff, set or class
    { ==var
      [
        { [| "wff " var |] proofFHyps .has } { "wff" }
        { [| "set " var |] proofFHyps .has } { "set" }
        { [| "class " var |] proofFHyps .has } { "class" }
        { 1 } { [| "Could not determine type of " var |] err "<unknown>" }
      ] conds
    } /typeOfVariable deffst

    { =*wrapOut ==rootNonterminal ==toks
      0 toks rootNonterminal logicParsers * * not {
        [| "Could not generate parse for syntax-proof." |] err
        [| toks { " " } each -- |] dump
        "?" wrapOut
      } { ==parse
        parse logicNonTerminal _ ==builder "" eq {
          [| rootNonterminal " " toks { " " } each -- |] ==fThm
          fThm proofFHyps .has {
            fThm proofFHyps * wrapOut
          } {
            [| "Could not find theorem for: " fThm |] err
          } ? *
        } {
          builder assertions * ==a

          parse toks a .thm 0 a .thm * 1 possibleSubstitutionsForParse ==substitutions
          substitutions len 1 neq {
            [| "No substitution found during syntax proof construction." |] err
          } { 0 substitutions * =*substitution
            a .hyps { ==h
              h a .ctx isFHyp {
                h a .ctx getFHyp 2 dearray ==var ==type
                var substitution type |wrapOut constructSyntax
              } rep
            } each
          } ? *

          builder wrapOut
        } ? *
      } ? *
    } /constructSyntax deffst

    { ==var
      [| "$" var "." nextMetaVariable _ 1 add =nextMetaVariable txt .produce .u |] ==newVar
      newVar var lastMetaVariables =[]
      1 newVar allMetaVariables =[]
      newVar
    } /newMetaVariable deffst

    { ==substitution ==assertion
      assertion mandatoryVariables dom { substitution .has not } grep { ==var
        [ var newMetaVariable ] var substitution =[]
        # [| "assigned " 0 var substitution * * " to " var |] err
        # [| "last is " var lastMetaVariables * |] err
      } each
    } /introduceMetaVariables deffst

    { ==substitution ==assertion
      0 ==disjunctionsViolated
      assertion .disj { 2 dearray ==x ==y
        x substitution * { ==xTok
          xTok constants .has not {
            y substitution * { ==yTok
              yTok constants .has not {
                xTok yTok eq {
                  1 =disjunctionsViolated
                  [| "Proposed application would violate\e[0m " x renderName " <!> " y renderName |] err
                } rep
                xTok yTok mustNotDisj {
                  1 =disjunctionsViolated
                  [| "Proposed application would violate\e[0m " x renderName " <=> " y renderName |] err
                } rep
              } rep
            } each
          } rep
        } each
      } each
      disjunctionsViolated
    } /hasDisjunctionViolations deffst

    { ==substitution ==assertion
      assertion .disj { 2 dearray ==x ==y
        x substitution * { ==xTok
          xTok constants .has not {
            y substitution * { ==yTok
              yTok constants .has not { xTok yTok markDisj } rep
            } each
          } rep
        } each
      } each
    } /markDisjunctions deffst

    <
      { ==goal
        ""
      } /usedAntecedent deffst

      { ==goal =*pushStep
        [ goal .resolution goal .substitution ] pushStep

        goal .children { ==child
          child _ .strategy .usedAntecedent "" neq {
            [| "Child rendered with used antecedent (but none were offered)." |] err
            goal .resolution dump
            child .resolution dump
            [| 0 child _ .strategy .usedAntecedent renderNicely "\n" |] out
            [| 0 child .thm renderNicely "\n" |] out
          } rep

          |pushStep child _ .strategy .construct
        } each
      } /construct deffst
    > ==strategyUseTheoremLiterally

    <
      { ==goal "" } /usedAntecedent deffst
      { ==goal =*pushStep
        [ goal .resolution map ] pushStep
      } /construct deffst
    > ==strategyUseEHypLiterally

    { ==goal ==thmName
      [
        { thmName collectedEHyps .has } {
          [ "|-" ] goal .thm " " str .split cat thmName collectedEHyps * arrEq {
            thmName /resolution goal .set
            strategyUseEHypLiterally /strategy goal .set
          } {
            [| "$e-hypothesis does not match current goal: " thmName |] err
          } ? *
        }

        { thmName assertions .has } {
          thmName assertions * _ ==a .thm ==thmToks

          1 ==legit

          0 thmToks * "|-" neq { 0 =legit
            [| "Theorem would not produce a logic statement: " thmName |] err
          } rep

          [ "|-" ] goal .thm " " str .split cat thmToks /wff 1 possibleSubstitutionsForToks ==possibleSubstitutions
          possibleSubstitutions len 1 neq { 0 =legit
            [| "No possible substitution found." |] err
              [ "|-" ] goal .thm " " str .split cat
              thmToks
              /wff 1
            debugPossibleSubstitutionsForToks
          } rep

          legit {
            0 possibleSubstitutions * ==substitution

            a substitution introduceMetaVariables

            [
              a .ctx collectEHyps _ =*hyps dom {
                [| -01 hyps substitution applySubstitution { " " } each -- |] 3 -01 str .postfix
              } each
            ] ==thmAntes

            a .thm [| -01 substitution applySubstitution { " " } each -- |] 3 -01 str .postfix
            ==thm

            a substitution hasDisjunctionViolations not {
              a substitution markDisjunctions

              thmName /resolution goal .set
              [
                thmAntes { ==ante [ ] ante newGoal _ normalizeGoal } each
              ] /children goal .set
              strategyUseTheoremLiterally /strategy goal .set
              substitution /substitution goal .setExtra
            } rep
          } rep
        }
        { 1 } { [| "No such theorem: " thmName |] err }
      ] conds
    } /useTheoremLiterally deffst

    <
      { ==goal
        [| 2 neg goal .resolution str .prefix collectedEHyps * { " " } each -- |] 3 -01 str .postfix ==thm

        [ { thm "( ph -> ps )" // } { $ps =thm $ph } loop ] makeConjunction
      } /usedAntecedent deffst

      { ==goal =*pushStep
        [| 2 neg goal .resolution str .prefix collectedEHyps * { " " } each -- |] 3 -01 str .postfix ==thm
        goal _ .strategy .usedAntecedent ==availableAntes
        goal .thm ==builtupThm

        stack ==anteTransforms

        [ { thm "( ph -> ps )" // } { $ps =thm $ph } loop ] ==antesToGenerate
        availableAntes "" eq {
          antesToGenerate reverse { ==ante
            $_
            ante $=ps builtupThm $=ph
            [ /a1i$HERE3 $$ ] pushStep
            [| "( " $ps " -> " $ph " )" |] =builtupThm
          } each
        } {
          antesToGenerate reverse { ==ante
            $_
            availableAntes $=ph ante $=ps builtupThm $=ch
            [ /mpd $$ ] pushStep
            [| "( " $ps " -> " $ch " )" |] =builtupThm

            |pushStep availableAntes ante transformConjunct
          } each

          $_
          availableAntes $=ps builtupThm $=ph
          [ /a1i$HERE4 $$ ] pushStep
        } ? *

        |pushStep 0 goal .children * _ .strategy .construct
      } /construct deffst
    > ==strategyUseEHyp

    <
      { ==goal
        map ==usedAntes
        1 goal .children len range goal .children * { ==child
          child _ .strategy .usedAntecedent splitConjunction { ==ante
            1 ante usedAntes =[]
          } each
        } each

        usedAntes dom makeConjunction
      } /usedAntecedent deffst

      { ==goal =*pushStep
        [|
          2 neg goal .resolution str .prefix assertions * .thm
          goal .substitution applySubstitution
          { " " } each --
        |] 3 -01 str .postfix ==thm

        goal _ .strategy .usedAntecedent ==requestedAntes

        map ==availableAntes
        1 goal .children len range goal .children * { _ .thm availableAntes =[] } each

        [ { thm "( ph -> ps )" // } { $ps =thm $ph } loop ] { ==ante
          [| ante " " str .split expandMeta { " " } each -- |]
        } '*0.0 ==antesToGenerate
        thm ==thmConclusion

        # |- ( requestedAntes -> goal .thm )
        thmConclusion goal .thm neq {
          map ==lastGrammarMatch $_
          requestedAntes $=ph thmConclusion $=ps goal .thm $=ch
          [ /syl$HERE2 $$ ] pushStep
        } rep

        # |- ( requestedAntes -> thmConclusion )
        requestedAntes "" eq {
          # |- thmConclusion
          antesToGenerate reverse { ==ante
            # |- thm
            [ /ax-mp$4444 <$ ante ==ph thm ==ps $> ] pushStep

            # |- ante
            { ==conjunction
              [
                { conjunction availableAntes .has } {
                  conjunction availableAntes * ==child
                  |pushStep child _ .strategy .construct
                }
                { conjunction "( ph /\\ ps )" // } { $_
                  [ /pm3.2i $$ ] pushStep

                  # TODO: Optimize case of trivial child
                  $ph callChildren
                  $ps callChildren
                }
                { 1 } {
                  [| "Failed to construct theorem formula." |] err
                  "Available antes:" dump
                  availableAntes dom dump
                  "Requested antes:" dump
                  [| 0 requestedAntes renderNicely "\n" |] out
                  "Conjunction:" dump
                  [| 0 conjunction renderNicely "\n" |] out
                  [ "?" map ] pushStep
                }
              ] conds
            } /callChildren deffst
            ante callChildren

            # |- ante -> thm
            [| "( " ante " -> " thm " )" |] =thm
          } each
        } {
          antesToGenerate reverse { ==ante
            $_
            requestedAntes $=ph ante $=ps thm $=ch
            [ /mpd $$ ] pushStep
            [| "( " $ps " -> " $ch " )" |] =thm

            { ==conjunction
              [
                { conjunction availableAntes .has } {
                  # TODO: Optimize case of trivial child

                  conjunction availableAntes * ==child
                  child _ .strategy .usedAntecedent ==childAnte
                  childAnte "" neq {
                    map ==lastGrammarMatch $_
                    requestedAntes $=ph conjunction $=ch childAnte $=ps
                    [ /syl$HERE3 $$ ] pushStep

                    |pushStep requestedAntes childAnte transformConjunct
                  } {
                    map ==lastGrammarMatch $_
                    requestedAntes $=ps conjunction $=ph
                    [ /a1i$HERE5 $$ ] pushStep
                  } ? *

                  |pushStep child _ .strategy .construct
                }
                { conjunction "( ps /\\ ch )" // } { $_
                  requestedAntes $=ph
                  [ /jca$HERE2 $$ ] pushStep

                  $ps callChildren
                  $ch callChildren
                }
                { conjunction "( ps /\\ ch /\\ th )" // } { $_
                  requestedAntes $=ph
                  [ /3jca$HERE7 $$ ] pushStep

                  $ps callChildren
                  $ch callChildren
                  $th callChildren
                }
                { 1 } {
                  [| "Failed to construct theorem formula." |] err
                  "Requested antes:" dump
                  [| 0 requestedAntes renderNicely "\n" |] out
                  "Conjunction:" dump
                  [| 0 conjunction renderNicely "\n" |] out
                  "Children:" dump
                  goal .children { ==child
                    [| 0 child .thm renderNicely "\n" |] out
                  } each
                }
              ] conds
            } /callChildren deffst
            ante callChildren
          } each

          $_
          requestedAntes $=ps thm $=ph
          [ /a1i$HERE6 $$ ] pushStep
        } ? *

        |pushStep 0 goal .children * _ .strategy .construct

        thmConclusion goal .thm neq {
        # |- ( thmConclusion -> goal .thm )
          |pushStep thmConclusion goal .thm transformConjunct
        } rep
      } /construct deffst
    > ==strategyUseTheorem

    { ==goal ==thmName
      [
        { thmName collectedEHyps .has } {
          [| thmName collectedEHyps * { " " } each -- |] 3 -01 str .postfix _ ==thm ==rawThm

          [ { thm "( ph -> ps )" // } { $ps =thm $ph splitConjunction _ len dearray } loop ] ==allAntes

          goal .thm thm eq {
            1 ==allAntesAvailable
            allAntes { ==ante
              goal .antes ante eq any not {
                0 =allAntesAvailable
                [| "$e-hypothesis antecedent not available in current goal: " ante |] err
              } rep
            } each

            allAntesAvailable {
              thmName "++" cat /resolution goal .set
              [
                [ ] rawThm newGoal
              ] /children goal .set

              strategyUseEHyp /strategy goal .set

              thmName 0 goal .children * useTheoremLiterally
            } rep
          } {
            [| "$e-hypothesis does not match current goal: " thmName |] err
          } ? *
        }

        { thmName assertions .has } {
          thmName assertions * ==a
          [| a .thm { " " } each -- |] 3 -01 str .postfix _ ==thm ==rawThm

          [ { thm "( ph -> ps )" // } { $ps =thm $ph splitConjunction _ len dearray } loop ] ==allAntes

          1 ==legit

            goal .thm splitConjunction makeConjunction " " str .split
            thm splitConjunction makeConjunction " " str .split
          /wff 0 possibleSubstitutionsForToks ==possibleSubstitutions

          possibleSubstitutions len 1 neq { 0 =legit
            [| "No possible substitution found." |] err
              goal .thm splitConjunction makeConjunction " " str .split
              thm splitConjunction makeConjunction " " str .split
              /wff 0
            debugPossibleSubstitutionsForToks
          } rep

          legit {
            0 possibleSubstitutions * ==substitution

            a substitution introduceMetaVariables
            a substitution hasDisjunctionViolations not {
              a substitution markDisjunctions

              thmName "++" cat /resolution goal .set
              [
                  [ ] rawThm " " str .split [| -01 substitution applySubstitution { " " } each -- |]
                newGoal

                allAntes { ==ante
                    goal .antes ante " " str .split [| -01 substitution applySubstitution { " " } each -- |]
                  newGoal _ normalizeGoal
                } each
              ] /children goal .set

              strategyUseTheorem /strategy goal .set
              substitution /substitution goal .setExtra

              0 goal .children * ==executionGoal
              {
                executionGoal .thm "$" str .split len 1 eq {
                  thmName executionGoal useTheoremLiterally
                } rep
              } /delayedResolution executionGoal .setExtra
            } rep
          } rep
        }
      ] conds
    } /useTheorem deffst

    { ==thm =*pushStep
      0 ==applied
      [
        /id
        /bicom1
        /eqcom
        /imbi1d /imbi2d /imbi12d
        /bibi1d /bibi2d /bibi12d
        /eleq1d /eleq2d /eleq12d
        /orbi1d /orbi2d /orbi12d
        /anbi1d /anbi2d4 /anbi2d /anbi12d
        /3anbi1d /3anbi2d /3anbi3d /3anbi12d /3anbi13d /3anbi23d /3anbi123d
        /3orbi123d
        /notbid
        /eqeq1d /eqeq2d /eqeq12d
        /neeq1d /neeq2d /neeq12d
        /sseq1d /sseq2d /sseq12d
        /albid
        /exbid
        /ralbid /ralbidv2
        /rexbid /rexbidv
        /breq1d /breq2d /breqd /breq12d /breq123d
        /releqd
        /feq1d /feq2d /feq12d /feq23d
        /sbceq1a /sbceq1b /sbceq1c /sbceq1d /sbceq1aa /sbceq1ba /sbceq1ca /sbceq1da /sbcbid /sbcbi13d /sbcbi123d
        /fveq1d /fveq2d /fveq12d
        /oveq /oveq1d /oveq2d /oveq12d /oveq123d
        /opeq1d /opeq2d /opeq12d
        /xpeq1d /xpeq2d /xpeq12d
        /inteqd
        /abbidv /abbid
        /rabbidv /rabeqbidv
        /uneq1d /uneq2d /uneq12d
        /iuneq1d /iuneq2d /iuneq12d
        /seqeq1d /seqeq2d /seqeq3d /seqeq123d
        /mpteq12dv
        /mpt2eq123dv
        /coeq1d /coeq2d /coeq12d
        /reseq1d /reseq2d /reseq12d
        /dmeqd
        /rneqd
        /cnveqd
        /unieqd
        /ifeq1d /ifeq2d /ifbid /ifeq12d /ifbieq12d
      ] { ==name
        applied not {
          name assertions * ==a
          thm [| a .thm { " " } each -- |] 3 -01 str .postfix // { $_
            1 =applied

            [ name $$ ] pushStep
            a .hyps { a .ctx isEHyp } grep { ==hyp
              [| hyp a .ctx getEHyp $$ applySubstitution { " " } each -- |] 3 -01 str .postfix ==child
              |pushStep child constructRewrite
            } each
          } rep
        } rep
      } each

      applied not { thm "( A = B -> B = A )" // } andif {
        1 =applied

        [| $A " = " $B |] $=ph [| $B " = " $A |] $=ps
        [ /biimpi $$ ] pushStep

        |pushStep [| "( " $A " = " $B " <-> " $B " = " $A " )" |] constructRewrite
      } rep

      applied not { thm "( ph -> A. x ph )" // } andif
                  { $ph " " str .split $x eq any not } andif {
        1 =applied

        $ph $x mayDisjunct not {
          [| "non-disjunction violated during rewrite" |] err
        } rep

        $ph $x checkMarkedDisjunct
        [ /ax-17 $$ ] pushStep
      } rep

      applied not {
        [| "\n" 0 thm renderNicely "\n" |] out
        /TODO:constructRewrite die
      } rep
    } /constructRewrite deffst

    <
      { ==goal
        1 goal .resolution ":" str .split * 1 neg -01 str .prefix ==pattern
        0 goal .children * ==child

          child _ .strategy .usedAntecedent _ ==usedByChild
        "" neq {
          { ==expr
            [
              { expr "( ph /\\ ps )" // } { $_
                [| "( " $ph unrewrite " /\\ " $ps unrewrite " )" |]
              }
              { 1 } {
                goal .antes { goal .from goal .to rewriteRecursive expr eq } grep ==src
                src len 1 lt {
                  [| "Could not find requested ante in unrewritten upstream." |] err
                  [| 0 expr renderNicely "\n" |] out
                  "F."
                } {
                  0 src *
                } ? *
              }
            ] conds
          } /unrewrite deffst

          usedByChild unrewrite =usedByChild

          [| "( " pattern " /\\ " usedByChild " )" |]
        } {
          pattern
        } ? *
      } /usedAntecedent deffst

      { ==goal =*pushStep
        goal _ .strategy .usedAntecedent ==requestedAnte
        0 goal .children * _ _ ==child .strategy .usedAntecedent ==childAnte
        1 goal .resolution ":" str .split * 1 neg -01 str .prefix ==pattern

        # |- ( requestedAnte -> goal .thm )
        childAnte "" eq {
          map ==lastGrammarMatch $_
          requestedAnte $=ph goal .thm $=ch child .thm $=ps
          [ /mpbid $$ ] pushStep

          # |- ( requestedAnte -> child .thm )
          map ==lastGrammarMatch $_
          child .thm $=ph
          [ /a1i$HERE7 $$ ] pushStep

          |pushStep child _ .strategy .construct

          # |- ( requestedAnte -> ( child .thm <-> goal .thm ) )
          map ==lastGrammarMatch $_
          requestedAnte $=ph pattern $=ps [| "( " child .thm " <-> " goal .thm " )" |] $=ch
          [ /syl$HERE4 $$ ] pushStep

          |pushStep requestedAnte pattern transformConjunct

          # |- ( pattern -> ( child .thm <-> goal .thm ) )
          |pushStep [| "( " pattern " -> ( " child .thm " <-> " goal .thm " ) )" |] constructRewrite
        } {
          # |- ( ( pattern /\ usedByChild ) -> goal .thm )
          [| "( " requestedAnte " -> " goal .thm " )" |] "( ( ph /\\ ps ) -> ch )" // -- $_
          $ps ==usedByChild
          [ /imp $$ ] pushStep

          # |- ( pattern -> ( usedByChild -> goal .thm ) )
          map ==lastGrammarMatch $_
          pattern $=ph [| "( " usedByChild " -> " goal .thm " )" |] $=ps
          [| "( " childAnte " -> " child .thm " )" |] $=ch
          [ /mpbird $$ ] pushStep

          # |- ( pattern -> ( childAnte -> child .thm ) )
          map ==lastGrammarMatch $_
          pattern $=ps
          [| "( " childAnte " -> " child .thm " )" |] $=ph
          [ /a1i$HERE8 $$ ] pushStep

          |pushStep child _ .strategy .construct

          # |- ( pattern -> ( ( usedByChild -> goal .thm ) <-> ( childAnte -> child .thm ) ) )
            |pushStep
            [| "( " pattern " -> "
                 "( ( " usedByChild " -> " goal .thm " ) <-> "
                 "( " childAnte " -> " child .thm " ) ) )" |]
          constructRewrite
        } ? *
      } /construct deffst
    > ==strategyRewrite

    { ==to ==from ==expr
      { from to rewriteRecursive } "..." deffst

      [
        { expr from eq } {
          to
        }
        { expr constants .has } {
          expr
        }
        { expr variables .has } {
          from expr mayDisjunct not ==symbolicRewrite

          symbolicRewrite {
            from " " str .split len 1 eq {
              [| "[ " to " / " from " ] " expr |]
            } {
              expr
            } ? *
          } {
            from " " str .split { ==x
              x variables .has {
                expr " " str .split { ==y
                  y variables .has {
                    x y markDisj
                  } rep
                } each
              } rep
            } each

            expr
          } ? *
        }
        { expr "( ph <-> ps )" // } { $_
          [| "( " $ph ... " <-> " $ps ... " )" |]
        }
        { expr "( ph -> ps )" // } { $_
          [| "( " $ph ... " -> " $ps ... " )" |]
        }
        { expr "( ph /\\ ps )" // } { $_
          [| "( " $ph ... " /\\ " $ps ... " )" |]
        }
        { expr "( ph /\\ ps /\\ ch )" // } { $_
          [| "( " $ph ... " /\\ " $ps ... " /\\ " $ch ... " )" |]
        }
        { expr "( ph \\/ ps )" // } { $_
          [| "( " $ph ... " \\/ " $ps ... " )" |]
        }
        { expr "( ph \\/ ps \\/ ch )" // } { $_
          [| "( " $ph ... " \\/ " $ps ... " \\/ " $ch ... " )" |]
        }
        { expr "( A u. B )" // } { $_
          [| "( " $A ... " u. " $B ... " )" |]
        }
        { expr "-. ph" // } { $_
          [| "-. " $ph ... |]
        }
        { expr "A R B" // } { $_
          [| $A ... " " $R ... " " $B ... |]
        }
        { expr "( A F B )" // } { $_
          [| "( " $A ... " " $F ... " " $B ... " )" |]
        }
        { expr "( F ` A )" // } { $_
          [| "( " $F ... " ` " $A ... " )" |]
        }
        { expr "; A B" // } { $_
          [| "; " $A ... " " $B ... |]
        }
        { expr "A e. B" // } { $_
          [| $A ... " e. " $B ... |]
        }
        { expr "A. x ph" // } { $_
          from " " str .split $x eq any
          to " " str .split $x eq any or {
            expr
          } {
            [| "A. " $x " " $ph ... |]
          } ? *
        }
        { expr "A. x e. A ph" // } { $_
          from " " str .split $x eq any
          to " " str .split $x eq any or {
            expr
          } {
            [| "A. " $x " e. " $A ... " " $ph ... |]
          } ? *
        }
        { expr "E. x e. A ph" // } { $_
          from " " str .split $x eq any
          to " " str .split $x eq any or {
            expr
          } {
            [| "E. " $x " e. " $A ... " " $ph ... |]
          } ? *
        }
        { expr "{ x | ph }" // } { $_
          from " " str .split $x eq any
          to " " str .split $x eq any or {
            expr
          } {
            [| "{ " $x " | " $ph ... " }" |]
          } ? *
        }
        { expr "{ x e. A | ph }" // } { $_
          from " " str .split $x eq any
          to " " str .split $x eq any or {
            expr
          } {
            [| "{ " $x " e. " $A ... " | " $ph ... " }" |]
          } ? *
        }
        { expr "[ A / x ] ph" // } { $_
          from " " str .split $x eq any
          to " " str .split $x eq any or {
            expr
          } {
            [| "[ " $A ... " / " $x " ] " $ph ... |]
          } ? *
        }
        { expr "A =/= B" // } { $_
          [| $A ... " =/= " $B ... |]
        }
        { expr "A = B" // } { $_
          $A from eq $B to eq and
          $B from eq $A to eq and or {
            expr
          } {
            [| $A ... " = " $B ... |]
          } ? *
        }
        { 1 } {
          [| "No rewrite rule known for: " expr |] warn
          expr
        }
      ] conds
    } '000.0 /rewriteRecursive deffst

    { ==goal ==pattern
      goal .antes pattern eq any {
        "" ==from "" ==to
        [
          { pattern "( ph <-> ps )" // } {
            $ph =from $ps =to
          }
          { pattern "A = B" // } {
            $A =from $B =to
          }
        ] conds

        from "" neq {
          [
              [
                goal .antes { ==ante
                  ante from to rewriteRecursive ==newAnte
                  newAnte ante neq newAnte ante ?
                } each
              ]
                goal .thm from to rewriteRecursive ==newThm
              newThm goal .thm neq newThm goal .thm ?
            newGoal
          ] /children goal .set

          [| "(rewrite:" pattern ")" |] /resolution goal .set
          strategyRewrite /strategy goal .set
          from /from goal .setExtra
          to /to goal .setExtra
        } {
          [| "Could not parse replacement pattern: " pattern |] err
        } ? *
      } {
        [| "Desired rewrite pattern not shown to be true." |] err
      } ? *
    } /rewrite deffst

    { ==goal
      1 neg goal .antes * goal rewrite
    } /andRewrite deffst

    <
      { ==goal
        [
          { goal .thm "A. x ps" // } {
            0 goal .children * _ .strategy .usedAntecedent
          }
          { goal .thm "A. x e. A ph" // } {
            [| $x " e. " $A |] ==restriction

            0 goal .children * _ .strategy .usedAntecedent ==childAnte
            map ==used
            childAnte splitConjunction { 1 -01 used =[] } each
            restriction used .has {
              used dom { restriction neq } grep makeConjunction
            } {
              childAnte
            } ? *
          }
          { 1 } {
            /ASSERT:strategyTakeAny die
          }
        ] conds
      } /usedAntecedent deffst

      { ==goal =*pushStep
        # alrimi / ralrimi as needed (rgen / ax-gen)

        {
          [| "Failed to construct take:any proof." |] err
          [| 0 goal .thm renderNicely "\n" |] out
        } ==failed

        goal _ .strategy .usedAntecedent ==ante

        # |- ( ante -> goal .thm )
        ante "" eq {
          /TODO:strategyTakeAny_empty_ante die
        } {
          [
            { goal .thm "A. x ps" // } { $_
              ante $=ph
              [ /alrimi $$ ] pushStep
              |pushStep [| "( " $ph " -> A. " $x " " $ph " )" |] constructUnused

              |pushStep 0 goal .children * _ .strategy .construct
            }
            { goal .thm "A. x e. A ps" // } { $_
              ante $=ph
              [ /ralrimi $$ ] pushStep

              |pushStep [| "( " $ph " -> A. " $x " " $ph " )" |] constructUnused

              # |- ( ante -> ( x e. A -> $ps ) )
              [ /ex <$
                ante ==ph
                [| $x " e. " $A |] ==ps
                $ps ==ch
              $> ] pushStep

              # |- ( ( ante /\ x e. A ) -> $ps )
              0 goal .children * ==child
              child _ .strategy .usedAntecedent ==childAnte

              [ /syl$HERE9 <$
                [| "( " ante " /\\ " $x " e. " $A " )" |] ==ph
                childAnte ==ps
                $ps ==ch
              $> ] pushStep
              |pushStep [| "( " ante " /\\ " $x " e. " $A " )" |] childAnte transformConjunct
              |pushStep child _ .strategy .construct
            }
            { 1 } failed
          ] conds
        } ? *
      } /construct deffst
    > ==strategyTakeAny
    { ==goal
      [
        { goal .thm "A. x ph" // } { $_
          0 ==needsRename
          goal .antes { ==ante
            $x ante requiredDisjuncts $x mustNotDisj any { 1 =needsRename } rep
          } each

          needsRename {
            [| "TODO:take:any" |] err
          } {
            goal .antes { ==ante
              $x ante requiredDisjuncts { $x markDisj } each
            } each

            [ goal .antes $ph newGoal ] /children goal .set
            /take:any /resolution goal .set
            strategyTakeAny /strategy goal .set
            $x /var goal .setExtra
          } ? *
        }
        { goal .thm "A. x e. A ph" // } { $_
          0 ==needsRename

          goal .antes { ==ante
            $x ante requiredDisjuncts $x mustNotDisj any { 1 =needsRename } rep
          } each

          needsRename {
            [| "TODO:take:any" |] err
          } {
            goal .antes { ==ante
              $x ante requiredDisjuncts { $x markDisj } each
            } each

            [ goal .antes [ [| $x " e. " $A |] ] cat $ph newGoal ] /children goal .set
            /take:any /resolution goal .set
            strategyTakeAny /strategy goal .set
            $x /var goal .setExtra
          } ? *
        }
        { 1 } {
          [| "Goal not in A. x e. A ph / A. x ph format." |] err
        }
      ] conds
    } /takeAny deffst

    {
      [| "\n" |] out
      0 ==i
      { ==indent ==goal
        [|
          i txt .produce .u _ out ")" out len
          indent -01 sub { " " } rep
          goal .isopen { "\e[31m???\e[0m " } { goal .resolution " " } ? *
          goal .thm " " str .split expandMeta { renderName " " } each "\n"
        |] out

        i 1 add =i
        goal .isopen not { goal .children { indent 2 add recurse } each } rep
      } /recurse deffst
      mainGoal 4 recurse
    } /tree deffst

    { ==index
      0 ==i
      < 1 ==notFound > ==theGoal
      { ==goal
        i index eq {
          goal =theGoal
        } rep
        i 1 add =i
        goal .isopen not { goal .children { recurse } each } rep
      } /recurse deffst
      mainGoal recurse

      theGoal .?notFound not {
        " " ==sep
        [| nonDisj dom sort { ==x
          x nonDisj * dom sort { ==y
            sep ", " =sep x renderName " <=> " y renderName
          } each
        } each "\n" |] out
        [| disj dom sort { ==x
          x disj * dom sort { ==y
            sep ", " =sep x renderName " <!> " y renderName
          } each
        } each "\n" |] out

        theGoal .antes { ==ante
          [| "* " ante " " str .split { renderName " " } each "\n" |] out
        } each
        [|
          "\e[1m-------------------------------------------------\e[0m\n"
          "resolution: " theGoal .resolution "\n"
          "\e[1m-------------------------------------------------\e[0m\n"
        |] out
        [| "|- " theGoal .thm " " str .split { renderName " " } each "\n" |] out
      } rep
    } /explain deffst

    { ==metaVar ==tokens
      0 ==disjunctionsViolated
      metaVar "^\\$([^.]+)$" regex { ==stem
        stem lastMetaVariables .has { stem lastMetaVariables * =metaVar } rep
        metaVar metaSubstitution .has {
          1 =disjunctionsViolated
          [| "Metavariable already assigned: " metaVar |] err
        } rep
      } rep

      tokens { ==x metaVar ==y
        x y gt { x y =x =y } rep
        x disj .has {
          y x disj * .has {
            1 =disjunctionsViolated
            [| "Proposed let would violate\e[0m " x renderName " <!> " y renderName |] err
          } rep
        } rep
        x nonDisj .has {
          y x nonDisj * .has {
            1 =disjunctionsViolated
            [| "Proposed let would violate " x renderName " <=> " y renderName |] err
          } rep
        } rep
      } each

      disjunctionsViolated not {
        tokens metaVar metaSubstitution =[]

        disj dom { ==x
          x disj * dom { ==y
            x metaVar eq { tokens { ==t t constants .has not { t y markDisj } rep } each } rep
            y metaVar eq { tokens { ==t t constants .has not { t x markDisj } rep } each } rep
          } each
        } each
      } rep
    } τlet /let deffst

    { ==goal ==pattern
      map ==variables
      [| [
        pattern " " str .split { ==tok
          1 tok str .prefix "$" eq {
              1 tok str .postfix _ # left on stack
            1 -01 variables =[]
          } {
            tok
          } ? *
        } each
      ] { " " } each -- |] =pattern

      0 ==assigned
      { ==mapping
        1 ==matching
        mapping dom { ==var
          var variables .has not {
            var mapping * [ var ] arrEq not {
              0 =matching
            } rep
          } rep
        } each

        matching {
          assigned { [| "Multiple matches for: " pattern |] err } rep
          1 =assigned

          mapping dom { ==var
            var variables .has {
              var mapping * var newMetaVariable let
            } rep
          } each
        } rep
      } /assignVariables deffst

      pattern "ph" // {
        goal .thm pattern // {
          $$ assignVariables
        } rep

        goal .antes { pattern // {
          $$ assignVariables
        } rep } each

        assigned not {
          [| "Did not match anywhere: " pattern |] err
        } rep
      } {
        [| "Not a well-formed formula: " pattern |] err
      } ? *
    } /match deffst

    { 1 -01 str .postfix ==metaVar
      metaVar lastMetaVariables * =metaVar

      0 ==success
      mainGoal openGoals { ==goal
        goal .thm metaVar eq {
          goal .antes makeConjunction " " str .split metaVar let
          1 =success
        } rep
      } each

      success not {
        [| "Failed to deduce:full." |] err
      } rep
    } /deduceFull deffst

    <
      { ==goal
        map ==used
        goal .children { ==child
          child _ .strategy .usedAntecedent splitConjunction { 1 -01 used =[] } each
        } each
        used dom makeConjunction
      } /usedAntecedent deffst

      { ==goal =*pushStep
        map ==children
        goal _ .strategy .usedAntecedent ==goalAnte
        goal .children { _ .thm children =[] } each

        { ==thm
          [
            { thm "( ps /\\ ch )" // } { $_
              goalAnte "" neq {
                # |- ( goalAnte -> ( ps /\ ch ) )
                goalAnte $=ph
                [ /jca$HERE3 $$ ] pushStep

                $ps constructSplit
                $ch constructSplit
              } {
                # |- ( ps /\ ch )
                $ps $ch $=ps $=ph
                [ /pm3.2i $$ ] pushStep

                $ph constructSplit
                $ps constructSplit
              } ? *
            }
            { 1 } {
              # |- ( goalAnte -> thm )
              thm children * ==child
              child _ .strategy .usedAntecedent ==ante

              [
                { ante "" neq } {
                  map ==lastGrammarMatch $_
                  goalAnte $=ph thm $=ch ante $=ps
                  [ /syl$HERE10 $$ ] pushStep

                  |pushStep $ph $ps transformConjunct
                  |pushStep child _ .strategy .construct
                }
                { goalAnte "" neq } {
                  map ==lastGrammarMatch $_
                  goalAnte $=ps thm $=ph
                  [ /a1i$HERE9 $$ ] pushStep

                  |pushStep child _ .strategy .construct
                }
                { 1 } {
                  |pushStep child _ .strategy .construct
                }
              ] conds
            }
          ] conds
        } /constructSplit deffst
        goal .thm constructSplit
      } /construct deffst
    > ==strategySplit
    { ==goal
      goal .thm splitConjunction ==clauses

      clauses len 2 lt {
        [| "Explicit split performed, but only a single clause." |] err
      } rep

      [ clauses { goal .antes -01 newGoal } each ] /children goal .set
      /split /resolution goal .set
      strategySplit /strategy goal .set
    } /split deffst

    <
      { ==goal
        1 goal .children * ==child
        goal .universal "A. x ph" // --
        $ph $x goal .value rewriteRecursive ==deduced

        map ==unique
          child _ .strategy .usedAntecedent splitConjunction { deduced neq } grep
        { 1 -01 unique =[] } each

        unique dom makeConjunction ==secondPart
        secondPart "" neq {
          [| "( " goal .universal " /\\ " secondPart " )" |]
        } {
          goal .universal
        } ? *
      } /usedAntecedent deffst

      { ==goal =*pushStep
        1 goal .children * ==child
        goal .universal "A. x ph" // --
        $ph $x goal .value rewriteRecursive ==deduced

        map ==unique
          child _ .strategy .usedAntecedent splitConjunction { deduced neq } grep
        { 1 -01 unique =[] } each

        unique dom makeConjunction ==secondPart

        secondPart "" neq {
          # |- ( ( universal /\ child .usedAntecedent <filtered> ) -> goal .thm )
          goal _ .strategy .usedAntecedent "( ph /\\ ch )" // --
          goal .thm $=th
          deduced $=ps
          [ /sylan$HERE1 $$ ] pushStep
          $ch ==filteredChildAnte

          # |- universal -> deduced
          goal .universal "A. x ph" // -- $_
          goal .value $=A

          [ /ax-mp$5 <$
            [| "( A. " $x " " $ph " -> " deduced " )" |] ==ps
            [| $A " e. _V" |] ==ph
          $> ] pushStep

          # |- value e. _V
          |pushStep 0 goal .children * _ .strategy .construct

          # |- ( value e. _V -> ( universal -> deduced ) )
          goal .universal "A. x ph" // -- $_
          deduced $=ps goal .value $=A
          "_V" $=V
          [| $A " " $x |] 1 freshVariables $=y
          [ /cla4gf $$ ] pushStep

          |pushStep [| "( " $y " e. " $A " -> A. " $x " " $y " e. " $A " )" |] constructUnused
          |pushStep [| "( " $ps " -> A. " $x " " $ps " )" |] constructUnused
          |pushStep [| "( " $x " = " $A " -> ( " $ph " <-> " $ps " ) )" |] constructRewrite

          # |- ( deduced /\ child .usedAntecedent <filtered> ) -> goal .thm
          child _ .strategy .usedAntecedent ==childAnte

          [ /syl$HERE11 <$
            [| "( " deduced " /\\ " filteredChildAnte " )" |] ==ph
            childAnte ==ps
            goal .thm ==ch
          $> ] pushStep

          |pushStep [| "( " deduced " /\\ " filteredChildAnte " )" |] childAnte transformConjunct
          |pushStep child _ .strategy .construct
        } {
          map ==lastGrammarMatch $_
          goal _ .strategy .usedAntecedent $=ph
          goal .thm $=ch
          deduced $=ps
          [ /syl$HERE13 $$ ] pushStep

          # |- universal -> deduced
          goal .universal "A. x ph" // -- $_
          goal .value $=A

          [ /ax-mp$6 <$
            [| "( A. " $x " " $ph " -> " deduced " )" |] ==ps
            [| $A " e. _V" |] ==ph
          $> ] pushStep

          # |- value e. _V
          |pushStep 0 goal .children * _ .strategy .construct

          # |- ( value e. _V -> ( universal -> deduced ) )
          goal .universal "A. x ph" // -- $_
          deduced $=ps goal .value $=A
          "_V" $=V
          [| $A " " $x |] 1 freshVariables $=y
          [ /cla4gf $$ ] pushStep

          |pushStep [| "( " $y " e. " $A " -> A. " $x " " $y " e. " $A " )" |] constructUnused
          |pushStep [| "( " $ps " -> A. " $x " " $ps " )" |] constructUnused
          |pushStep [| "( " $x " = " $A " -> ( " $ph " <-> " $ps " ) )" |] constructRewrite

          # |- ( deduced -> goal .thm )
          child _ .strategy .usedAntecedent ==childAnte

          childAnte "" neq {
            [ /syl$HERE14 <$ deduced ==ph childAnte ==ps goal .thm ==ch $> ] pushStep

            |pushStep deduced childAnte transformConjunct
            |pushStep child _ .strategy .construct
          } {
            [| "Child did not used explicitly instantiated value:" |] warn
            [| 0 deduced renderNicely "\n" |] out

            map ==lastGrammarMatch $_
            deduced $=ps goal .thm $=ph
            [ /a1i$HERE10 $$ ] pushStep

            |pushStep child _ .strategy .construct
          } ? *
        } ? *
      } /construct deffst
    > ==strategyInstantiate
    <
      { ==goal
        goal .universal "A. x e. A ph" // --
        $ph $x goal .value rewriteRecursive ==deduced

        0 goal .children * _ .strategy .usedAntecedent ==restrictionPart

        map ==unique
          1 goal .children * _ .strategy .usedAntecedent splitConjunction { deduced neq } grep
        { 1 -01 unique =[] } each
        unique dom makeConjunction ==secondPart

        restrictionPart "" neq {
          [| "( " restrictionPart " /\\ " goal .universal " )" |]
        } {
          goal .universal
        } ? * ==firstPart

        secondPart "" neq {
          [| "( " firstPart " /\\ " secondPart " )" |]
        } {
          firstPart
        } ? *
      } /usedAntecedent deffst

      { ==goal =*pushStep
        goal .universal "A. x e. A ph" // -- $_
        $ph $x goal .value rewriteRecursive ==deduced $A ==restriction

        0 goal .children * _ .strategy .usedAntecedent ==restrictionPart

        map ==unique
          1 goal .children * _ .strategy .usedAntecedent splitConjunction { deduced neq } grep
        { 1 -01 unique =[] } each
        unique dom makeConjunction ==secondPart

        restrictionPart "" neq {
          [| "( " restrictionPart " /\\ " goal .universal " )" |]
        } {
          goal .universal
        } ? * ==firstPart

        {
          restrictionPart "" neq {
            # |- ( restrictionPart /\ universal ) -> deduced
            map ==lastGrammarMatch $_
            restrictionPart $=ph goal .universal $=ch deduced $=th
            [| goal .value " e. " restriction |] $=ps
            [ /sylan$HERE2 $$ ] pushStep

            # |- ( restrictionPart -> value e. restriction )
            |pushStep 0 goal .children * _ .strategy .construct

            # |- ( ( value e. restriction /\ universal ) -> deduced )
            goal .universal "A. x e. B ph" // -- $_
            goal .value $x eq {
              [ /impcom <$
                [| goal .value " e. " restriction |] ==ps goal .universal ==ph deduced ==ch
              $> ] pushStep

              # |- ( universal -> ( value e. restriction -> deduced ) )
              [ /ra4 <$ $B ==A $x ==x $ph ==ph $> ] pushStep
            } {
              [ /imp <$
                [| goal .value " e. " restriction |] ==ph goal .universal ==ps deduced ==ch
              $> ] pushStep

              # |- ( value e. restriction -> ( universal -> deduced ) )
              goal .value $=A deduced $=ps
              [ /rcla4 $$ ] pushStep

              |pushStep [| "( " $ps " -> A. " $x " " $ps " )" |] constructUnused
              |pushStep [| "( " $x " = " $A " -> ( " $ph " <-> " $ps " ) )" |] constructRewrite
            } ? *
          } {
            /TODO:strategyInstantiateRestricted1 die
          } ? *
        } /constructDeducedInstance deffst

        secondPart "" neq {
          # |- ( ( firstPart /\ secondPart ) -> goal .thm )
          map ==lastGrammarMatch $_
          firstPart $=ph secondPart $=ch
          goal .thm $=th
          deduced $=ps
          [ /sylan$HERE3 $$ ] pushStep

          # |- ( firstPart -> deduced )
          constructDeducedInstance

          # |- ( deduced /\ secondPart ) -> goal .thm
          1 goal .children * ==child
          child _ .strategy .usedAntecedent ==childAnte

          [ /syl$HERE15 <$
            [| "( " deduced " /\\ " secondPart " )" |] ==ph
            childAnte ==ps
            goal .thm ==ch
          $> ] pushStep

          |pushStep [| "( " deduced " /\\ " secondPart " )" |] childAnte transformConjunct
          |pushStep child _ .strategy .construct
        } {
          # |- ( firstPart -> goal .thm )
          map ==lastGrammarMatch $_
          firstPart $=ph deduced $=ps goal .thm $=ch
          [ /syl$HERE16 $$ ] pushStep

          # |- ( firstPart -> deduced )
          constructDeducedInstance

          # |- ( deduced -> goal .thm }
          1 goal .children * ==child
          child _ .strategy .usedAntecedent ==childAnte

          childAnte "" neq {
            childAnte deduced eq {
              |pushStep child _ .strategy .construct
            } {
              /ASSERT:strategyInstantiateRestricted2 die
            } ? *
          } {
            /TODO:strategyInstantiateRestricted4 die
          } ? *
        } ? *
      } /construct deffst
    > ==strategyInstantiateRestricted
    { ==goal ==universal ==value
      [| universal " " str .split useLastMetas expandMeta { " " } each -- |] =universal
      goal .antes universal eq any {
        [
          { universal "A. x ph" // } {
            [| "(instantiate A. " $x " for " value ")" |] /resolution goal .set
            strategyInstantiate /strategy goal .set
            universal /universal goal .setExtra
            value /value goal .setExtra
            [
              [ ] [| value " e. _V" |] newGoal
              goal .antes [ $ph $x value rewriteRecursive ] cat goal .thm newGoal
            ] /children goal .set
          }
          { universal "A. x e. A ph" // } {
            [| "(instantiate A. " $x " for " value ")" |] /resolution goal .set
            strategyInstantiateRestricted /strategy goal .set
            universal /universal goal .setExtra
            value /value goal .setExtra
            [
              goal .antes [| value " e. " $A |] newGoal
              goal .antes [ $ph $x value rewriteRecursive ] cat goal .thm newGoal
            ] /children goal .set
          }
          { 1 } { [| "Not a universal quantifier: " universal |] err }
        ] conds
      } {
        [| "Universal quantifier not among antecedents: " universal |] err
      } ? *
    } /instantiate deffst

    <
      { ==goal
        map ==concluded
        0 goal .children * .thm splitConjunction { 1 -01 concluded =[] } each

        0 goal .children * _ .strategy .usedAntecedent ==firstAnte
          1 goal .children * _ .strategy .usedAntecedent _ ==rawSecondAnte splitConjunction
          { concluded .has not } grep
        makeConjunction ==secondAnte

        [
          { firstAnte "" neq secondAnte "" neq and } {
            [| "( " firstAnte " /\\ " secondAnte " )" |]
          }
          { firstAnte "" neq } {
            firstAnte
          }
          { secondAnte "" neq } {
            secondAnte
          }
          { 1 } {
            ""
          }
        ] conds
      } /usedAntecedent deffst

      { ==goal =*pushStep
        map ==concluded
        0 goal .children * .thm splitConjunction { 1 -01 concluded =[] } each

        0 goal .children * _ .strategy .usedAntecedent ==firstAnte
          1 goal .children * _ .strategy .usedAntecedent _ ==rawSecondAnte splitConjunction
          { concluded .has not } grep
        makeConjunction ==secondAnte

        rawSecondAnte "" eq {
          [| "Explicit conclusion was not used (constructing anyway + throwing away):" |] warn
          [| 0 0 goal .children * .thm renderNicely "\n" |] out
        } rep

        [
          { firstAnte "" neq secondAnte "" neq and } {
            # |- ( firstAnte /\ secondAnte ) -> goal .thm
            map ==lastGrammarMatch $_
            firstAnte $=ph secondAnte $=ch goal .thm $=th
            0 goal .children * .thm $=ps

            [ /sylan$HERE4 $$ ] pushStep

            |pushStep 0 goal .children * _ .strategy .construct

            # |- ( $ps /\ $ch ) -> child1 .thm
            [ /syl$HERE17 <$
              [| "( " $ps " /\\ " $ch " )" |] ==ph
              rawSecondAnte ==ps
              goal .thm ==ch
            $> ] pushStep

            |pushStep [| "( " $ps " /\\ " $ch " )" |] rawSecondAnte transformConjunct
            |pushStep 1 goal .children * _ .strategy .construct
          }
          { firstAnte "" neq } {
            map ==lastGrammarMatch $_
            # |- firstAnte -> goal .thm
            firstAnte $=ph
            goal .thm $=ch
            0 goal .children * .thm $=ps

            [ /syl$HERE5 $$ ] pushStep

            |pushStep 0 goal .children * _ .strategy .construct

            rawSecondAnte "" eq {
              # |- $ps -> child1 .thm
              map ==lastGrammarMatch $_
              0 goal .children * .thm $=ps
              1 goal .children * .thm $=ph
              [ /a1i$HERE11 $$ ] pushStep

              |pushStep 1 goal .children * _ .strategy .construct
            } {
              # |- $ps -> child1 .thm
              map ==lastGrammarMatch $_
              0 goal .children * .thm $=ph
              rawSecondAnte $=ps
              1 goal .children * .thm $=ch
              [ /syl$HERE7 $$ ] pushStep

              |pushStep $ph $ps transformConjunct
              |pushStep 1 goal .children * _ .strategy .construct
            } ? *
          }
          { secondAnte "" neq } {
            # |- secondAnte -> goal .thm
            map ==lastGrammarMatch $_
            secondAnte $=ph secondAnte $=ps
            goal .thm $=th
            0 goal .children * .thm $=ch
            [ /sylancl $$ ] pushStep

            # |- ( ph -> ps )
            [ /id$HERE5 $$ ] pushStep

            |pushStep 0 goal .children * _ .strategy .construct

            # |- ( ( secondAnte /\ conclusion ) -> 1 goal .children * .thm
            [ /syl$HERE18 <$
              [| "( " $ps " /\\ " $ch " )" |] ==ph
              rawSecondAnte ==ps
              goal .thm ==ch
            $> ] pushStep

            |pushStep [| "( " $ps " /\\ " $ch " )" |] rawSecondAnte transformConjunct
            |pushStep 1 goal .children * _ .strategy .construct
          }
          { 1 } {
            |pushStep 1 goal .children * _ .strategy .construct
          }
        ] conds
      } /construct deffst
    > ==strategyConclude
    { ==goal ==conclusion
      [| conclusion " " str .split { "" neq } grep useLastMetas expandMeta { " " } each -- |] =conclusion
      conclusion "ph" // {
        "(conclude)" /resolution goal .set
        strategyConclude /strategy goal .set
        [
          goal .antes conclusion newGoal
          goal .antes conclusion splitConjunction cat goal .thm newGoal
        ] /children goal .set
      } {
        [| "Desired conclusion is not a wff: " conclusion |] err
      } ? *
    } /conclude deffst

    <
      { ==goal
        goal .resolution "\\(rename (.+) to (.+)\\)" regex -- ==from ==to
        0 goal .children * _ .strategy .usedAntecedent to from rewriteRecursive
      } /usedAntecedent deffst

      { ==goal =*pushStep
        goal .resolution "\\(rename (.+) to (.+)\\)" regex -- ==from ==to
        goal _ .strategy .usedAntecedent ==goalAnte
        0 goal .children * ==child
        child _ .strategy .usedAntecedent ==childAnte

        map ==lastGrammarMatch $_
        [| "( " goalAnte " -> " goal .thm " )" |] $=ps
        [| "( " childAnte " -> " child .thm " )" |] $=ph
        from $=y to $=x
        [ /chvar $$ ] pushStep

        |pushStep [| "( " $ps " -> A. " $x " " $ps " )" |] constructUnused
        |pushStep [| "( " $x " = " $y " -> ( " $ph " <-> " $ps " ) )" |] constructRewrite
        |pushStep child _ .strategy .construct
      } /construct deffst
    > ==strategyRename
    { ==goal ==from ==to
      0 ==inUse
      goal .antes [ goal .thm ] cat {
        to -01 requiredDisjuncts to mustNotDisj any inUse or =inUse
      } each

      inUse not {
        goal .antes [ goal .thm ] cat {
          to -01 requiredDisjuncts { to markDisj } each
        } each

        [
          goal .antes from to rewriteRecursive goal .thm from to rewriteRecursive newGoal
        ] /children goal .set
        [| "(rename " from " to " to ")" |] /resolution goal .set
        strategyRename /strategy goal .set
      } {
        [| "Desired rename would violate non-disjunction constraints." |] err
      } ? *
    } /rename deffst

    { ==goal
      [
        goal .antes { ==ante
          [
            { ante "A < B" // } { $_
              [ $A "<" $B ante ]
            }
            { ante "A <_ B" // } { $_
              [ $A "<_" $B ante { =*pushStep
                [ /id <$ ante ==ph $> ] pushStep
              } ]
            }
            { ante "A > B" // } { $_
              [ $B "<" $A [| "( " ante " /\\ ( " $A " e. _V /\\ " $B " e. _V ) )" |] _
              { ==stepAnte =*pushStep
                # |- ( A > B /\ ( A e. _V /\ B e. _V ) ) -> B < A

                [ /mpbid <$
                  [| $B " < " $A |] ==ch stepAnte ==ph ante ==ps
                $> ] pushStep

                # |- ( A > B /\ ( A e. _V /\ B e. _V ) ) -> A > B
                [ /simpl <$
                  ante ==ph
                  [| "( " $A " e. _V /\\ " $B " e. _V )" |] ==ps
                $> ] pushStep

                # |- ( A > B /\ ( A e. _V /\ B e. _V ) ) -> ( A > B <-> B < A )
                [ /adantl$HERE2 <$
                  ante ==ch
                  [| "( " $A " e. _V /\\ " $B " e. _V )" |] ==ph
                  [| "( " $A " > " $B " <-> " $B " < " $A " )" |] ==ps
                $> ] pushStep

                [ /gt-lt $$ ] pushStep
              }_ ]
            }
            { ante "A >_ B" // } { $_
              [ $B "<_" $A ante ]
            }
            { ante "A = B" // } { $_
              [ $A "<_" $B [| "( " $A " e. RR /\\ " ante " )" |] { =*pushStep
                [ /eqle $$ ] pushStep
              } ]
              [ $B "<_" $A ante ]
            }
          ] conds
        } each
      ] ==graph

      map ==numbers
      graph { 3 dearray ==A -- ==B
        A evaluateArithmetics { -- 1 A numbers =[] } rep
        B evaluateArithmetics { -- 1 B numbers =[] } rep
      } each

      goal .thm "A R B" // { $_
        $A evaluateArithmetics { -- 1 $A numbers =[] } rep
        $B evaluateArithmetics { -- 1 $B numbers =[] } rep
      } rep

      map ==offsets

      graph [
        goal .thm "( ( A - B ) + C ) R D" // { $_
          $B evaluateArithmetics { ==B
            $C evaluateArithmetics { ==C
              C B sub ==result
              [| "( ( " $A " - " $B " ) + " $C " )" |] ==orig
              [
                { result 0 lt } {
                  [
                    [| "( " $A " - " result neg printNumber { " " } each -- " )" |] "<_" orig
                    [| "( " $A " e. RR /\\ ( " $B " e. RR /\\ " $C " e. RR ) )" |]
                    { /TODO:strategyRange20 die }
                  ]
                  [
                    orig "<_" [| "( " $A " - " result neg printNumber { " " } each -- " )" |]
                    [| "( " $A " e. RR /\\ ( " $B " e. RR /\\ " $C " e. RR ) )" |]
                    { /TODO:strategyRange21 die }
                  ]
                  1 [| " - " result neg printNumber { " " } each -- |] offsets =[]
                }
                { result 0 eq } {
                  [
                    $A "<_" orig
                    [| "( " $A " e. RR /\\ ( " $B " e. RR /\\ " $C " e. RR ) )" |]
                    { /TODO:strategyRange22 die }
                  ]
                  [
                    orig "<_" $A
                    [| "( " $A " e. RR /\\ ( " $B " e. RR /\\ " $C " e. RR ) )" |]
                    { /TODO:strategyRange23 die }
                  ]
                }
                { result 0 gt } {
                  [
                    [| "( " $A " + " result printNumber { " " } each -- " )" |] "<_" orig
                    [| "( " $A " e. RR /\\ ( " $B " e. RR /\\ " $C " e. RR ) )" |]
                    { /TODO:strategyRange24 die }
                  ]
                  [
                    orig "<_" [| "( " $A " + " result printNumber { " " } each -- " )" |]
                    [| "( " $A " e. RR /\\ ( " $B " e. RR /\\ " $C " e. RR ) )" |]
                    { /TODO:strategyRange25 die }
                  ]
                  1 [| " + " result printNumber { " " } each -- |] offsets =[]
                }
              ] conds
            } rep
          } rep
        } rep
      ] cat =graph

      graph [
        numbers dom { _ ==Aexpr evaluateArithmetics -- ==A
          numbers dom { _ ==Bexpr evaluateArithmetics -- ==B
            A B lt { [ Aexpr "<" Bexpr "" { # =*pushStep
              [| Aexpr " < " Bexpr |] constructArithmetics
            } ] } rep
            A B eq { [ Aexpr "<_" Bexpr "" { # =*pushStep
              [| Aexpr " <_ " Bexpr |] constructArithmetics
            } ] } rep
          } each
        } each
      ] cat ==graph

      graph [
        graph { 3 dearray ==right ==rel ==left
          left "( A + B )" // {
            [ $A rel [| "( " right " - " $B " )" |] ]
            1 [| " + " $B |] offsets =[]
          } rep
          left "( A - B )" // {
            [ $A rel [| "( " right " + " $B " )" |] ]
            1 [| " - " $B |] offsets =[]
          } rep
          right "( A + B )" // {
            [ [| "( " left " - " $B " )" |] rel $A ]
            1 [| " + " $B |] offsets =[]
          } rep
          right "( A - B )" // {
            [ [| "( " left " + " $B " )" |] rel $A ]
            1 [| " - " $B |] offsets =[]
          } rep
        } each
      ] cat ==graph

      goal .thm "( A + B ) R C" // { 1 [| " + " $B |] offsets =[] } rep
      goal .thm "( A - B ) R C" // { 1 [| " - " $B |] offsets =[] } rep
      goal .thm "C R ( A + B )" // { 1 [| " + " $B |] offsets =[] } rep
      goal .thm "C R ( A - B )" // { 1 [| " - " $B |] offsets =[] } rep

      graph [
        offsets dom { ==off [
          { 1 off * 0 "+" * eq } {
            graph { =*o [
              [| "( " 0 o off " )" |] 1 o [| "( " 2 o off " )" |]
              [| "( " 3 o " /\\ ( " 0 o " e. RR /\\ " 2 o " e. RR ) )" |] _ ==stepAnte
              { =*pushStep
                |o dump
                [ [| "( " 0 o off " )" |] 1 o [| "( " 2 o off " )" |] ] dump
                /TODO:strategyRange8 die
              }
            ] } each
          }
          { 1 off * 0 "-" * eq } {
            graph { =*o
              [
                [| "( " 0 o off " )" |] 1 o [| "( " 2 o off " )" |]
                [| "( " 3 o " /\\ ( " 0 o " e. RR /\\ " 2 o " e. RR ) )" |] _ ==stepAnte
                { =*pushStep
                  # TODO: This is a huge bunch of ante reorganization. Helper methods would be good
                  [ /mpbid <$
                    stepAnte ==ph
                    [| 0 o " " 1 o " " 2 o |] ==ps
                    [| "( " 0 o off " ) " 1 o " ( " 2 o off " )" |] ==ch
                  $> ] pushStep

                  # |- stepAnte -> [ 0 1 2 ] o
                  [ /syl$HERE19 <$ stepAnte ==ph 3 o ==ps [| 0 o " " 1 o " " 2 o |] ==ch $> ] pushStep
                  [ /simpl <$ 3 o ==ph [| "( " 0 o " e. RR /\\ " 2 o " e. RR )" |] ==ps $> ] pushStep
                  |o len 5 neq { |o dump /TODO:strategyRange die } rep
                  |pushStep 4 o *

                  # |- stepAnte -> ( [ 0 1 2 ] o <-> this_step )
                  [ /syl$HERE20 <$
                    stepAnte ==ph
                    [| "( " 0 o " e. RR /\\ " 2 o " e. RR /\\ " 3 off str .postfix " e. RR )" |] ==ps
                    [| "( " 0 o " " 1 o " " 2 o " <-> ( " 0 o off " ) " 1 o " ( " 2 o off " ) )" |] ==ch
                  $> ] pushStep

                  # |- stepAnte -> ( 0 o e. RR /\ 1 o e. RR /\ 3 off str .postfix e. RR )
                  [ /mpbird <$
                    stepAnte ==ph
                    [| "( ( " 0 o " e. RR /\\ " 2 o " e. RR ) /\\ " 3 off str .postfix " e. RR )" |] ==ch
                    [| "( " 0 o " e. RR /\\ " 2 o " e. RR /\\ " 3 off str .postfix " e. RR )" |] ==ps
                  $> ] pushStep

                  # |- stepAnte -> ( ( 0 o e. RR /\ 1 o e. RR ) /\ 3 off str .postfix e. RR )
                  [ /jctir <$
                    stepAnte ==ph
                    [| "( " 0 o " e. RR /\\ " 2 o " e. RR )" |] ==ps
                    [| 3 off str .postfix " e. RR" |] ==ch
                  $> ] pushStep

                  [ /simpr <$
                    3 o ==ph
                    [| "( " 0 o " e. RR /\\ " 2 o " e. RR )" |] ==ps
                  $> ] pushStep
                  |pushStep [| 3 off str .postfix " e. RR" |] constructDecimal

                  [ /a1i$HERE12 <$
                    stepAnte ==ps
                    [|
                      "( "
                        "( " 0 o " e. RR /\\ " 2 o " e. RR /\\ " 3 off str .postfix " e. RR )"
                      " <-> "
                        "( ( " 0 o " e. RR /\\ " 2 o " e. RR ) /\\ " 3 off str .postfix " e. RR )"
                      " )"
                    |] ==ph
                  $> ] pushStep

                  [ /df-3an <$
                    [| 0 o " e. RR" |] ==ph
                    [| 2 o " e. RR" |] ==ps
                    [| 3 off str .postfix " e. RR" |] ==ch
                  $> ] pushStep

                  # |- ( 0 o e. RR /\ 2 o e. RR /\ 3 off str .postfix e. RR ) -> ...
                  1 o "<_" eq {
                    [ /lesub1 <$ 0 o ==A 2 o ==B 3 off str .postfix ==C $> ] pushStep
                  } {
                    [ /ltsub1 <$ 0 o ==A 2 o ==B 3 off str .postfix ==C $> ] pushStep
                  } ? *
                }
              ]
              [
                [| "( " 0 o off " )" |] "<" 0 o
                [| "( " 0 o " e. RR /\\ " 3 off str .postfix " e. RR )" |]
                {
                  /TODO:strategyRange30 die
                }
              ]
              [
                [| "( " 2 o off " )" |] "<" 2 o
                [| "( " 2 o " e. RR /\\ " 3 off str .postfix " e. RR )" |]
                {
                  /TODO:strategyRange31 die
                }
              ]
            } each
          }
          { 1 } { /ASSERT:strategyRange3 die }
        ] conds } each
      ] cat ==graph

      map ==computed
      graph [
        graph { [ 0 2 ] -01 * { ==term
          term computed .has not {
            1 term computed =[]

            term evaluateArithmetics { ==value
              value 0 ge {
                [| value printNumber { " " } each -- |] ==strValue
                term strValue neq {
                  [ term "<_" strValue "" { # =*pushStep
                    [| term " <_ " strValue |] constructArithmetics
                  } ]
                  [ strValue "<_" term "" { # =*pushStep
                    [| strValue " <_ " term |] constructArithmetics
                  } ]
                } rep
              } rep
            } rep
          } rep
        } each } each
      ] cat ==graph

      graph
        { 3 dearray -201 -- neq } grep
        map ==seen
        { [| -01 { "$" } each |] _ seen .has -01 1 -01 seen =[] not } grep
    } /buildRangeGraphImpl deffst

    [ ] ==lastGraph
    "" ==lastGraphBuiltFor
    { ==goal
      goal sys .asm .rawAddress ==goalAddr
      goalAddr lastGraphBuiltFor neq {
        goal buildRangeGraphImpl =lastGraph
        goalAddr =lastGraphBuiltFor
      } rep

      lastGraph
    } /buildRangeGraph deffst

    { ==graph ==to ==from
        graph { 1 -01 * "<_" eq } grep
        graph { 1 -01 * "<" eq } grep
      cat ==ltLeGraph
      map ==visited
      map ==hopeless
      stack ==path

      map ==nextStep
      ltLeGraph { ==step
        0 step * ==from
          [ step ] from nextStep .has { from nextStep * cat } rep
        from nextStep =[]
      } each

      { ==src
        src hopeless .has not {
          src visited .has { src visited * } andif not {
            1 src visited =[]

            src to eq {
              0 path .top range path .data *
            } {
              src nextStep .has { src nextStep * { ==step
                [
                  step path .push
                  2 step * depthFirstSearch
                  path .pop --
                ] ==results
                results len 0 eq {
                  2 step * ==target
                  target visited .has { target visited * } andif not {
                    1 2 step * hopeless =[]
                  } rep
                } {
                  results _ len dearray
                } ? *
              } each } rep
            } ? *

            0 src visited =[]
          } rep
        } rep
      } /depthFirstSearch deffst

      [
        from depthFirstSearch
      ]
    } /findLeLtPaths deffst

    { ==path
      [ path { 1 -01 * "<" eq } each ] any
    } /isLtPath deffst

    {
      |isLtPath grep
    } /grepLtPaths deffst

    { ==arrays
      0 arrays * _ len arrays { _ ==p len ==l _ l gt { -- -- p l } rep } each --
    } /shortest deffst

    { [ -01 { =*step
      [| 0 step " e. RR" |] [| 2 step " e. RR" |]
    3 step } each ] { "" neq } grep } /pathAntecedents deffst

    { _ ==goal _ .thm ==thm buildRangeGraph ==graph
      [ ] ==initialAntecedents
        [
          { thm "A >_ B" // } { $_
            $B $A graph findLeLtPaths
            [ [| $A " e. _V" |] [| $B " e. _V" |] ] =initialAntecedents
          }
          { thm "A <_ B" // } { $_
            $A $B graph findLeLtPaths
          }
          { thm "A > B" // } { $_
            $B $A graph findLeLtPaths grepLtPaths
            [ [| $A " e. _V" |] [| $B " e. _V" |] ] =initialAntecedents
          }
          { thm "A < B" // } { $_
            $A $B graph findLeLtPaths grepLtPaths
          }
          { 1 } {
            /ASSERT:strategyRange1 die
          }
        ] conds
      shortest pathAntecedents initialAntecedents cat ==allAntecedents

      map ==unique allAntecedents { splitConjunction { 1 -01 unique =[] } each } each
      unique dom makeConjunction
    } /rangeAntecedent deffst

    { ==goal ==ante =*pushStep
      # |- ( ante -> goal .thm )
      goal _ .strategy .usedAntecedent ==goalAnte

      goalAnte "" neq {
        [ /syl$HERE21 <$ ante ==ph goalAnte ==ps goal .thm ==ch $> ] pushStep
        |pushStep ante goalAnte transformConjunct
      } {
        [ /a1i$HERE13 <$ ante ==ps goal .thm ==ph $> ] pushStep
      } ? *

      |pushStep goal _ .strategy .construct
    } /constructFromAnte deffs

    <
      { ==goal
        map ==fromChildren
        goal .children { 1 -01 .thm fromChildren =[] } each

        map ==unique
        goal rangeAntecedent splitConjunction { fromChildren .has not } grep [
          goal .children { _ .strategy .usedAntecedent splitConjunction _ len dearray } each
        ] cat { 1 -01 unique =[] } each
        unique dom makeConjunction
      } /usedAntecedent deffst

      { _ ==goal _ .thm ==thm buildRangeGraph ==graph
        =*pushStep
        { } =*finish [ ] ==path 0 ==needsLt
        goal _ .strategy .usedAntecedent ==usedAnte

        # |- ( usedAnte -> goal .thm )
        goal .children { ==child
          [ /mpancom <$ usedAnte ==ps goal .thm ==ch child .thm ==ph $> ] pushStep

          # |- ( usedAnte -> child .thm )
          |pushStep usedAnte child constructFromAnte

          # |- ( ( child .thm /\ usedAnte ) -> goal .thm )
          [| "( " child .thm " /\\ " usedAnte " )" |] =usedAnte
        } each

        [
          { thm "A >_ B" // } { $_
            # ( usedAnte -> A >_ B )
            [ /mpbird <$ usedAnte ==ph thm ==ps [| $B " <_ " $A |] ==ch $> ] pushStep

            # |- ( usedAnte -> $B <_ $A )
            $B $A graph findLeLtPaths shortest =path

            # |- ( usedAnte -> ( $A >_ $B <-> $B <_ $A ) )
            {
              [ /syl$HERE22 <$
                usedAnte ==ph
                [| "( " $A " e. _V /\\ " $B " e. _V )" |] ==ps
                [| "( " $A " >_ " $B " <-> " $B " <_ " $A " )" |] ==ch
              $> ] pushStep

              |pushStep usedAnte [| "( " $A " e. _V /\\ " $B " e. _V )" |] transformConjunct
              [ /gte-lte $$ ] pushStep
            } =finish
          }
          { thm "A <_ B" // } { $_
            $A $B graph findLeLtPaths shortest =path
          }
          { thm "A > B" // } { $_
            # ( usedAnte -> A >_ B )
            [ /mpbird <$ usedAnte ==ph thm ==ps [| $B " < " $A |] ==ch $> ] pushStep

            # |- ( usedAnte -> $B < $A )
            $B $A graph findLeLtPaths grepLtPaths shortest =path 1 =needsLt

            # |- ( usedAnte -> ( $A > $B <-> $B < $A ) )
            {
              [ /syl$HERE23 <$
                usedAnte ==ph
                [| "( " $A " e. _V /\\ " $B " e. _V )" |] ==ps
                [| "( " $A " > " $B " <-> " $B " < " $A " )" |] ==ch
              $> ] pushStep

              |pushStep usedAnte [| "( " $A " e. _V /\\ " $B " e. _V )" |] transformConjunct
              [ /gt-lt $$ ] pushStep
            } =finish
          }
          { thm "A < B" // } { $_
            $A $B graph findLeLtPaths grepLtPaths shortest =path 1 =needsLt
          }
          { 1 } {
            /ASSERT:strategyRange2 die
          }
        ] conds

        # |- ( usedAntecedent -> 0 path * { <_, < } 1 neg path * )
        { ==path
          0 path * =*step
          |step len 5 neq { |step dump /TODO:strategyRange die } rep

          3 step ==stepAnte
          4 step =*constructStep

          stepAnte "" neq {
            [ /syl$HERE24 <$ usedAnte ==ph stepAnte ==ps [| 0 step " " 1 step " " 2 step |] ==ch $> ] pushStep

            # |- ( usedAnte -> stepAnte )
            |pushStep usedAnte stepAnte transformConjunct

            # |- ( stepAnte -> [| 0 path * " { <_, < } " 1 path * |] )
            |pushStep constructStep
          } {
            [ /a1i$HERE14 <$ usedAnte ==ps [| 0 step " " 1 step " " 2 step |] ==ph $> ] pushStep

            |pushStep constructStep
          } ? *
        } /constructOneStepPath deffst
        { ==path
          path len 1 eq {
            0 path * ==step
            1 step * "<" eq {
              [ /ltled <$
                0 step * ==A
                2 step * ==B
                usedAnte ==ph
              $> ] pushStep

              |pushStep usedAnte [| 0 step * " e. RR" |] transformConjunct
              |pushStep usedAnte [| 2 step * " e. RR" |] transformConjunct
            } rep

            path constructOneStepPath
          } {
            path len 2 div ==split
            0 split range path * ==left
            split path len range path * ==right

            [ /letrd <$
              0 0 path * * ==A
              0 0 right * * ==B
              2 1 neg path * * ==C
              usedAnte ==ph
            $> ] pushStep

            |pushStep usedAnte [| 0 0 path * * " e. RR" |] transformConjunct
            |pushStep usedAnte [| 0 0 right * * " e. RR" |] transformConjunct
            |pushStep usedAnte [| 2 1 neg path * * " e. RR" |] transformConjunct

            left constructLeFromPath
            right constructLeFromPath
          } ? *
        } /constructLeFromPath deffst
        { ==path
          path len 1 eq {
            path constructOneStepPath
          } {
            path len 2 div ==split
            0 split range path * ==left
            split path len range path * ==right

            [
              { left isLtPath } {
                [ /ltletrd <$
                  0 0 path * * ==A
                  0 0 right * * ==B
                  2 1 neg path * * ==C
                  usedAnte ==ph
                $> ] pushStep

                left constructLtFromPath
                right constructLeFromPath
              }
              { right isLtPath } {
                [ /lelttrd <$
                  0 0 path * * ==A
                  0 0 right * * ==B
                  2 1 neg path * * ==C
                  usedAnte ==ph
                $> ] pushStep

                |pushStep usedAnte [| 0 0 path * * " e. RR" |] transformConjunct
                |pushStep usedAnte [| 0 0 right * * " e. RR" |] transformConjunct
                |pushStep usedAnte [| 2 1 neg path * * " e. RR" |] transformConjunct

                left constructLeFromPath
                right constructLtFromPath
              }
              { 1 } {
                /ASSERT:strategyRange4 die
              }
            ] conds
          } ? *
        } /constructLtFromPath deffst
        path needsLt |constructLtFromPath |constructLeFromPath ? *

        finish
      } /construct deffst
    > ==strategyRange
    { _ ==goal .thm ==thm
      [
        { thm "A >_ B" // } { $_
          $B $A goal buildRangeGraph findLeLtPaths len {
            "(range)" /resolution goal .set
            strategyRange /strategy goal .set
          } {
            [| "No <_ path found between endpoints." |] err
          } ? *
        }
        { thm "A <_ B" // } { $_
          $A $B goal buildRangeGraph findLeLtPaths len {
            "(range)" /resolution goal .set
            strategyRange /strategy goal .set
          } {
            [| "No <_ path found between endpoints." |] err
          } ? *
        }
        { thm "A > B" // } { $_
          goal buildRangeGraph ==graph
          $B $A graph findLeLtPaths grepLtPaths len {
            "(range)" /resolution goal .set
            strategyRange /strategy goal .set
          } {
            [| "No < path found between endpoints." |] err
          } ? *
        }
        { thm "A < B" // } { $_
          goal buildRangeGraph ==graph
          $A $B graph findLeLtPaths grepLtPaths len {
            "(range)" /resolution goal .set
            strategyRange /strategy goal .set
          } {
            [| "No < path found between endpoints." |] err
          } ? *
        }
        { 1 } {
          [| "Current goal not solvable by this command." |] err
        }
      ] conds

      "(range)" goal .resolution eq {
        map ==existingAntes
        goal .antes { 1 -01 existingAntes =[] } each

        goal rangeAntecedent splitConjunction {
          existingAntes .has not
        } grep {
          goal .antes -01 newGoal
        } '*0.0 /children goal .set
      } rep
    } /ranges deffst

    { ==goal ==ante
      goal .antes { ante neq } grep /antes goal .set
    } /drop deffst

    { ==goal ==pattern
      pattern "/(.*)/" regex { =pattern } { [| "(^| )" pattern "( |$)" |] =pattern } ? *
      goal .antes { ==ante 1 neg [ ante pattern regex not ] * } grep /antes goal .set
    } /dropMatching deffst

    {
      metaSubstitution dom { ==v
        [| v " = " v metaSubstitution * { renderName " " } each "\n" |] out
      } each
    } /lets deffst

    { ==token 0 token * 0 "$" * eq } '0.0 /tokenIsMetaVar deffst

    {
      map ==allVars
      disj dom { tokenIsMetaVar not } grep { ==x
        1 x allVars =[]
        x disj * dom { tokenIsMetaVar not } grep { ==y
          1 y allVars =[]
        } each
      } each

      9999 ==column
      { ==tok
        column tok len add 78 gt {
          "\n    " out 4 =column
          tok "^ *$" regex { "" =tok } rep
        } rep
        tok out
        column tok len add =column
      } /wrapOut deffst

      { ==X ==P ==R
        P len 0 eq { X len 0 eq } andif {
          R len 1 gt {
            [| "$d " R { " " } each "$." |] wrapOut "  " wrapOut
          } rep
        } {
          0 P X cat * ==u # any can be chosen

          P { u mustDisj not } grep { ==v
            R [ v ] cat P { v mustDisj } grep X { v mustDisj } grep findMaximalCliques
            P { v eq not } grep =P
            X [ v ] cat =X
          } each
        } ? *
      } /findMaximalCliques deffst

      [ ] allVars dom [ ] findMaximalCliques

      "\n" out
    } /exportDisjuncts deffst

    {
      mainGoal _ .strategy .usedAntecedent "" neq {
        [| "TODO: Top-level goal rendered with antecedents." |] err
      } rep

      # Non-syntax proof steps in easy to generate order, elements: [ /thmName substitution ]
      # Example:
      # [ /syl <ph => ph, ch => ch> ]
      # [ ... (steps for syl.1) ... ]
      # [ ... (steps for syl.2) ... ]
      # To debug, add info after $, e.g. syl$DEBUG1

      stack ==proofSteps
      { proofSteps .push } mainGoal _ .strategy .construct

      # All proof steps in nested arrays and final order
      # Example:
      # [
      #   [ /wph "wff ph" ]
      #   [ /wps "wff ps" ]
      #   [ /wch "wff ch" ]
      #   [ ... proving ph -> ps "|- ( ph -> ps )" ]
      #   [ ... proving ps -> ch "|- ( ps -> ch )" ]
      #   /syl
      #   "|- ( ph -> ch )"
      # ]
      stack ==proofTree
      { proofSteps .has } {
        proofSteps .pop ==step
        step 2 dearray ==substitution ==resolution
        resolution "$" str .split ==splitResolution
        0 splitResolution * ==resolutionName

        [
          { resolutionName collectedEHyps .has } {
            [
              resolution
              resolution collectedEHyps *
            ] proofTree .push
          }
          { resolutionName assertions .has } {
            resolutionName assertions * ==a

            [
              a .hyps { ==hyp [
                { hyp a .ctx isFHyp } {
                  hyp a .ctx getFHyp 2 dearray ==var ==type
                  var substitution .has not {
                    [| "Required variable " var " was undefined during processing " resolution "." |] err
                    [ "?" "?" ]
                  } {
                    var substitution * "" eq any {
                      [| "Required variable " var " was empty during processing " resolution "." |] err
                      [ "?" "?" ]
                    } {
                      [
                        var substitution * expandMeta type { } constructSyntax
                        [| type " " var substitution * expandMeta { " " } each -- |]
                      ]
                    } ? *
                  } ? *
                }

                { hyp a .ctx isEHyp } {
                  proofTree .has {
                    proofTree .pop _ ==eHypResolution
                    1 neg eHypResolution * ==result
                    result "?" neq {
                      [| hyp a .ctx getEHyp substitution applySubstitution expandMeta { " " } each -- |] ==required
                      required result neq {
                        step dump
                        [| "Incorrect result on $e-hyp: " hyp |] err
                        [| "Required:\n" 0 required renderNicely "\n" |] out
                        [| "Proven (by " 2 neg eHypResolution * "):\n" 0 result renderNicely "\n" |] out
                        [| "Required (raw):\n" required "\n" |] out
                        [| "Proven (raw):\n" result "\n" |] out
                      } rep
                    } rep
                    2 neg eHypResolution * "$" str .split 0 -01 * ==name
                    name assertions .has not { name "?" neq } andif {
                      step dump
                      [| "Attempt to resolve $e hypothesis by syntax construction: " hyp |] err
                    } rep
                  } {
                    step dump
                    [| "Stack underflow while creating proof." |] err
                  } ? *
                }

                { 1 } {
                  [| "Unknown theorem hypothesis during proof construction: " resolution |] err
                }
              ] conds } each

              resolution
              [| a .thm substitution applySubstitution expandMeta { " " } each -- |]
            ] proofTree .push
          }
          { resolutionName "?" eq } {
            [
              resolution
              "?"
            ] proofTree .push
          }
          { 1 } {
            step dump
            [| "Unknown resolution." |] err
          }
        ] conds
      } loop

      # Flattening
      stack ==flatProof
      { proofTree .has } {
        proofTree .pop ==top
        top sys .typed .type 1 eq {
          top flatProof .push
        } {
          1 ==last
          top reverse {
            last {
              0 =last --
            } {
              proofTree .push
            } ? *
          } each
        } ? *
      } loop

      flatProof
    } /buildProof deffst

    { ==flatProof
      # Just an array of metamath names
      flatProof .top ==flatProofMax
      flatProof .data =flatProof

      # Checking, duplication detection + tagging
      # Elements: [ "|- ph" <min proof step used> <final proof step> ]
      stack ==proofState
      # From "|- ph" to proof step which first produced it
      map ==seenThms

      0 flatProofMax range { ==i
        i flatProof * ==step
        # 0 proofState .top range proofState .data * dump
        # step dump
        step "$" str .split ==splitStep
        0 splitStep * ==stepName

        [
          { stepName collectedEHyps .has } {
            [ [| stepName collectedEHyps * { " " } each -- |] i i ] proofState .push
          }
          { stepName collectedFHyps .has } {
            [ [| stepName collectedFHyps * { " " } each -- |] i i ] proofState .push
          }
          { stepName assertions .has } {
            i ==blockStart
            map ==substitution
            map ==assignments
            map ==sources # DEBUGGING ONLY
            stepName assertions * ==a
            [ a .hyps { } each ] reverse { ==hyp
              proofState .pop 3 dearray
                hyp sources =[]
                =blockStart
                hyp assignments =[]
            } each

            [ a .hyps { } each ] { ==hyp
              [
                { hyp a .ctx isFHyp } {
                  hyp a .ctx getFHyp ==expected
                  hyp assignments * " " str .split ==toks

                  0 toks * 0 expected * neq {
                    [| "Broken proof: Could not unify $f-hyp: " hyp " of " step |] err
                  } rep

                  1 toks len range toks * 1 hyp a .ctx getFHyp * substitution =[]
                }
                { hyp a .ctx isEHyp } {
                  [| hyp a .ctx getEHyp substitution applySubstitution { " " } each -- |] ==expected
                  hyp assignments * expected neq {
                    [| "Broken proof: Could not unify $e-hyp: " hyp " of " step |] err
                    [| "On the stack:\n" 0 hyp assignments * renderNicely "\n" |] out
                    [| "Expected:\n" 0 expected renderNicely "\n" |] out
                    [| "Generated by: " hyp sources * flatProof * |] dump
                  } rep
                }
              ] conds
            } each

            [| a .thm substitution applySubstitution { " " } each -- |] ==newThm
            newThm seenThms .has {
              newThm seenThms * blockStart lt { blockStart i lt } andif {
                [| "*" newThm |] i flatProof =[]
                blockStart i range { ==j
                  [| "~" j flatProof * |] j flatProof =[]
                } each
                newThm seenThms * ==k
                1 k flatProof * str .prefix "!" neq {
                  [| "!" k flatProof * "!" newThm |] k flatProof =[]
                } rep
              } rep
            } {
              i newThm seenThms =[]
            } ? *

            [ newThm blockStart i ] proofState .push
          }
          { stepName "?" eq } {
            [ "?" i i ] proofState .push
          }
          { 1 } {
            [| "Unresolved name during proof checking: " step |] err
          }
        ] conds
      } each

      # Remove debugging $-suffixes
      0 flatProofMax range { ==i
        i flatProof * ==step

        1 step str .prefix ==t
        [
          { t "*" eq } { }
          { t "!" eq } {
            1 step str .postfix "!" str .split 2 dearray ==thm ==name
            [| "!" name "$" str .split 0 -01 * "!" thm |] i flatProof =[]
          }
          { step "?" eq } { }
          { 1 } {
            step "$" str .split 0 -01 * i flatProof =[]
          }
        ] conds
      } each

      flatProofMax flatProof len range { "~" -01 flatProof =[] } each

      # 0 proofState .top range proofState .data * dump
      # flatProof dump
      flatProof { 1 -01 str .prefix "~" neq } grep =flatProof
      # flatProof dump

      # Creating name map
      map ==nameMap
      map ==explicitNameMap
      map ==nameCount

      flatProof { ==step
        1 step str .prefix ==t
        [
          { t "*" eq } { }
          { t "!" eq } {
            1 step str .postfix "!" str .split 2 dearray ==thm ==name
            name nameCount .has { name nameCount * } { 0 } ? * 1 add name nameCount =[]
          }
          { step "?" eq } {
            # don't count
          }
          { 1 } {
            step nameCount .has { step nameCount * } { 0 } ? * 1 add step nameCount =[]
          }
        ] conds
      } each

      1 ==i
      proposition .hyps { ==name
        i name nameMap =[]
        i 1 add =i
      } each

      nameCount dom { ==a ==b
        a nameCount * b nameCount * lt
      } order nameCount dom * { ==name
        name nameMap .has not {
          i name explicitNameMap =[]
          i name nameMap =[] i 1 add =i
        } rep
      } each

      i ==totalMappedNames

      map ==taggedThms

      # Final output
      9999 ==column
      { ==tok
        column tok len add 78 gt {
          "\n      " out 6 =column
          tok "^ *$" regex { "" =tok } rep
        } rep
        tok out
        column tok len add =column
      } /wrapOut deffst

      { 1 sub ==i
        [ [
          i 20 mod "ABCDEFGHIJKLMNOPQRST" * i 20 div =i
          { i } {
            i 1 sub =i
            i 5 mod "UVWXY" * i 5 div =i
          } loop
        ] reverse { [ -01 ] str .fromArray } each ]
      } /encodeNumber deffst

      {
        "Z" wrapOut
      } /encodeTag deffst

      [ "( " explicitNameMap dom { " " } each ") " ] |wrapOut each

      flatProof { ==step
        1 step str .prefix ==t
        [
          { step "?" eq } {
            "?" wrapOut
          }
          { t "*" eq } {
            1 step str .postfix taggedThms * encodeNumber |wrapOut each
          }
          { t "!" eq } {
            1 step str .postfix "!" str .split 2 dearray ==thm ==name
            name nameMap * encodeNumber |wrapOut each
            encodeTag
            totalMappedNames _ 1 add =totalMappedNames thm taggedThms =[]
          }
          { 1 } {
            step nameMap * encodeNumber |wrapOut each
          }
        ] conds
      } each

      " $." wrapOut
      "\n" out
    } /exportProof deffst

    {
      buildProof exportProof
    } /exportCompressed deffst

    {
      buildProof ==proof
      [| "=== snip here for " proposition .name " ===\n" |] out
      [| "${" |] out
      exportDisjuncts
      proofContext collectEHyps _ ==hyps dom { ==name
        [| "  " name " $e " name hyps * { " " } each -- " $.\n" |] out
      } each
      [| "\n" |] out
      [| "  " proposition .name " $p " proposition .thm { " " } each -- " $=" |] out
      proof exportProof
      [| "$}\n" |] out
      [| "=== /snip here for " proposition .name " ===\n" |] out
    } /exportTheorem deffst

    { ==thing ==indent
      [
        { thing "" eq } {
          "<empty>"
        }
        { thing len 70 lt } {
          thing " " str .split {  _ "" eq { -- } { renderName } ? * " " } each --
        }
        { 3 thing str .prefix "|- " eq } {
          "|- " indent 3 add 3 thing str .postfix renderNicely
        }
        { thing "A. x ph" // } {
          "A. " $x renderName " "
          indent 5 add $ph renderNicely
        }
        { thing "( ph /\\ ps )" // } { $_
          "(  " indent 3 add $ph renderNicely "\n" indent { " " } rep
          "/\\ " indent 3 add $ps renderNicely " )"
        }
        { thing "( ph -> ps )" // } { $_
          "(  " indent 3 add $ph renderNicely "\n" indent { " " } rep
          "-> " indent 3 add $ps renderNicely " )"
        }
        { thing "A. x e. A ph" // } { $_
          "A. " $x renderName " e. " indent 8 add $A renderNicely "\n" indent 3 add { " " } rep
          indent 3 add $ph renderNicely
        }
        { thing "ph" // } { $_
          thing " " str .split { _ "" eq { -- } { renderName } ? * " " } each --
        }
        { thing "A" // } { $_
          thing " " str .split { _ "" eq { -- } { renderName } ? * " " } each --
        }
        { 1 } {
          "<unparseable> "
          thing " " str .split { _ "" eq { -- } { renderName } ? * " " } each --
        }
      ] conds
    } /renderNicely deffst

    map ==disj map ==nonDisj
    { ==x ==y
      x y eq { [| "Can not mark disjunct: " x |] err } rep
      x y gt { x y =x =y } rep
      x disj .has not { map x disj =[] } rep
      1 y x disj * =[]
    } /markDisj deffst

    { ==x ==y
      x y gt { x y =x =y } rep
      x disj .has {
        y x disj * .has
      } { 0 } ? *
    } /mustDisj deffst

    { ==x ==y
      x y gt { x y =x =y } rep
      x nonDisj .has not { map x nonDisj =[] } rep
      1 y x nonDisj * =[]
    } /markNonDisj deffst

    { ==x ==y
      x y eq { 1 } {
        x y gt { x y =x =y } rep
        x nonDisj .has {
          y x nonDisj * .has
        } { 0 } ? *
      } ? *
    } '00.0 /mustNotDisj deffst

    { ==termA ==termB
      1 ==may
      termA " " str .split { ==x
        x variables .has {
          termB " " str .split { ==y
            y variables .has {
              x y mustNotDisj {
                0 =may
              } rep
            } rep
          } each
        } rep
      } each
      may
    } /mayDisjunct deffst

    { ==termA ==termB
      termA " " str .split { ==x
        x variables .has {
          termB " " str .split { ==y
            y variables .has {
              x y eq {
                [| "Identical variable found on both sides of allegedly disjunct terms: " x |] err
                [| 0 termA renderNicely "\n" |] out
                [| 0 termB renderNicely "\n" |] out
              } rep
              x y mustDisj not {
                [| "Not all required variables were marked disjunct: " x " <!> " y |] err
                [| 0 termA renderNicely "\n" |] out
                [| 0 termB renderNicely "\n" |] out
              } rep
            } rep
          } each
        } rep
      } each
    } /checkMarkedDisjunct deffst

    [ ] ==loadedCommands
    [ ] ==loadedAutomations
    [ ] ==loadedDisplays
    { include }' /load deffst

    1 ==running
    0 ==selectedGoal
    proposition .disj { 2 dearray markDisj } each
    proposition .ctx _ =proofContext
    map ==proofEHyps
    proofContext collectEHyps _ ==collectedEHyps dom {
      [| -101 collectedEHyps * { " " } each -- |] 3 -01 str .postfix proofEHyps =[]
    } each
    map ==proofFHyps
    proofContext collectFHyps _ ==collectedFHyps dom {
      [| -101 collectedFHyps * { " " } each -- |] proofFHyps =[] # note we keep the type-code in
    } each

      [ ] proposition .thm [| -01 { " " } each -- |] 3 -01 str .postfix
    newGoal _ normalizeGoal ==mainGoal

    0 ==shownMessages

    { running } { [
      {
        mainGoal openGoals ==goals
        { selectedGoal goals len ge selectedGoal 0 gt and } { selectedGoal 1 sub =selectedGoal } loop

        goals len {
          selectedGoal goals * _ normalizeGoal .isopen not
        } { 0 } ? *
      }' { } loop


      { ==f { goals len f { "\e[32mWe are done here.\e[0m\n" out } ? * } } =*unlessSolved

      messages shownMessages eq {
        {
          " " ==sep
          [| nonDisj dom sort { ==x
            x nonDisj * dom sort { ==y
              sep ", " =sep x renderName " <=> " y renderName
            } each
          } each "\n" |] out
          [| disj dom sort { ==x
            x disj * dom sort { ==y
              sep ", " =sep x renderName " <!> " y renderName
            } each
          } each "\n" |] out

          selectedGoal goals * ==goal

          collectedEHyps dom { ==name
            [| "+ " name collectedEHyps * _ len 1 -01 range -01* { renderName " " } each "\n" |] out
          } each
          goal .antes { ==ante
            0 ante " " str .split /wff metaLogicParsers * * not {
              [| "! " 2 ante renderNicely |] err
            } { --
              [| "* " 2 ante renderNicely "\n" |] out
            } ? *
          } each
          loadedDisplays len 0 gt {
            |out _ ==origOut =*?out
            {
              origOut =out
              [| "\e[1m-------------------------------------------------\n" |] out
              out
            } =out

            [
              loadedDisplays "*" | each
            ] _ ==litter len 0 gt {
              [| "Loaded displays left stuff on the stack." |] err
              litter dump
            } rep
          } rep

          [|
            "\e[1m-------------------------------------------------"
            " (" selectedGoal 1 add txt .produce .u "/" goals len txt .produce .u ")"
            # goal .autohint "" neq { " \e[32m(hint: " goal .autohint ")" } rep
            "\e[0m\n"
          |] out
          [| "|- " 3 goal .thm renderNicely "\n" |] out
        } unlessSolved *
      } rep

      messages =shownMessages

      perfstats
      "proof2> " sys .out .writeall
      inputCmd ==cmd ==args

      [
        { cmd "quit" eq } { 0 =running }
        { cmd "todo" eq } { selectedGoal goals len 1 sub lt { selectedGoal 1 add =selectedGoal } rep }
        { cmd "next" eq } { selectedGoal goals len 1 sub lt { selectedGoal 1 add =selectedGoal } rep }
        { cmd "prev" eq } { selectedGoal 0 gt { selectedGoal 1 sub =selectedGoal } rep }
        { cmd "norm" eq } { selectedGoal goals * normalizeGoal } unlessSolved
        { cmd "use" eq } { args selectedGoal goals * useTheorem } unlessSolved
        { cmd "let" eq { args "^(\\$[^=]+) = (.*)" regex } andif } { ==metaVar " " str .split { "" neq } grep ==tokens
          tokens metaVar let
          selectedGoal goals * normalizeGoal
        } unlessSolved
        { cmd "match" eq } { args selectedGoal goals * match } unlessSolved
        { cmd "instantiate" eq { args "(.*) for (.*)" regex } andif } { selectedGoal goals * instantiate } unlessSolved
        { cmd "conclude" eq } { args selectedGoal goals * conclude } unlessSolved
        { cmd "normalize:all" eq } { goals |normalizeGoal each }
        { cmd "deduce:full" eq { args "^(\\$.+)" regex } andif } { ==metaVar
          metaVar deduceFull
          selectedGoal goals * normalizeGoal
        } unlessSolved
        { cmd "split" eq } { selectedGoal goals * split } unlessSolved
        { cmd "lets" eq } { lets }
        { cmd "nondisj" eq { args "^(.*) <=> (.*)" regex } andif } { markNonDisj }
        { cmd "rewrite" eq } { args selectedGoal goals * rewrite } unlessSolved
        { cmd "and:rewrite" eq } { selectedGoal goals * andRewrite } unlessSolved
        { cmd "take:any" eq } { selectedGoal goals * takeAny } unlessSolved
        { cmd "rename" eq { args "(.) to (.)" regex } andif } { selectedGoal goals * rename } unlessSolved
        { cmd "range" eq } { selectedGoal goals * ranges } unlessSolved
        { cmd "drop" eq { args "all matching (.*)" regex } andif } { selectedGoal goals * dropMatching } unlessSolved
        { cmd "drop" eq } { args selectedGoal goals * drop } unlessSolved
        { cmd "load" eq } { args load }
        { cmd "tree" eq } { tree }
        { cmd "explain" eq { args "^(\\d+)$" regex } andif } { txt .consume .u explain }
        { cmd "export:disj" eq } { exportDisjuncts }
        { cmd "export:compressed" eq } { exportCompressed }
        { cmd "export:theorem" eq } { exportTheorem }
        { cmd "freeze" eq } { { _ { * }_ args sys .freeze * } !! * }
        loadedCommands "*" | each
      ] conds
    ] _ ==residue len 0 gt {
      [| "Something left on the stack:" |] err
      residue dump
    } rep } loop
  } /prove2Proposition deffd

  { ==name
    name assertions .has { name assertions * .type "p" eq } { 0 } ? * {
      name assertions * prove2Proposition
    } {
      [| name " is not a provable proposition\n" |] out
      name show
    } ? *
  } /prove2 deffd

  { ==name
    [
      { name assertions .has } {
        name assertions * ==a
        a .hyps { ==hyp
          /hypothesis: hyp cat dump
          [
            { hyp a .ctx isEHyp } {
              hyp a .ctx getEHyp ==hypToks
              [| hypToks { renderName " " } each "\n" |] out
              [ 1 hypToks /wff logicParsers * * ] dump
            }
            { hyp a .ctx isFHyp } {
              hyp a .ctx getFHyp ==hypToks
              [| hypToks { renderName " " } each "\n" |] out
            }
            { 1 } { "\e[31mHypothesis is neither e- nor f-hyp. Probably a bug.\e[0m" dump }
          ] conds
        } each
        /theorem: dump
        [ 1 a .thm /wff logicParsers * * ] dump
      }
      { 1 } { [| "\e[31m" name " is not a proposition\e[0m" |] dump }
    ] conds
  } /parseTokens deffd

  {
    1 ==running
    { running } {
      "> " sys .out .writeall
      inputCmd ==cmd ==args

      [
        { cmd "" eq } { 0 =running }
        { cmd "quit" eq } { 0 =running }
        { cmd "show" eq } { args show }
        { cmd "parse" eq } { args parseTokens }
        { cmd "prove" eq } { args prove }
        { cmd "prove2" eq } { args prove2 }
        { cmd "silent" eq } { 2 =silent }
        { cmd "quiet" eq } { 1 =silent }
        { cmd "nosilent" eq } { 0 =silent }
      ] conds
    } loop
  }
> -- /interactive deffd

interactive

# vim: syn=elymas
